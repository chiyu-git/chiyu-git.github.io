---
layout: post
#标题配置
title:  Javascript Advanced Note
#时间配置
date:   2019-3-16 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note front-end
---

* content
{:toc}




# 1. 基础总结深入

## 数据类型

### 分类

- 基本类型（值类型）

  - String: 任意字符串

  - Number: 任意的数字

  - boolean: true/false

  - undefined: undefined

  - null: null

- 引用类型（对象类型）

  - Object: 任意对象

  - Function: 一种特别的对象(可以执行)

  - Array: 一种特别的对象(数值下标, 内部数据是有序的)

### 判断

- typeof:

  - 可以判断: undefined/ 数值 / 字符串 / 布尔值 / function

  - 不能判断: null与object  object与array

- ```js
  typeof null //object
  typeof array //object
  ```

  - 返回的是数据类型的字符串表达，全都是小写
   - 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 `null` 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，`typeof null`就错误的返回了"`object"`。（[reference](http://www.2ality.com/2013/10/typeof-null.html)）
   - ECMAScript提出了一个修复（通过opt-in），但[被拒绝](http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null)。这将导致typeof null === 'object'。

- instanceof:
  - instanceof运算符用于测试**构造函数**的prototype属性是否出现在对象的原型链中的任何位置
  - 判断对象的是否是某个具体类（构造函数的实例）

- ===
  - 可以判断: undefined, null

  - 因为这两个类型都只有一个值

- `Object.prototype.toString.call(target) `
  - 返回固定字符串： [Object target类型]
  - `Object.prototype.toString.call(target).slice(8,-1)`，就可以返回准确的类型
  - Array.prototype也是数组，类似的Number.prototype是number类型的对象
  - 实例本身是没有`constructor`属性的，`constructor`属性在原型上，为了保持一致性，所以`Array.prototype`也是`Array`
  - ES5开始，可以检查Null 和 undefined

### undefined与null的区别?

- undefined代表**定义未赋值**
  - 注意，用未定义的变量是会报错的，未定义的属性是undefined

- `nulll`定义并赋值了, 只是值为`null`
- 什么时候给变量赋值为null呢?

  - 初始赋值, 表明将要赋值为对象

  - 结束前, 让对象成为垃圾对象(被浏览器的垃圾回收器回收)

### 严格区别变量类型与数据类型?

- **数据**的类型
  - 基本类型（五种基本类型）

  - 对象类型

- **变量**的类型(变量内存值的类型)
  - 基本类型: 保存就是基本类型的数据

  - 引用类型: 保存的是地址值（指向对象类型数据）

- `JS`是弱类型语言，全都是var声明变量，变量是没有类型的，判断的其实是变量保存的值的类型

## 数据、变量、内存

### **什么是数据?**

- 存储在内存中代表特定信息的'东东', 本质上是0101...

- 数据的特点: 可传递, 可运算

- 一切皆数据（基本数据、对象数据）

- 内存中所有**操作的目标**: **数据**
  - 算术运算

  - 逻辑运算

  - 赋值

  - 运行函数

### **什么是内存?**

- **内存条**通电后产生的可储存数据的空间(临时的)

- 内存产生和死亡: 内存条(电路版)==>通电==>产生内存空间==>存储数据==>处理数据==>断电==>内存空间和数据都消失

- 一块小内存的2个数据

  - 内部存储的数据

  - 地址值

- 内存分类

  - 栈: 全局变量/局部变量 （函数名本质上是一个变量名）

  - 堆: 对象（包括对象的属性、方法）

### **什么是变量?**

- 可变化的量, 由变量名和变量值组成

- 每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据

### **内存,数据, 变量三者之间的关系**

- 内存用来存储数据的临时空间

- 变量是内存的标识

- 数据赋值给变量是数据有了实际意义，仅仅是内存中存储着的“18”，可能是年龄，年份，时间等等，只有赋值给了变量才变得有意义



### 关于赋值与内存的问题

- var a = xxx, a内存中到底保存的是什么?
- `xxx`是**基本数据,** 保存的就是这个数据
- `xxx`是**对象**, 保存的是对象的地址值

- `xxx`是一个**变量**, 保存的`xxx`的内存内容(可能是基本数据, 也可能是地址值)

- 对象的赋值只能有一次，就是创建的时候，**其他变量想要获取同一个对象的地址值**，只能赋值变量，即使创建一个内容一模一样的对象，地址值也是不同的

- 关于引用变量赋值的问题

```js
var obj1 = {};
var obj2 = obj1; 
//这一步的操作是：把obj1保存的内容（{}的地址值）赋值给obj2，而不是把obj1的地址值赋值，因为所有的变量都是有自己的地址值的（用于在内存中查找该数据）
```

- 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据

- 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象

### 形参赋值

```js
var a = {age:12}

function fn (obj){
  obj = {age:15}
}
fn(a)
console.log(a.age) //12
//实参赋值给形参，obj保存了a的内存内容，age12的对象的内存地址值，然后obj获得了a的保存内容，然后又重新获取了一个地址值，age15，然后函数运行完毕，fn的执行上下文出栈，age15成为垃圾对象
//函数操作的永远是形参，只是形参保存了传入的实参的值
var b = 2 
function fn2 (animal){
  animal = 3
}
fn(b)
console.log(b) //2
```

### 关于数据传递的问题

- 在`js`调用函数时传递变量参数时, 是值传递还是引用传递

- 理解1: 都是值(基本/地址值)传递

- 理解2: 可能是值传递, 也可能是引用传递(地址值)

### `JS`引擎如何管理内存

- 内存生命周期
  - 分配小内存空间, 得到它的使用权
  - 存储数据, 可以反复进行操作
  - 释放小内存空间

  - 释放内存

- 局部变量: 函数执行完自动释放

- 对象: 成为垃圾对象==>垃圾回收器回收 //即使是函数内部新建的对象

- 所以要尽量少全局变量

### 对象

- 什么是对象?
  - 多个数据的封装体
  - 用来保存多个数据的容器
  - 一个对象代表现实中的一个事物（Object）

- 为什么要用对象?
  - 统一管理多个数据

- 对象的组成
  - 属性: 属性名(字符串，引号省略了)和属性值(任意)组成

  - 方法: 一种特别的属性(属性值是函数)

  - 如何访问对象内部数据?
    - .属性名: 编码简单, 有时不能用
    - ['属性名']: 编码麻烦, 能通用

- 问题: 什么时候必须使用['属性名']的方式?

  - 属性名包含特殊字符: - 空格

  - 属性名不确定 //用一个变量来存储变量名，可以做到任意变量名读取同一个数据

```js
var n = “变量名”
p.[n] //p.变量名 可以随时读取数据

//属性名不确定
var propName = "bge"
var value = 18
p[propName] = value
console.log(p[propName]) //18
console.log(p.age) //从有值→undefined
console.log(p.bge) //从undefined→18
```

### 函数

- 什么是函数?

  - 实现特定功能的n条语句的封装体

  - 只有函数是可以执行的, 其它类型的数据不能执行

- 为什么要用函数?
  - 提高代码复用

  - 便于阅读交流

- 如何定义函数?

  - 函数声明

  - 表达式

```js
var b = function c () {
  console.log(c) //可见
}
b()
console.log(c) //Uncaguht ReferenceError： c is not defined
```

- 表达式形式无法访问c，这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效。

- 如何调用(执行)函数?

  - test(): 直接调用

  - obj.test(): 通过对象调用

  - new test(): new调用

  - test.call/apply(obj): 临时让test成为obj的方法进行调用

- 什么函数才是回调函数?

  - 你定义的

  - 你没有调

  - 但最终它执行了(在某个时刻或某个条件下)

- 常见的回调函数?

  - `dom`事件回调函数 ==>发生事件的`dom`元素（与用户交互）
  - 定时器回调函数 ===>window
  - 延时定时器

  - 循环定时器
  - `ajax`请求回调函数(后面讲)（与后台交互）

  - 生命周期回调函数(后面讲)

### `IIFE`

- 理解

  - 全称: Immediately-Invoked Function Expression

  - 立即调用函数表达式

- 作用

  - 隐藏实现

  - 不会污染外部(全局)命名空间

  - 用它来编码`js`模块

- 只有function(){}会报错，要么使用要么赋值存起来 //`SyntaxError: function statement requires a name`

- (function(){})();  //匿名函数自调用，也就是`IIFE`

### this是什么?

- 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window

```:bullettrain_front:
function fun1(){
	function fun2(){
	console.log(this); //window，没有直接指定就是window
	}
}
```

- 所有函数内部都有一个变量this

- 它的值是**调用函数的当前对象**

- 如何确定this的值?

  - test(): window //相当于window.test()

  - p.test(): p

  - new test(): 新创建的对象

  - p.call(obj): obj

# 2. 函数高级

## 原型与原型链

### 原型(prototype)

- 函数的prototype属性(图)
  - 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象) 
  - 内建函数则指向的Object有许多定义好的方法

- 原型对象中有一个属性constructor, 它指向构造函数对象

- 给原型对象添加属性(一般都是方法)
  - 作用: 函数的所有实例对象自动拥有原型中的属性(方法)

### 显式原型与隐式原型

- 每个函数function都有一个prototype，即显式原型（属性）
  - 创建函数的时候，内部有一条内部语句：`Fn.prototype={}`

- 每个实例对象都有一个`__proto__`，可称为隐式原型（属性）

- 对象的隐式原型的值为其对应构造函数的显式原型的值
  - 创建对象的时候，内部有一条语句：`this.__proto__=Fn.prototype`

![1546691834085](F:\OneDrive\JS\纲略合集\assets\1546691834085.png)

### 总结:

- 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象

- 对象的`__proto__`属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值

- 程序员能直接操作显式原型, 但不能直接操作隐式原型(`ES6`之前)

### 原型链

- 原型链(图解)
  - ![1546692183103](F:\OneDrive\JS\纲略合集\assets\1546692183103.png)
   - 可以直接访问到的对象只有栈内存的三个
   - 变量找作用域链，对象的属性找原型链

- 访问一个对象的属性时，先在自身属性中查找，找到返回如果没有, 再沿着__proto__这条链向上查找, 找到返回如果最终没找到, 返回undefined

- 别名: 隐式原型链
  - 作用: 查找对象的属性(方法)

- 构造函数/原型/实体对象的关系2(图解)
- ![1546692302049](F:\OneDrive\JS\纲略合集\assets\1546692302049.png)
- 探索`instanceof`
  - `instanceof`是如何判断的?
  - 表达式: `A instanceof B`
  - 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false
  - Function是通过new自己产生的实例
- ![1546692412784](F:\OneDrive\JS\纲略合集\assets\1546692412784.png)
- ![1546692426651](F:\OneDrive\JS\纲略合集\assets\1546692426651.png)
- Object.create(prototype, [descriptors])相当于是在`o1, o2` 再接一个`__proto__`指向`o1 ,o2`的对象，他们没有其他constructor和prototype属性，因为它们都是实例

### 面试题

![1546692544602](F:\OneDrive\JS\纲略合集\assets\1546692544602.png)

![1546692548349](F:\OneDrive\JS\纲略合集\assets\1546692548349.png)

- 凡是实例，都会经过`Object.prototype`
- 所有的函数，都是由Function构造的（都是Function 的实例），凡是函数都会经过`Function.porotype` 和` Object.prototype`

## 执行上下文与执行上下文栈

> https://juejin.im/post/5ba32171f265da0ab719a6d7

### 变量提升与函数提升

- 变量声明提升
  - 通过var定义(声明)的变量, 在定义语句之前就可以访问到

  - 值: undefined

- 函数声明提升

  - 通过function声明的函数, 在之前就可以直接调用

  - 值: 函数定义(对象)

- 用函数表达式创建的函数，只遵循变量提升

  - `var fun =function(){}`

- 面试题

  - ```js
    var a =3 
    function fn(){
      console.log(a) 
      var a = 4
    }
    fn() //undefined
    //实际的过程
    var a = 3
    function fn(){
      var a 
      console.log(a)
      a = 4
    }
    ```

  - ```js
    fn() //undefined
    
    var a =3 
    function fn(){
      console.log(a)
    }
    
    //实际的过程
    var a
    var fn 
    fn = function(){
      console.log(a)
    }
    fn() //undefined
    a = 3
    ```

### 问题: 变量提升和函数提升是如何产生的?（执行上下文）

- 在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在**作用域的最开始的部分**。

- 函数提升要比变量提升的优先级要高一些，且**不会被变量声明覆盖**，但是会被**变量赋值之后覆盖**。

- 优先级：

  - ```js
    console.log(a) //f a(){console.log(10)}
    console.log(a()) //undefined，因为函数a没有定义返回值
    var a = 3 
    
    function a(){
      console.log(10)
    }
    console.log(a) //3
    a=6
    console.log(a()) //a is not a function
    
    //实际过程
    var a //函数的声明
    a = function(){
      console.log(10)
    }
    var a  //变量的声明,仅声明，不会覆盖函数定义
    
    console.log(a) //f a(){console.log(10)}
    console.log(a()) //undefined，因为函数a没有定义返回值
    
    a = 3 
    console.log(a) //3
    a=6
    console.log(a()) //a is not a function
    ```

### 执行上下文（execution context）

- 码分类(位置)

  - 全局代码

  - 函数(局部)代码

- 全局执行上下文

  - 在执行全局代码前将window确定为全局执行上下文

  - 对全局数据进行预处理
    - function声明的全局函数==>赋函数定义(fun), 添加为window的方法
    - var定义的全局变量==>undefined, 添加为window的属性
    - this==>赋值(window，传递引用)
    - 开始执行全局代码

- 函数执行上下文

  - 在**调用函数**, 准备执行函数体之前, **创建**对应的函数执行上下文 (虚拟的, 存在于栈中，方便调用完函数之后内存的释放)
  - 对局部数据进行预处理
    - 形参变量==>赋值(实参)==>添加为执行上下文的属性
    - arguments==>赋值(实参列表), 添加为执行上下文的属性
    - function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
    - var定义的局部变量==>undefined, 添加为执行上下文的属性
    - this==>赋值(调用函数的对象，传递引用)
    - 开始执行函数体代码

### 执行上下文栈（不是栈内存）

- 栈：后进先出；队列：先进先出

- 浏览器中的JS解释器被实现为单线程，这也就意味着同一时间只能发生一件事情，其他的行为或事件将会被放在叫做执行栈里面排队。下面的图是单线程栈的抽象视图：

![1546693704393](F:\OneDrive\JS\纲略合集\assets\1546693704393.png)

- 执行步骤

  - 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象

  - 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)

  - 在函数执行上下文创建(函数被调用时)后, 将其添加到栈中(压栈)

  - 在当前函数执行完后,将栈顶的对象移除(出栈)

  - 当所有的代码执行完后, 栈中只剩下window

### 面试题

```js
console.log("gb:"+i)
var i = 1
foo(1)
function foo(i){
  if(i==4){
    return
  }
  console.log("fb:"+i)
  foo(i+1) //递归调用
  console.log("fe:"+i)
}
console.log("ge:"+i)

//1.依次输出了什么？
/*
undefined
1
2
3
3
2
1
1
*/
//2.整个过程产生了几个执行上下文栈
//步骤分解
var foo
foo = function (i){}
var i 
console.log("gb:"+i) //undefined
i = 1
foo(i)
	/*
	  var i //定义形参
	  i = 1 //实参赋值给形参
	  console.log("fb:"+i) //1
	  foo(i+1) //foo(2)
	  	//var i
	  	// i = 2
	  	// console.log("fb:"+i) // 2
	  	// foo(i+1) // foo(3)→ console.log("fb:"+i) //3
	  	// foo(4) return 结束整个函数，foo(4)结束了
	  	// foo(3) 继续下一步 console.log("fe:"+i) ， 闭包没有传递下来，所以i还是3
	  	// foo(2) console.log("fe:"+i) // 2
	  	// foo(1) console.log("fe:"+i) // 1
	*/
console.log("ge:"+i) //闭包没有保存下来，所以全局里i的值没有变过 1
```

```js
//1.先函数提升，再变量提升，但是var如果有值了不会再次赋值undefined
  function a(){}
  var a 
  console.log(typeof a) // function
//2.if是语句，不是函数，var正常声明提升
  if(!b in window){
    var b = 1
  }
  console.log(b) //undefined，而不是报错Uncaught ReferenceError: pangjing is not defined
  //压缩过后的代码，很多abcd，得试试其他的
//3.
var c =1 
function c(c){
  console.log(c)
  var c = 3
}
c(2) //函数提升之后变量提升，c先被赋予了数字1，报错 c is not a function
```

## 作用域与作用域链

- 理解

  - 就是一块"地盘", 一个代码段所在的区域

  - 它是静态的(相对于上下文对象), 在编写代码时就确定了

- 分类

  - 全局作用域

  - 函数作用域

  - 没有块作用域(ES6有了)

- 作用
  - 隔离变量，不同作用域下同名变量不会有冲突

### 左查询与右查询

为了继续更深入地理解，我们需要一点儿更多的编译器术语。

当 *引擎* 执行 *编译器* 在第二步为它产生的代码时，它必须查询变量 `a` 来看它是否已经被声明过了，而且这个查询是咨询 *作用域* 的。但是 *引擎* 所实施的查询的类型会影响查询的结果。

在我们这个例子中，*引擎* 将会对变量 `a` 实施一个“LHS”查询。另一种类型的查询称为“RHS”。

我打赌你能猜出“L”和“R”是什么意思。这两个术语表示“Left-hand Side（左手边）”和“Right-hand Side（右手边）”

什么的……边？赋值操作的。

换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。

实际上，我们可以表述得更准确一点儿。对于我们的目的来说，一个 RHS 是难以察觉的，因为它简单地查询某个变量的值，而 LHS 查询是试着找到变量容器本身，以便它可以赋值。从这种意义上说，RHS 的含义实质上不是 *真正的* “一个赋值的右手边”，更准确地说，它只是意味着“不是左手边”。

注意： LHS 和 RHS 意味着“赋值的左/右手边”未必像字面上那样意味着“ `=` 赋值操作符的左/右边”。赋值有几种其他的发生形式，所以最好在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）”。

注意： 你可能会试图将函数声明 `function foo(a) {...` 概念化为一个普通的变量声明和赋值，比如 `var foo` 和 `foo = function(a){...`。这样做会诱使你认为函数声明涉及了一次 LHS 查询。

考虑这段程序，它既有 LHS 引用又有 RHS 引用：

```
function foo(a) {
	console.log( a ); // 2
}

foo( 2 );
```

调用 `foo(..)` 的最后一行作为一个函数调用要求一个指向 `foo` 的 RHS 引用，意味着，“去查询 `foo` 的值，并把它交给我”。另外，`(..)` 意味着 `foo` 的值应当被执行，所以它最好实际上是一个函数！

这里有一个微妙但重要的赋值。你发现了吗？

你可能错过了这个代码段隐含的 `a = 2`。它发生在当值 `2` 作为参数值传递给 `foo(..)` 函数时，值 `2` 被赋值 给了参数 `a`。为了（隐含地）给参数 `a` 赋值，进行了一个 LHS 查询。

这里还有一个 `a` 的值的 RHS 引用，它的结果值被传入 `console.log(..)`。`console.log(..)` 需要一个引用来执行。它为 `console` 对象进行一个 RHS 查询，然后发生一个属性解析来看它是否拥有一个称为 `log` 的方法。

最后，我们可以将这一过程概念化为，在将值 `2`（通过变量 `a` 的 RHS 查询得到的）传入 `log(..)` 时发生了一次 LHS/RHS 的交换。在 `log(..)` 的原生实现内部，我们可以假定它拥有参数，其中的第一个（也许被称为 `arg1`）在 `2` 被赋值给它之前，进行了一次 LHS 引用查询。

然而，一个微妙但重要的不同是，在这种情况下 *编译器* 在代码生成期间同时处理声明和值的定义，如此当 *引擎* 执行代码时，没有必要将一个函数值“赋予” `foo`。因此，将函数声明考虑为一个我们在这里讨论的 LHS 查询赋值是不太合适的。

### 小测验

检查你到目前为止的理解。确保你扮演 *引擎*，并与 *作用域* “对话”：

```
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );
```

1. 找到所有的 LHS 查询（有3处！）。
2. 找到所有的 RHS 查询（有4处！）。

注意： 小测验答案参见本章的复习部分！

为什么我们区别 LHS 和 RHS 那么重要？

因为在变量还没有被声明（在所有被查询的 *作用域* 中都没找到）的情况下，这两种类型的查询的行为不同。

```
function foo(a) {
	console.log( a + b );
	b = a;
}

foo( 2 );

找出所有的 LHS 查询（有3处！）。

c = .., a = 2（隐含的参数赋值）和 b = ..

找出所有的 RHS 查询（有4处！）。

foo(2.., = a;, a + .. 和 .. + b
```

当 `b` 的 RHS 查询第一次发生时，它是找不到的。它被说成是一个“未声明”的变量，因为它在作用域中找不到。

如果 RHS 查询在嵌套的 *作用域* 的任何地方都找不到一个值，这会导致 *引擎* 抛出一个 `ReferenceError`。必须要注意的是这个错误的类型是 `ReferenceError`。

相比之下，如果 *引擎* 在进行一个 LHS 查询，但到达了顶层（全局 *作用域*）都没有找到它，而且如果程序没有运行在“Strict模式”[[1\]](https://www.kancloud.cn/kancloud/you-dont-know-js-scope-closures/516609#fn1)下，那么这个全局 *作用域* 将会在 全局作用域中 创建一个同名的新变量，并把它交还给 *引擎*。

*“不，之前没有这样的东西，但是我可以帮忙给你创建一个。”*

在 ES5 中被加入的“Strict模式”[[1:1\]](https://www.kancloud.cn/kancloud/you-dont-know-js-scope-closures/516609#fn1)，有许多与一般/宽松/懒惰模式不同的行为。其中之一就是不允许自动/隐含的全局变量创建。在这种情况下，将不会有全局 *作用域* 的变量交回给 LHS 查询，并且类似于 RHS 的情况, *引擎* 将抛出一个 `ReferenceError`。

现在，如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 `null` 或者 `undefined` 值的属性，那么 *引擎* 就会抛出一个不同种类的错误，称为 `TypeError`。

`ReferenceError` 是关于 *作用域* 解析失败的，而 `TypeError` 暗示着 *作用域* 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。

作用域是一组规则，它决定了一个变量（标识符）在哪里和如何被查找。这种查询也许是为了向这个变量赋值，这时变量是一个 LHS（左手边）引用，或者是为取得它的值，这时变量是一个 RHS（右手边）引用。

### 作用域与执行上下文

### 区别与联系

- 区别1

  - 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时

  - 全局执行上下文环境是在**全局作用域确定之后**, js代码马上执行之前创建

  - 函数执行上下文是在调用函数时, 函数体代码执行之前创建

- 区别2

  - 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化

  - 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放

- 联系

  - 执行上下文(对象)是从属于所在的作用域
  - 全局上下文环境==>全局作用域
  - 函数上下文环境==>对应的函数作用域
  - 问题来了：作用域 词法作用域 词法环境
    - 作用域的一种工作方式：词法作用域
    - 另一种：动态作用域
    - 词法环境：在执行上下文中的一个对象，有着和作用域相同的映射 
  - 执行上下文和作用域之间没有从属关系，仅仅是执行上下文当中的lexical environment对象保存着函数被创建时的作用域（**标识符—变量映射**）的信息，可以说一个副本，在函数要执行的时候把这个对象放了进来
  - 当函数被定义时，他的作用域就确定了，当函数要执行的时候lexical environment对象保存了这个作用域的信息
  - 而且：
  - https://segmentfault.com/a/1190000009522006
  - https://juejin.im/post/5ba32171f265da0ab719a6d7
  -  A *closure* is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was created. 

### 作用域链

- 理解

  - 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)

  - 查找变量时就是沿着作用域链来查找的

- 查找一个变量的查找规则

  1. 在**当前作用域**下的**执行上下文**中查找对应的属性, 如果有直接返回, 否则进入2
  2. 在**上一级作用域**的**执行上下文**中查找对应的属性, 如果有直接返回, 否则进入3
  3. 再次执行2的相同操作, 直到**全局作用域**, 如果还找不到就抛出找不到的异常

- 一旦找到第一个匹配，作用域查询就停止了。相同的标识符名称可以在嵌套作用域的多个层中被指定，这称为“遮蔽（shadowing）”（内部的标识符“遮蔽”了外部的标识符）。无论如何遮蔽，作用域查询总是从当前被执行的最内侧的作用域开始，向外/向上不断查找，直到第一个匹配才停止。

  注意： 全局变量也自动地是全局对象（在浏览器中是 `window`，等等）的属性，所以不直接通过全局变量的词法名称，而通过将它作为全局对象的一个属性引用来间接地引用，是可能的。

- 词法作用域查询 *仅仅* 在处理头等标识符时实施，比如 `a`，`b`，和 `c`。如果你在一段代码中拥有一个 `foo.bar.baz` 的引用，词法作用域查询将在查找 `foo` 标识符时实施，但一旦定位这个变量，对象属性访问规则将会分别接管 `bar` 和 `baz` 属性的解析。

- 词法作用域意味着作用域是由编写时函数被声明的位置的决策定义的。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并如此在执行期间预测它们将如何被查询。

### 面试题

```javascript
var x = 10
function fn (){
  console.log(x)
}
function show(f){
  var x = 20 
  f()
}
show(fn)
```

- 因为函数时引用类型，把`fn`赋值给<u>f</u>，<u>f</u>依然是引用相同的`fn`，所以是**调用函数**，而不是新建然后执行，所以被调用的`fn`函数的作用域还是外部的，而不是在show()内部

```js
var fn = function(){
  console.log(fn)
}
fn()
var obj={
  fn2:function(){
    console.log(this.fn2)
    console.log(obj.fn2)
    console.log(fn2)
  }
}
obj.fn2()
//与是不是方法没有关系，本质都是把函数的引用传递给了一个变量，然后某个对象读取了这个变量值（调用了this），这个对象就是this
```

## 函数与块作用域

```js
var a = 2;

(function foo(){ // <-- 插入这个

	var a = 3;
	console.log( a ); // 3

})(); // <-- 和这个

console.log( a ); // 2
```

首先注意，与仅仅是 `function...` 相对，这个包装函数语句以 `(function...` 开头。虽然这看起来像是一个微小的细节，但实际上这是一个重大改变。与将这个函数视为一个标准的声明不同的是，这个函数被视为一个函数表达式。

注意： 区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。

这里我们可以观察到一个函数声明和一个函数表达式之间的关键不同是，它的名称作为一个标识符被绑定在何处。

比较这前两个代码段。在第一个代码段中，名称 `foo` 被绑定在外围作用域中，我们用 `foo()` 直接调用它。在第二个代码段中，名称 `foo` 没有被绑定在外围作用域中，而是被绑定在它自己的函数内部。

换句话说，`(function foo(){ .. })` 作为一个表达式意味着标识符 `foo` 仅能在 `..` 代表的作用域中被找到，而不是在外部作用域中。将名称 `foo` 隐藏在它自己内部意味着它不会没必要地污染外围作用域。

### 匿名与命名

你可能对函数表达式作为回调参数再熟悉不过了，比如：

```js
setTimeout( function(){
	console.log("I waited 1 second!");
}, 1000 );
```

这称为一个“匿名函数表达式”，因为 `function()...` 上没有名称标识符。函数表达式可以是匿名的，但是函数声明不能省略名称 —— 那将是不合法的JS程序。

匿名函数表达式可以快速和很容易地键入，而且许多库和工具往往鼓励使用这种代码惯用风格。然而，它们有几个缺点需要考虑：

1. 在栈轨迹上匿名函数没有有用的名称可以表示，这可能会使得调试更加困难。
2. 没有名称的情况下，如果这个函数需要为了递归等目的引用它自己，那么就需要很不幸地使用 被废弃的`arguments.callee` 引用。另一个需要自引用的例子是，当一个事件处理器函数在被触发后想要把自己解除绑定。
3. 匿名函数省略的名称经常对提供更易读/易懂的代码很有帮助。一个描述性的名称可以帮助代码自解释。

内联函数表达式 很强大且很有用 —— 匿名和命名的问题并不会贬损这一点。给你的函数表达式提供一个名称就可以十分有效地解决这些缺陷，而且没有实际的坏处。最佳的方法是总是命名你的函数表达式：

```js
setTimeout( function timeoutHandler(){ // <-- 看，我有一个名字！
	console.log( "I waited 1 second!" );
}, 1000 );
```

- 但是现在有更好的选择：箭头函数？

得益于包装在一个 `()` 中，我们有了一个作为表达式的函数，我们可以通过在末尾加入另一个 `()` 来执行这个函数，就像 `(function foo(){ .. })()`。第一个外围的 `( )` 使这个函数变成表达式，而第二个 `()` 执行这个函数。

传统的IIFE有一种稍稍变化的形式，一些人偏好这样：`(function(){ .. }())`。仔细观察不同之处。在第一种形式中，函数表达式被包在 `( )` 中，然后用于调用的 `()` 出现在它的外侧。在第二种形式中，用于调用的 `()` 被移动到用于包装的 `( )` 内侧。

这两种形式在功能上完全相同。这纯粹是一个你偏好的风格的选择。

### `try/catch`

一个鲜为人知的事实是，JavaScript 在 ES3 中明确指出在 `try/catch` 的 `catch` 子句中声明的变量，是属于 `catch` 块儿的块儿作用域的。

例如：

```js
try {
	undefined(); //用非法的操作强制产生一个异常！
}
catch (err) {
	console.log( err ); // 好用！
}

console.log( err ); // ReferenceError: `err` not found
```

### `let`

至此，我们看到 JavaScript 仅仅有一些奇怪的小众行为暴露了块儿作用域功能。如果这就是我们拥有的一切，而且许多许多年以来这 *确实就是* 我们拥有的一切，那么块作用域对 JavaScript 开发者来说就不是非常有用。

幸运的是，ES6 改变了这种状态，并引入了一个新的关键字 `let`，作为另一种声明变量的方式伴随着 `var`。

`let` 关键字将变量声明附着在它所在的任何块儿（通常是一个 `{ .. }`）的作用域中。换句话说，`let` 为它的变量声明隐含地劫持了任意块儿的作用域。

## 闭包

- 调用的时候i是谁，i为什么还在

- 如何产生闭包?
  - 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包

- 闭包到底是什么?

  - 使用chrome调试查看

  - 理解一: 闭包是嵌套的内部函数(绝大部分人)

  - 理解二: 包含被引用变量(函数)的对象(极少数人)
  - 我的理解：闭包是一个嵌套在内部的函数对象，包含着引用的变量，传递对象的引用的时候这个小背包里的变量也会被一起传递

  - 注意: 闭包存在于嵌套的内部函数中

- 产生闭包的条件?

  - 函数嵌套

  - 内部函数引用了外部函数的数据(变量/函数)

```js
function fn1(){
  var a =2 
  function fn2(){
    a++
    console.log(a)
  }
  return fn2
}

var f = fn1 //接受了函数引用（还有小背包里的变量）
f() //3 函数fn1的局部变量fn2已经消失，但是把引用赋值给了f，所以产生的闭包对象一直存在
f() //4 反复调用f，可以继续使用fn1的局部变量
```

![1546850652897](F:\OneDrive\JS\纲略合集\assets\1546850652897.png)

- 常见的闭包

  - 将函数作为另一个函数的返回值

  - 将函数作为实参传递给另一个函数调用

- 闭包的作用

  - 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)

  - 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

  - 外部无法直接访问闭包内的变量，只能执行内部函数设定好的操作

- 问题:

  - 函数执行完后, 函数内部声明的局部变量是否还存在?  一般是不存在, 存在于闭包中的变量，且闭包对象被引用，才会继续存在

  - 在函数外部能直接访问函数内部的局部变量吗? 不能, 但我们可以通过闭包让外部操作它

- 闭包的生命周期

  - 产生: 在嵌套内部函数**定义执行**完时就产生了(不是在调用 a：undefined)

  - 死亡: 在嵌套的内部函数成为垃圾对象时
    - f = null;

- 定义JS模块

  - 具有特定功能的js文件

  - 将所有的数据和功能都封装在一个函数内部(私有的)

  - 只向外暴露一个包含n个方法的对象或函数

  - 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能

- 缺点
    - 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
    - 容易造成内存泄露
- 解决
    - 能不用闭包就不用
    - 及时释放
```js
function fn1() {
	var arr = new Array[100000]
	function fn2() {
 		console.log(arr.length)
	}
	return fn2
}
var f = fn1()
f()

f = null //让内部函数成为垃圾对象-->回收闭包
```

```js
var module = myModule()
module.doSomething()
module.doOtherhing()

(function(window){
  //私有数据
  var msg = "Hello Closure"
  //操作数据的函数
  function doSomething(){
    console.log("doSomething()"+ msg.toUpperCase())
  }
  function doOtherthing(){
    console.log("doSomething()"+ msg.toLowerCase())
  }
  
  //向外暴露对象（给外部使用的方法）
  window.myModule2 = (){
    doSomething:doSomething,
    doOtherthing:doOtherthing
  }
  
})(window)
```

- 用闭包和用tool.js的区别在哪里呢？
  - tool.js所有的函数和变量都可以直接操作

### 面试题

```js
//代码片段一
var name = "The Window"
var object = {
  name:"My Object",
  getNameFunc:function(){
    return function(){
      return this.name
    }
  }
}
consloe.log(object.getNameFunc()()) //The Window,this变成了window

//代码片段二
  var name2 = "The Window";
  var object2 = {
    name2 : "My Object",
    getNameFunc : function(){
      var that = this;
      return function(){
        return that.name2;
      };
    }
  };
  alert(object2.getNameFunc()()); //?  my object thta还是object，
//执行上下文创建的时候，this每次都会重新绑定引用，没办法作为闭包内的变量，
//而且是在创建函数的那一刻的执行上下文中引用的变量，所以不同的执行上下文，即使引用了外部变量也不会是闭包变量
//外部函数，只能是包着的哪一个
```

```js
function foo(n,o) {
  console.log(o)
  return {
    method:function(m){
      return foo(m,n)
    }
  }
}
var a=foo(0)
a.method(1)
a.method(2)
a.method(3)//undefined,0,0,0

var b = foo(0).method(1).method(2).method(3)//undefined,0,1,2

var c = foo(0).method(1)
c.method(2)
c.method(3)//undefined,0,1,1
```

## 循环 + 闭包

用来展示闭包最常见最权威的例子是老实巴交的 for 循环。

```
for (var i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}
```

注意： 当你将函数放在循环内部时 Linter 经常会抱怨，因为不理解闭包的错误 在开发者中太常见了。我们在这里讲解如何正确地利用闭包的全部力量。但是 Linter 通常不理解这样的微妙之处，所以它们不管怎样都将抱怨，认为你 *实际上* 不知道你在做什么。

这段代码的精神是，我们一般将 *期待* 它的行为是分别打印数字“1”，“2”，……“5”，一次一个，一秒一个。

实际上，如果你运行这段代码，你会得到“6”被打印5次，一秒一个。

啊？

首先，让我们解释一下“6”是从哪儿来的。循环的终结条件是 `i`*不*`<=5`。第一次满足这个条件时 `i` 是6。所以，输出的结果反映的是 `i` 在循环终结后的最终值。

如果多看两眼的话这其实很明显。超时的回调函数都将在循环的完成之后立即运行。实际上，就计时器而言，即便在每次迭代中它是 `setTimeout(.., 0)`，所有这些回调函数也都仍然是严格地在循环之后运行的，因此每次都打印 `6`。

但是这里有个更深刻的问题。要是想让它实际上如我们在语义上暗示的那样动作，我们的代码缺少了什么？

缺少的东西是，我们试图 *暗示* 在迭代期间，循环的每次迭代都“捕捉”一份对 `i` 的拷贝。但是，虽然所有这5个函数在每次循环迭代中分离地定义，由于作用域的工作方式，它们 都闭包在同一个共享的全局作用域上，而它事实上只有一个 `i`。

这么说来，所有函数共享一个指向相同的 `i` 的引用是 *理所当然* 的。循环结构的某些东西往往迷惑我们，使我们认为这里有其他更精巧的东西在工作。但是这里没有。这与根本没有循环，5个超时回调仅仅一个接一个地被声明没有区别。

好了，那么，回到我们火烧眉毛的问题。缺少了什么？我们需要更多 铃声 被闭包的作用域。明确地说，我们需要为循环的每次迭代都准备一个新的被闭包的作用域。

我们在第三章中学到，IIFE 通过声明并立即执行一个函数来创建作用域。

让我们试试：

```
for (var i=1; i<=5; i++) {
	(function(){
		setTimeout( function timer(){
			console.log( i );
		}, i*1000 );
	})();
}
```

这好用吗？试试。我还会等你。

我来为你终结悬念。不好用。 但是为什么？很明显我们现在有了更多的词法作用域。每个超时回调函数确实闭包在每次迭代时分别被每个 IIFE 创建的作用域中。

拥有一个被闭包的 空的作用域 是不够的。仔细观察。我们的 IIFE 只是一个空的什么也不做的作用域。它内部需要 *一些东西* 才能变得对我们有用。

它需要它自己的变量，在每次迭代时持有值 `i` 的一个拷贝。

```
for (var i=1; i<=5; i++) {
	(function(){
		var j = i;
		setTimeout( function timer(){
			console.log( j );
		}, j*1000 );
	})();
}
```

万岁！它好用了！

有些人偏好一种稍稍变形的形式：

```
for (var i=1; i<=5; i++) {
	(function(j){
		setTimeout( function timer(){
			console.log( j );
		}, j*1000 );
	})( i );
}
```

当然，因为这些 IIFE 只是函数，我们可以传入 `i`，如果我们乐意的话可以称它为 `j`，或者我们甚至可以再次称它为 `i`。不管哪种方式，这段代码都能工作。

在每次迭代内部使用的 IIFE 为每次迭代创建了新的作用域，这给了我们的超时回调函数一个机会，在每次迭代时闭包一个新的作用域，这些作用域中的每一个都拥有一个持有正确的迭代值的变量给我们访问。

问题解决了！

### 重温块儿作用域

仔细观察我们前一个解决方案的分析。我们使用了一个 IIFE 来在每一次迭代中创建新的作用域。换句话说，我们实际上每次迭代都 *需要* 一个 块儿作用域。我们在第三章展示了 `let` 声明，它劫持一个块儿并且就在这个块儿中声明一个变量。

这实质上将块儿变成了一个我们可以闭包的作用域。所以接下来的牛逼代码“就是好用”：

```
for (var i=1; i<=5; i++) {
	let j = i; // 呀，给闭包的块儿作用域！
	setTimeout( function timer(){
		console.log( j );
	}, j*1000 );
}
```

*但是，这还不是全部！*（用我最棒的 Bob Barker 嗓音）在用于 for 循环头部的 `let` 声明被定义了一种特殊行为。这种行为说，这个变量将不是只为循环声明一次，而是为每次迭代声明一次。并且，它将在每次后续的迭代中被上一次迭代末尾的值初始化。

```
for (let i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}
```

这有多酷？块儿作用域和闭包携手工作，解决世界上所有的问题。我不知道你怎么样，但这使我成了一个快乐的 JavaScript 开发者。





本质：传递了引用和词法环境，词法环境有环境记录器和outer，outer绑定了父级作用域（闭住了父级作用域，把他包进来了，作为outer对象），环境记录器引用了outer的变量，这样他自己可以使用，同时为了让他可以使用，父级的作用域一直存在，其他没有被引用的变量也一直存在，只是因为环境记录器没有记录，现在他们访问不到了

https://juejin.im/post/5ba32171f265da0ab719a6d7

https://segmentfault.com/a/1190000009522006

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures

https://www.kancloud.cn/kancloud/you-dont-know-js-scope-closures/516613

https://zhuanlan.zhihu.com/p/25296587



如果环境记录器没有引用outer的变量，那么outer会被垃圾回收机制处理，所以：仅仅是返回一个函数的话，之后就没办法在调用outer的变量了

```js
function fn1(){
  var a = 2
  return function fn2(){
    
  }
}
```





![1546912097947](F:\OneDrive\JS\纲略合集\assets\1546912097947.png)

在函数定义的时候，闭包就产生了

![1546912224962](F:\OneDrive\JS\纲略合集\assets\1546912224962.png)

闭包其实是：外部作用域，所以在fn2还没执行上下文的时候，闭包就一已经有了，因为外部作用域已经有了，而且外部作用域的变化，闭包也会跟着变化，a变成了2

![1546912786105](F:\OneDrive\JS\纲略合集\assets\1546912786105.png)

闭包仅仅是被fn2引用者，所以保留了一下来，依然可以访问，由于fn2的函数声明提升，闭包被创建了，outer和fn2的环境记录器已经起了联系

![1546913014211](F:\OneDrive\JS\纲略合集\assets\1546913014211.png)

a产生的时候，b也产生了，因为函数声明的提升，fn2内部的环境记录器和outer都已经有值了

a 和 b 不在同一个环境里，所以a不在fn2的环境记录器中，而是一直在闭包里面，也就是outer，如果没有产生闭包，fn2的outer也还是一样，只是没有办法引用outer的值了，因为在fn1被回收之前，没有过outer，outer应该也被回收了，即使把整个词法环境一起传递（但是没有引用outer，outer是无用的），所以outer也会被回收

环境记录器和outer并不是在函数执行的时候确定的，而是在函数定义的时候就已经确定了，在函数执行的时候，创建执行上下文，在词法环境内引用环境记录器和outer，给可能的函数定义，在执行阶段，给环境记录器内的变量赋值

```js
  // 1. 将函数作为另一个函数的返回值
  function fn1() {
    var a = 2

    function fn2() {
	  var b = 2
      a++
      console.log(a)
    }

    return fn2
  }
  var f = fn1()
  f() // 3
  f() // 4
```
```js
window.onload = function(){
  //用var声明，也存在闭包，只是外部作用域为全局作用域，其他的闭包也引用着相同的它，所以i被修改了
  //用let声明，每次都为i创建一个单独的作用域，即可正常绑定和引用
  for(let i=0;i<liNodes.length;i++){
    //转绑很重要
    liNodes[i].index = i;
    liNodes[i].onclick=function(){
      //var i ，本质上是在函数内部声明了i，导致不会沿着作用域链去访问外部闭包里的i
      for(var j=0;j<upNodes.length;j++){
        //upNodes[i].style.width="0";
        upNodes[j].style.width="";
      }
      upNodes[i].style.width="100%";
      arrowEl.style.left = liNodes[i].offsetLeft + liNodes[i].offsetWidth/2 - arrowEl.offsetWidth/2+"px";
    }
  }
}
```





# 3. 面向对象高级

## 对象创建模式

### 方式一: Object构造函数模式

- 套路: 先创建空Object对象, 再动态添加属性/方法

- 适用场景: 起始时不确定对象内部数据

- 问题: 语句太多

### 方式二: 对象字面量模式

- 套路: 使用{}创建对象, 同时指定属性/方法

- 适用场景: 起始时对象内部数据是确定的，创建对象数量少

- 问题: 如果创建多个对象, 有重复代码

### 方式三: 工厂模式

- 套路: 通过工厂函数动态创建对象**并返回**

- 适用场景: 需要创建多个对象

-  问题: 对象没有一个具体的类型, 都是Object类型

### 方式四: 自定义构造函数模式

- 套路: 自定义构造函数, 通过new创建对象

- 适用场景: 需要创建多个类型确定的对象

- 问题: 每个对象都有相同的数据, 浪费内存

### 方式五：原型模式

### 方式六: 构造函数+原型的组合模式

- 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上

- 适用场景: 需要创建多个类型确定的对象

## 继承模式

### 原型链继承

- 步骤

1. 定义父类型构造函数

2. 给父类型的原型添加方法

3. 定义子类型的构造函数

4. 创建父类型的实例对象赋值给子类型的原型

5. 将子类型原型的构造属性设置为子类型的构造函数

6. 给子类型原型添加方法

7. 创建子类型的对象: 可以调用父类型的方法

- 关键

  - 子类型的原型为父类型的一个实例对象

  - 如果不去更改子类型的原型的constructor属性，则只能在父类型的原型中找到，所以最好更改constructor属性，指向子类型

![1547106232276](F:\OneDrive\JS\纲略合集\assets\1547106232276.png)

### 借用构造函数继承(假的)

- 步骤

1. 定义父类型构造函数

2. 定义子类型构造函数

3. 在子类型构造函数中调用父类型构造

- 关键:
  - 在子类型构造函数中通用call()调用父类型构造函数
  - 并没有真正的继承操作，实质是代码的简化

### 组合继承

- 原型链+借用构造函数的组合继承

- 利用原型链实现对父类型对象的方法继承

- 利用super()借用父类型构建函数初始化相同属性

![1547106660261](F:\OneDrive\JS\纲略合集\assets\1547106660261.png)

# 4. 线程机制与事件机制

## 进程与线程

### 理解

- 进程(process)：程序的一次执行, 它占有一片独有的内存空间

- 线程(thread)：是进程内独立执行的单元，CPU的基本调度单位, 是程序执行的一个完整流程

![1547106772414](F:\OneDrive\JS\纲略合集\assets\1547106772414.png)

- 进程与线程
  - 应用程序必须运行在某个进程的某个线程上

  - 一个进程中一般至少有一个运行的线程: 主线程

  - 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的

  - 一个进程内的数据可以供其中的多个线程直接共享

  - 多个进程之间的数据是不能直接共享的

  - 线程池(thread pool)：保存多个线程对象的容器，实现线程对象的反复调用

- 多进程：一个应用程序可以同时启动多个进程运行

- 多线程：单个进程内，同时运行多个线程

### 优缺点

- 多线程优点：：有效提高CPU的利用率

- 缺点：

  - 创建多线程开销

  - 线程间切换开销（单个CPU单位时间只运行一个线程）

  - 死锁与状态同步问题

- 单线程优点：顺序编程简单易懂

- 缺点：效率低

### 浏览器运行是**单进程**还是**多进程**?

- 有的是单进程

  - firefox

  - 老版IE

- 有的是多进程

  - chrome

  - 新版IE

- 如何查看浏览器是否是多进程运行的呢?
  - 任务管理器==>进程
- 浏览器运行是**单线程**还是**多线程**?
  - 都是多线程运行的

## 浏览器内核

### 什么是浏览器内核?

- 支持浏览器运行的最核心的程序

- 不同的浏览器可能不太一样

  - Chrome, Safari: webkit

  - firefox: Gecko

  - IE: Trident

  - 360,搜狗等国内浏览器: Trident + webkit

- 内核由很多模块组成

    - html,css文档解析模块 : 负责页面文本的解析

    - dom/css模块 : 负责dom/css在内存中的相关处理

    - 布局和渲染模块 : 负责页面的布局和效果的绘制

    - 布局和渲染模块 : 负责页面的布局和效果的绘制

    - 定时器模块 : 负责定时器的管理

    - 网络请求模块 : 负责服务器请求(常规/Ajax)

    - 事件响应模块 : 负责事件的管理

### 定时器引发的思考

- 定时器真是定时执行的吗?

- 定时器并不能保证真正定时执行

- 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)

- 定时器回调函数是在分线程执行的吗?
  - 在主线程执行的, js是单线程的

- 定时器是如何实现的?
  - 事件循环模型(后面讲)

### JS是单线程执行的

- 如何证明js执行是单线程的?
  - setTimeout()的回调函数是在主线程执行的
  - 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行
  - alert()之后，暂停了主线程，也暂停了计时，不点确定，定时器的回调函数一直不会执行

- 为什么js要用单线程模式, 而不用多线程模式?
  - JavaScript的单线程，与它的用途有关。

  - 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。

  - 这决定了它只能是单线程，否则会带来很复杂的同步问题

- 代码的分类:

  - 初始化代码

  - 回调代码

- js引擎执行代码的基本流程

1. 先执行**初始化代码**: 包含一些特别的代码   回调函数(异步执行)

2. 设置定时器

3. 绑定事件监听

4. 发送ajax请求

5. 后面在某个时刻才会执行**回调代码**

- <https://www.cnblogs.com/Jacky-MYD/p/7743532.html>

- 同步异步 与 事件循环模型


## 浏览器的事件循环（轮询）模型

### 理解

- 所有代码分类
  - 初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码
  - 回调执行代码(异步代码): 处理回调逻辑
- js引擎执行代码的基本流程:
  - 初始化代码===>回调代码
- 模型的2个重要组成部分:
  - 事件(定时器/DOM事件/Ajax)管理模块（工作线程）
  - 回调队列
- 模型的运转流程

1. 执行初始化代码, 将事件回调函数交给对应模块管理

2. **当事件发生时, 管理模块会将回调函数及其上数据添加到回调列队中**

3. 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行

- 模型概念图

![1547107412345](F:\OneDrive\JS\纲略合集\assets\1547107412345.png)

![1547107426240](F:\OneDrive\JS\纲略合集\assets\1547107426240.png)

### 单线程

　　我们常说的“JavaScript是单线程的”。所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个，一般称它为主线程。但是实际上还存在其他的线程，例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分，不妨称它们为工作线程吧。

### 一个完整异步过程：

1. 主线程发一起一个异步请求
2. 相应的工作线程接收请求并告知主线程已收到通知（异步函数调用后的返回值？）
3. 主线程可以继续执行后面的代码，同时工作线程执行异步任务，并管理着回调函数
4. 事件发生，工作线程完成工作后，通知主线程
5. 主线程收到通知后，如果已经执行完了初始化的代码，会遍历读取回调队列（消息队列）中的回调函数执行

### 异步函数

- 通常具有以下的形式：A(args..., callbackFn);
- 它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。
  - args是这个函数需要的参数
  - callbackFn（回调函数）也是这个函数的参数

- 所以，从主线程的角度看，一个异步过程包括下面两个要素：

1. 发起函数（或叫注册函数）A;

1. 回调函数callbackFn；

- 它们都是主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。

```js
setTimeout（()=>{})，1000）；
//其中setTimeout就是异步过程的发起函数，function是回调函数。
```

```js
//注：前面说得形式A(args..., callbackFn)只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如：
　　var xhr = new XMLHttpRequest();
　　xhr.onreadystatechange = xxx;     // 添加回调函数
　　xhr.open('GET'， url);
　　xhr.send();   // 发起函数　　
//发起函数和回调函数是分离的。
```

### 消息队列和事件循环

- 工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。

- 消息队列：消息队列是一个先进先出的队列，它里面存放这各种消息。

- 事件循环：事件循环是指主线程重复从消息队列中取消息，执行的过程。
  - 实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息、再取消息、再执行消息。
  - 当消息队列为空时，就会等待直到消息队列变成非空。
  - 而且主线程只有在将前面的消息执行完成后，才会去去下一个消息。
  - 这种机制就叫做**事件循环机制**，取一个消息并执行的过程叫做一次循环。

```js
//事件循环代码表示大概是这样的：
　　while（true）{
　　　　var message = queue.get（）；
　　　　execute（message）；
　　}
```

- 消息队列中放的消息具体是什么？
  - 消息的具体结构当然跟具体实现有关，但是为了简单起见，我们可以认为：消息就是注册异步任务时添加的回调函数。

```js
//再次以异步AJAX为例，假设存在如下的代码：
　　$.ajax（'http://baidu.com'，function（resp）{
　　　　console.log（'我是响应'，resp）；
　　}）
　　// 其他代码
　　...
　　...
```

- 主线程在发起AJAX请求后，会继续执行其他代码，AJAX线程负责请求http://baidu.com，拿到响应后，它会把响应封装成一个JavaScript对象，然后构造一条消息：

```js
var message = function（）{
  callbackFn（response）；
}
//其中callbackFn就是就是前面代码中得到成功响应时的回调函数。
```

- 主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是message函数)，并执行它。
- 到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。
- 如果一开始主线程就没有提供回调函数，AJAX线程在收到HTTP响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。
- 用图表示这个过程就是：

　　![img](F:\OneDrive\JS\纲略合集\assets\1220270-20171027174149305-672812579-1547109462353.png)

- 从上文中我们也可以得到这样一个明显的结论，就是：异步过程的回调函数，一定不在当前这一轮事件循环中执行。

### 异步与事件

- 消息队列中的每条消息实际上都对应着一个事件。
- 上文中一直没有提到一类很重要的异步过程：DOM事件。

```js
var button = document.getElement('#btn');
	button.addEventListener('click', function(e) {
	console.log();
});
```

- 从事件的角度来看，上述代码表示：
  - 在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。

- 从异步过程的角度看：
  - addEventListener函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。

- 事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。
- 我觉得它的存在是为了编程接口对开发者更友好。
- 另一方面，所有的异步过程也都可以用事件来描述。
- 例如：setTimeout可以看成对应一个时间到了！的事件。
- 前文的setTimeout(fn, 1000);可以看成：`timer.addEventListener('timeout', 1000, fn);`

## H5 Web Workers（多线程）

- H5规范提供了js分线程的实现, 取名为: Web Workers

  - 我们可以将一些计算量大的代码，交由web workers运行而不冻结用户界面

  - 但是子线程完全受主线程控制，且不得操纵DOM。所以这个新标准，并没有改变JS的本质

### 相关API

- Worker: 构造函数, 加载分线程执行的js文件
  - `var workers = new Worker(‘worker.js’)`

- Worker.prototype.onmessage: 用于接收另一个线程的回调函数

- Worker.prototype.postMessage: 向另一个线程发送消息

### 不足

- worker内代码不能操作DOM(更新UI)
  - 因为全局对象不再是window，没有方法了

- 不能跨域加载JS

- 不是每个浏览器都支持这个新特性

![1547107490966](F:\OneDrive\JS\纲略合集\assets\1547107490966.png)





　

- 