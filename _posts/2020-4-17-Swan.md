---
layout: post
#标题配置
title:  Swan
#时间配置
date:   2020-4-17 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note derive-front-end
---

* content
{:toc}


# 入门

## 新建项目

### 使用测试号

在 2.19.0 以上版本的百度开发者工具中，进入新建项目界面，在填写 AppID 下面可以点击使用测试号，即可自动开通测试号权限并将测试号填写到 AppID 输入框。

测试号在使用上有一些功能上的限制，比如**不支持发布、云开发、云测试、插件、动态库、远程调试**等能力，以及**不支持支付、手机号等权限**的获取。

如果需要使用webview组件，请在项目信息内关闭域名校验功能后再次预览，即可在百度APP上跳过域名校验。

## 预览发布

### 预览

当点击预览按钮时，开发者工具会对当前项目进行编译，然后制作压缩包上传到服务器，并生成小程序和 web 小程序的预览二维码，用百度app扫码后可以看到相应页面。

### 发布

当点击发布按钮时，开发者工具会对当前项目进行编译，然后制作压缩包上传到服务器，上传成功后，可以在智能小程序官网的开发管理一栏看到提交的相关信息。

1. 输入当前发布的小程序版本号，默认按照上次发布的版本号递增
2. 选择上线基础库的最低版本
3. 填写描述信息

## 调试

### 开发者工具调试

> 具体调试方法请参考[调试](https://smartprogram.baidu.com/docs/develop/devtools/smartappdebug_function_monitor/)章节。

### Chrome 浏览器调试

> 对于正在开发中或者审核中的小程序，可使用 Chrome 进行 inspect 调试。

**调试方法**：

1. adb 连接手机至电脑，打开 chrome 浏览器，打开 chrome://inspect 。

   > adb:https://developer.android.google.cn/studio/command-line/adb#howadbworks
   >
   > adb连接教程：https://blog.csdn.net/qq_32327737/article/details/100576786

2. 打开需调试的小程序，单击“关于”，进入“启动 Inspect 页面”。

   <img src="Swan/2020010.png" alt="img" style="zoom:80%;" /> <img src="Swan/202002.png" alt="img" style="zoom:80%;" /> 

3. Inspect 分为强化启动和普通启动。您可根据需要选择不同的启动方式，对小程序进行调试。

   + 强化启动：重启小程序
   + 普通启动：热启动

## 搬家工具

https://smartprogram.baidu.com/docs/develop/tutorial/move/

https://smartprogram.baidu.com/docs/develop/tutorial/frameworkdevelop/

# 场景功能  @@@

## 打开小程序

https://smartprogram.baidu.com/docs/develop/function/opensmartprogram/

## 小程序导航

折返阅读

# 基本配置

## 概述

小程序开发包括全局配置文件、页面配置文件。开发者可通过`app.json`和`app.js`文件对小程序进行[全局配置](https://smartprogram.baidu.com/docs/develop/framework/process/)；通过`.css`、`.js`、`.json`和`.swan`文件进行[页面配置](https://smartprogram.baidu.com/docs/develop/framework/devcss/)。具体结构如下：

```
├── app.js
├── app.json
├── app.css
├── project.config.json
└──  pages
    └── index
        ├── index.swan
        ├── index.css
        ├── index.js
        └── index.json
    └── detail
        ├── detail.swan
        ├── detail.css
        ├── detail.js
        └── detail.json
```

### 方法说明

智能小程序的逻辑层使用 JavaScript 编写；

逻辑层将数据进行处理后发送给视图层，同时接受视图层的反馈。

在 JavaScript 的基础上，我们提供了一些框架方法，用以辅助开发者更容易的开发小程序。

**例如以下方法和功能说明:**

- 提供了 [App](https://smartprogram.baidu.com/docs/develop/framework/app_service_register/) 和 [注册页面](https://smartprogram.baidu.com/docs/develop/framework/app_service_page/) 方法，分别用于注册小程序应用和每个页面；
- 提供了 [getApp](https://smartprogram.baidu.com/docs/develop/framework/app_service_registergetapp/) 和 [getCurrentPages](https://smartprogram.baidu.com/docs/develop/framework/app_service_routegetCurrentPages/) 方法，分别用来获取 App 实例和当前页面栈；
- 每个页面有独立的 [文件作用域](https://smartprogram.baidu.com/docs/develop/framework/app_service_routefile/) ，并提供 [模块化](https://smartprogram.baidu.com/docs/develop/framework/app_service_routemodule/)，使得开发者更容易进行代码封装并复用；
- 框架本身并非运行在浏览器中，所以 JavaScript 在 Web 中的一些能力都无法使用，如 document , window 等，这会使得小程序应用更接近原生；
- 开发者所编写的代码，最终会被编译打包成一份 JavaScript 文件，并在智能小程序启动时进行加载并运行，直到智能小程序销毁。
- 请勿在 App、Page 等构造器的参数对象中使用底层已存在的 key，注意，在Page 中不要自定义 getData 方法，会存在冲突。

详细内容请参看[注册 App](https://smartprogram.baidu.com/docs/develop/framework/app_service_register/)、[注册页面](https://smartprogram.baidu.com/docs/develop/framework/app_service_page/)、[页面路由](https://smartprogram.baidu.com/docs/develop/framework/app_service_route/)。

## 小程序全局配置

### 配置app.json 文件

可以通过配置 app.json 文件，设置 SWAN 的界面、路径、多 TAB 等。

**app.json 配置项列表如下**

| 属性                                                         | 类型            | 必填 | 描述                                 |
| ------------------------------------------------------------ | --------------- | ---- | ------------------------------------ |
| [pages](https://smartprogram.baidu.com/docs/develop/framework/process/#pages) | Array.< string> | 是   | 设置页面路径                         |
| [window](https://smartprogram.baidu.com/docs/develop/framework/process/#window) | Object          | 否   | 设置页面展现                         |
| [preloadRule](https://smartprogram.baidu.com/docs/develop/framework/subpackages/#分包预下载规则) | Object          | 否   | 分包预下载规则                       |
| [tabBar](https://smartprogram.baidu.com/docs/develop/framework/process/#tabBar) | Object          | 否   | 底部 tab 栏的表现                    |
| [requiredBackgroundModes](https://smartprogram.baidu.com/docs/develop/framework/process/#requiredBackgroundModes) | string[]        | 否   | 需要在后台使用的能力，如「音乐播放」 |
| [subPackages](https://smartprogram.baidu.com/docs/develop/framework/subpackages/#普通分包) | Array.< object> | 否   | 分包结构配置                         |
| [prefetches](https://smartprogram.baidu.com/docs/develop/framework/process/#prefetches) | Object Array    | 否   | 预请求的配置列表                     |
| [networkTimeout](https://smartprogram.baidu.com/docs/develop/framework/process/#networkTimeout) | Object          | 否   | 网络超时                             |

### pages

pages 接受一个数组，每一项都是一个字符串，指定 SWAN App 都有哪些页面。每一项代表页面的[路径 + 文件名]，数组第一项代表 SWAN 初始页面。

SWAN 中新增或减少页面的话，需要在 pages 中进行配置。

配置项中不需要加文件后缀名， SWAN 会自动解析。

如，开发目录为：

```
├── app.js
├── app.json
├── app.css
├── project.config.json
└──  pages
    └── index
        ├── index.swan
        ├── index.css
        ├── index.js
        └── index.json
    └── detail
        ├── detail.swan
        ├── detail.css
        ├── detail.js
        └── detail.json
```

则需要在 app.json 中书写

```json
{
    "pages":[
        "pages/index/index",
        "pages/detail/detail"
    ]
}

```

**提示**：开发者工具在app.json的pages中填写页面路径可自动生成文件夹。

### window

用于设置 SWAN 的状态栏、导航条、标题、窗口背景色。

| 属性                         | 类型     | 默认值  | 描述                                                         | 最低版本 |
| ---------------------------- | -------- | ------- | ------------------------------------------------------------ | -------- |
| navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色，如 "#000000"                                 |          |
| navigationBarTextStyle       | String   | white   | 导航栏标题颜色，目前有效值 black/white                       |          |
| navigationBarTitleText       | String   |         | 导航栏标题文字内容                                           |          |
| navigationStyle              | String   | default | 导航栏样式，有效值：default(默认样式) custom(自定义导航栏)，只保留右上角胶囊按钮 | 2.10.34  |
| backgroundColor              | HexColor | #ffffff | 背景颜色                                                     |          |
| backgroundTextStyle          | String   | dark    | 下拉背景字体、loading 图的样式，有效值 dark/light            |          |
| backgroundColorTop           | HexColor | #ffffff | 顶部窗口的背景色，仅 iOS 支持                                |          |
| backgroundColorBottom        | HexColor | #ffffff | 底部窗口的背景色，仅 iOS 支持                                |          |
| enablePullDownRefresh        | Boolean  | false   | 是否开启下拉刷新                                             |          |
| onReachBottomDistance        | Number   | 50      | 页面上拉触底事件触发时距页面底部距离，单位为 px              |          |

**注意**：

+ navigationStyle 全局配置`Android`和`iOS`从基础库版本 2.10.34 开始支持, 但子页面配置支持情况`Android`从`基础库版本 2.10.34`开始支持，`iOS`从`基础库 3.0.39`开始支持, 做低版本兼容时，通过 [swan.getSystemInfo](https://smartprogram.baidu.com/docs/develop/api/device_sys/swan-getSystemInfo/#getSystemInfo) 或者 [swan.getSystemInfoSync](https://smartprogram.baidu.com/docs/develop/api/device_sys/swan-getSystemInfo/#getSystemInfoSync) 获取百度APP版本号进行兼容判断，具体见下表；

+ 无其它特殊说明，请使用`SWAN基础库版本`进行兼容判断。

**navigationStyle配置**

| 顶bar设置           | iOS                | Android            | WebView组件页面 | 备注                                          |
| ------------------- | ------------------ | ------------------ | --------------- | --------------------------------------------- |
| 百度APP定义的顶bar  | 无版本限制         | 无版本限制         | 无版本限制      |                                               |
| 顶bar全局透明设置   | 基础库版本 2.10.34 | 基础库版本 2.10.34 | 不生效          |                                               |
| 顶bar子页面透明设置 | 基础库版本 2.10.34 | 基础库版本 2.10.34 | 不生效          | 每个page的json文件可以单独配置navigationStyle |

**适配提示**：原生顶bar高度=状态栏高度（statusBarHeight）+顶部导航栏高度（navigationBarHeight）；可通过 [swan.getSystemInfo](https://smartprogram.baidu.com/docs/develop/api/device_sys/swan-getSystemInfo/) 或者 [swan.getSystemInfoSync](https://smartprogram.baidu.com/docs/develop/api/device_sys/swan-getSystemInfoSync/) 获取。

**代码示例**

```json
{
    "window": {
        "navigationBarBackgroundColor": "#ffffff",
        "navigationBarTextStyle": "black",
        "navigationBarTitleText": "swan接口功能演示",
        "backgroundColor": "#eeeeee",
        "backgroundTextStyle": "light"
    }
}
```

### tabBar

用于设置客户端底部的tab栏：可通过tabBar设置tab的颜色、个数、位置、背景色等内容。

| 属性            | 类型     | 必填 | 描述                                                         |
| --------------- | -------- | ---- | ------------------------------------------------------------ |
| backgroundColor | HexColor | 是   | tab 的背景色。                                               |
| borderStyle     | String   | 否   | tabBar 边框颜色。有效值 black/white 两种边框颜色，默认值为 black 。 |
| color           | HexColor | 是   | tab 上文字的默认颜色。                                       |
| list            | Array    | 是   | tab 的列表，列表个数2~5个。                                  |

list 接受一个数组，tab 按数组的顺序排序，每个项都是一个对象，其属性值如下： 

- pagePath：已在 pages 中定义的页面路径；类型：String；必填项。 
- text：tab上显示的文字信息；类型：String；必填项。 
- iconPath：图片路径，icon 大小限制为40kb，建议尺寸为 78px*78px，不支持网络图片；类型：String；非必填项。 
- selectedIconPath：选中时的图片路径，icon 规格同上；类型：String；非必填项。

**代码示例**

[在开发者工具中预览效果](swanide://fragment/856bf21941915909e30407b6dceb58f51581652182529)

```json
{
    "tabBar": {
        "list": [
            {
                "pagePath": "pages/index/index",
                "text": "首页",
                "iconPath":"/images/API_normal.png",
                "selectedIconPath":"/images/API_selected.png"
        },
            {
                "pagePath": "pages/detail/detail",
                "text": "详情",
                "iconPath":"/images/component_normal.png",
                "selectedIconPath":"/images/component_selected.png"
            }
        ],
        "backgroundColor" : "#ffffff",
        "borderStyle": "white",
        "color": "#000",
        "selectedColor": "#6495ED"
    }
}

```

自定义tabbar

**代码示例**

[在开发者工具中预览效果](swanide://fragment/856bf21941915909e30407b6dceb58f51581652182529)

### requiredBackgroundModes

> 基础库 3.50.36 及以上版本支持

申明需要后台运行的能力，类型为数组。目前支持以下项目：

audio: 后台音乐播放

**代码示例**

```json
{
    "pages": ["pages/index/index"],
    "requiredBackgroundModes": ["audio"]
}
```

注：在此处申明了后台运行的接口，开发版和体验版上可以直接生效，正式版还需通过审核。

### prefetches

用于设置预请求的所有url的列表，该部分URL，会在进入小程序后自动发起请求(优于开发者代码加载)。当开发者再次发起request请求时可以增加cache参数，如果配置的prefetch请求已返回，则会直接返回请求结果，如果配置的prefetch请求还未返回，则当次request会继续之前未发送完成的request请求。

**代码示例**

[在开发者工具中预览效果](swanide://fragment/1b50c5342babcda03f71d3d559bca6fc1574152614328)

```js
// app.json
{
    prefetches: [
        'https://m.baidu.com'
    ]
}
```

```js
swan.request({
    url: 'https://m.baidu.com',
    usePrefetchCache: true,
    success: res => {
        console.log('缓存结果:', res);
    }
});
```

**注意：**路由配置
配置项中可以增加变量，且该变量只能来自于打开小程序的调起协议中的query。如：

```json
// app.json
{
    prefetches: [
        'https://m.baidu.com?id=${id}'
    ]
}
```

打开小程序的协议中，也需要携带此参数：

```
pages/index/index?id=123
```

这样，再次使用request发起请求时，就可以利用上prefetches中的配置。

### networkTimeout

各类网络请求的超时时间。

| 属性          | 类型   | 必填 | 默认值 | 说明                                        |
| ------------- | ------ | ---- | ------ | ------------------------------------------- |
| request       | number | 否   | 60000  | swan.request 的超时时间，单位：毫秒。       |
| connectSocket | number | 否   | 60000  | swan.connectSocket 的超时时间，单位：毫秒。 |
| uploadFile    | number | 否   | 60000  | swan.uploadFile 的超时时间，单位：毫秒。    |
| downloadFile  | number | 否   | 60000  | swan.downloadFile 的超时时间，单位：毫秒。  |

### 基础配置代码示例

[在开发者工具中预览效果](swanide://fragment/5ac6441402c040f2c37722872ee29c1e1576047748031)

这两个都是分包配置，分包是啥？@@@

preloadRule

subPackages

### 配置 app.js 文件

app.js 中存放全局的 JavaScript 逻辑；更多内容参见[生命周期](https://smartprogram.baidu.com/docs/develop/framework/process_life/)。

```js
App({
    onLaunch: function () {
        console.log('SWAN launch');
    },
    onShow: function () {
    console.log('SWAN展现');
    },
    onHide: function () {
    console.log('SWAN当前处于后台');
    },
    onError: function () {
    console.log('SWAN发生错误');
    },
    globalData: 'SWAN'
});

```

整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 getApp 方法获取到全局唯一的 App 示例，获取App上的数据或调用开发者注册在 App 上的函数。

```js
// xxx.js
const appInstance = getApp()
console.log(appInstance.globalData)
```

## 小程序页面配置

### 开发 .css 文件

CSS 结尾的样式文件，类似于常规 CSS，用以渲染界面时进行样式描述。
具体可以参考这里：https://smartprogram.baidu.com/docs/develop/framework/view_css/

### 开发 .js 文件

SWAN 智能小程序中，JS 文件是控制交互逻辑的动态语言
如，在 SWAN 模板中书写了以下代码：

```html
<view>{{ me }}</view>
<button bind:tap="setName">点击变值</button>
```

在 JS 中可以对于视图中的行为进行监听，并触发界面的变化。

```js
Page({
    setName: function() {
    this.setData({ me: "aaa" });
    }
})
```

错误写法：

```js
Page({
    setName: function() {
    this.Data.me = "aaa"; // 这样写不会触发swan界面的变化
    }
})
```

**注意**

书写 SWAN App 的逻辑层请使用 JavaScript 

逻辑层将数据进行更新后，会触发视图更新

在 app.js 中使用 App 方法、在页面 JS 中使用 Page 方法，来进行页面的逻辑管理

可以在 SWAN 命名空间下，使用各种 API 端能力

框架中不可使用 window, document, location, navigator, localStorage, history等Web、浏览器 API。

### 开发 .json 文件

小程序页面可以使用.json文件来对本页面的**窗口表现**进行配置。

即页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，因此无需写 window 这个键，页面中配置项会覆盖 app.json 的 window 中相同的配置项。

#### 配置示例

```js
{
    "navigationBarBackgroundColor": "#ffffff",
    "navigationBarTextStyle": "black",
    "navigationBarTitleText": "智能小程序接口功能演示",
    "backgroundColor": "#eeeeee",
    "backgroundTextStyle": "light"
}
```

#### 页面配置项列表

| 属性                         | 类型     | 默认值  | 描述                                                         | 最低版本                                          |
| ---------------------------- | -------- | ------- | ------------------------------------------------------------ | ------------------------------------------------- |
| navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色，如 `#000000`                                 |                                                   |
| navigationBarTextStyle       | String   | white   | 导航栏标题颜色，有效值 black / white                         |                                                   |
| navigationBarTitleText       | String   | --      | 导航栏标题文字内容                                           |                                                   |
| navigationStyle              | String   | default | 导航栏样式，有效值：default(默认样式) custom(自定义导航栏)，只保留右上角胶囊按钮，在页面级配置优先级高于全局配置 | iOS 基础库版本 3.0.39, Android 基础库版本 2.10.34 |
| backgroundColor              | HexColor | #ffffff | 窗口的背景色                                                 |                                                   |
| backgroundTextStyle          | String   | dark    | 下拉 loading 的样式，有效值 dark / light                     |                                                   |
| backgroundColorTop           | HexColor | #ffffff | 顶部窗口的背景色，仅 iOS 支持                                |                                                   |
| backgroundColorBottom        | HexColor | #ffffff | 底部窗口的背景色，仅 iOS 支持                                |                                                   |
| enablePullDownRefresh        | Boolean  | false   | 是否全局开启下拉刷新。详见 [Page.onPullDownRefresh](https://smartprogram.baidu.com/docs/develop/framework/app_service_pagefunction/)。 |                                                   |
| onReachBottomDistance        | Number   | 50      | 页面上拉触底事件触发时距页面底部距离，单位为px。详见[Page.onReachBottom](https://smartprogram.baidu.com/docs/develop/framework/app_service_pagefunction/)。 |                                                   |
| disableScroll                | Boolean  | false   | 设置为 true 则页面整体不能上下滚动。只在页面配置中有效，无法在 app.json 中设置 | Android暂不支持                                   |

**注意**：其他的注意要点与window配置项说明的一致，不再赘述。

### 开发 .swan 文件

这部分是每个智能小程序页面的展现模板，类似于 Web 开发中的 HTML，SWAN 模板中使用的标签均为 SWAN 组件规定的标签。

```html
<view s-for="item in items" 
      class="single-item" 
      bind:tap="oneItemClick" 
      bind:touchstart="oneItemTouchStart" 
      bind:touchmove="oneItemTouchmove" 
      bind:touchcancel="oneItemTouchcancel" 
      bind:touchend="oneItemTouchEnd">
    <image src="{{item.imgsrc}}" class="single-img"></image>
    <view class="single-text-area">
        <text class="single-title">
        {{item.title}}
    </text>
    <view s-if="{{item.tags}}" class="tag-area">
        <text s-for="tag in item.tags" class="{{tag.className}}">
            {{tag.content}}
        </text>
    </view>
    </view>
</view>
<view class="view-more" bind:tap="loadMore">
    <text>点击加载更多</text>
</view>
```

**注意**：

+ 标签可以拥有属性，swan中的属性是大小写敏感的，也就是说 class 和 Class 在swan中是不同的属性。

+ 一个文件夹可以有两个swan文件 @@@ 没看懂，意义何在？难道不能有多个嘛？，有N个页面也只是通过app.json声明不就好了

### 基础数据绑定

```html
<!-- xxx.swan -->
<view>
    Hello My {{ name }}
</view>
```

```js
// xxx.js
Page({
  data: {
    name: 'SWAN'
  }
});
```

### 模板指令

#### 循环

开发者可以通过在元素上添加`s-for`指令，来渲染一个列表。

```html
<view>
    <view s-for="p in persons">
    {{p.name}}
    </view>
</view>
```

```js
Page({
  data: {
    persons: [
      {name: 'superman'},
      {name: 'spiderman'}
    ]
  }
});
```

#### 条件

开发者可以通过在元素上添加`s-if`指令，来在视图层进行逻辑判断：

```html
<view s-if="is4G">4G</view>
<view s-elif="isWifi">Wifi</view>
<view s-else>Other</view>
```

```js
Page({
  data: {
    is4G: true,
    isWifi: false
  }
});
```

### 事件绑定

开发者可以使用`bind: + 事件名`来进行事件绑定

```html
<view class="view-more" bind:tap="loadMore">
    点击加载更多
</view>
```

```js
Page({
  loadMore: function () {
    console.log('加载更多被点击');
  }
});
```

#### 事件类型

| 类型        | 触发条件                         |
| ----------- | -------------------------------- |
| touchstart  | 手指触摸开始                     |
| touchmove   | 手指触摸后进行移动               |
| touchend    | 手指触摸结束                     |
| touchcancel | 手指触摸动作被打断，如来电提醒等 |
| tap         | 手指触摸后马上离开动作           |

#### 事件对象

当开发者绑定方法到事件，事件触发时，SWAN 会给触发的方法传递事件对象，事件对象因事件不同而不同，目前**基础的事件**对象结构为：

| 属性          | 类型   | 说明               |
| :------------ | :----- | :----------------- |
| type          | String | 事件类型           |
| currentTarget | Object | 事件触发的属性集合 |

#### touches

开发者在接收到触摸类事件后，在事件对象上，可以接收到当前停留在屏幕上的触摸点。

| 属性              | 类型   | 描述                                       |
| ----------------- | ------ | ------------------------------------------ |
| pageX , pageY     | Number | 距离文档左上角的距离，横向为 X，纵向为 Y   |
| clientX , clientY | Number | 距离屏幕视口左上角距离，横向为 X，纵向为 Y |

```html
 <view bind:touchstart="viewtouchstart">viewtouchstart</view>
```

```js
Page({
  viewtouchstart: function (event) {
    console.log('value is:', event.touches);
    // 输出 clientX: 44，clientX: 47，pageX: 44, pageY: 47
  }
});
```

#### dataset

开发者可以在组件中自定义数据，并在事件发生时，由 SWAN 所在事件对象中，传递给绑定函数。

```html
<view data-swan="1" bind:tap="viewtap">dataset-test</view>
```

```js
Page({
    viewtap: function (event) {
    console.log('value is:', event.currentTarget.dataset.swan);// 输出1
    }
});
```

属性值也可以动态的去改变，有所不同的是，属性值必须被包裹在双引号中, 且引号可加可不加

```html
<view data-swan={{test}} bind:tap="viewtap">dataset-test</view>
// 同<view data-swan="{{test}}" bind:tap="viewtap">dataset-test</view>
```

```js
Page({
  data: {
    test: 1
  },
  viewtap: function (event) {
    console.log('value is:', event.currentTarget.dataset.swan);// 输出1
  }
});
```

**注意**：变量名是大小写敏感的，也就是说 test 和 Test 是两个不同的变量。

### Page

Page() 函数用来注册一个页面。**接受一个 object 参数**，其指定页面的初始数据、生命周期函数、事件处理函数等。

**object 参数说明**：

| 属性              | 类型     | 描述                                                         |
| ----------------- | -------- | ------------------------------------------------------------ |
| data              | Object   | 页面的初始数据                                               |
| onLoad            | Function | 监听页面加载的生命周期函数                                   |
| onReady           | Function | 监听页面初次渲染完成的生命周期函数                           |
| onShow            | Function | 监听页面显示的生命周期函数                                   |
| onHide            | Function | 监听页面隐藏的生命周期函数                                   |
| onUnload          | Function | 监听页面卸载的生命周期函数                                   |
| onPullDownRefresh | Function | 监听用户下拉动作                                             |
| onReachBottom     | Function | 页面上拉触底事件的处理函数                                   |
| onShareAppMessage | Function | 用户点击右上角转发                                           |
| onURLQueryChange  | Function | 监听页面 URL query 改变                                      |
| onError           | Function | 错误监听函数                                                 |
| 其他              | 不限     | 开发者可以添加任意的函数或数据到 object 参数中，在页面的函数中用 this 可以访问 |

智能小程序框架，会将同页面的 .swan 文件与 .js 中定义的 Page 对象中的 data，进行组合渲染。

### 组件

智能小程序中提供了丰富多样的组件，开发者可以在 .swan 文件中，使用预设好的组件，拼装完成自己的智能小程序的页面。

如：使用 slider 组件

```html
<slider min="200" max="1500" value="{{switchDuration}}"></slider>
```

即可在页面上展示一个 slider 组件。

也可以在 slider 组件上绑定事件，在相应的组件事件发生时，得到回调与组件信息：

```html
<slider min="200" max="1500" value="{{switchDuration}}" bind:change="changeSlider"></slider>
```

```js
Page({
    changeSlider: function () {
        console.log('changeSwitchDuration');
    }
});
```

### API

智能小程序为开发者提供了百度APP 提供的丰富的端能力。使用方式比较简单，直接调用 SWAN 对象上的端能力方法，或者 Page 对象中 this 上挂载的方法。

**showToast**

```js
swan.showToast({
    title: '我是标题'
});
```

也有很多挂载在 Page 对象与 SWAN 上的方法，如 createCanvasContext，在 SWAN 对象与 Page 对象上均有。所以，你可以这样用：

```js
Page({
  data: {},
  onLoad: function () {
    this.createCanvasContext();
  }
});
```

```js
Page({
  data: {},
  onLoad: function () {
    swan.createCanvasContext();
  }
});
```

但是推荐使用第一种方法，可以在当前 Page 上精准查找，避免一些问题。具体方法的挂载，在 [API 章节](https://smartprogram.baidu.com/docs/develop/api/apilist/) 会有详细介绍。

## 文件作用域

在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，且不会互相影响。
通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 [App()](https://smartprogram.baidu.com/docs/develop/framework/app_service_register/#App/) 中设置

**代码示例**

```js
// app.js
App({
    data: 1
});
```

```js
// page.js
var app = getApp();
app.data++;
```

```js
// page2.js
var app = getApp();
console.log(app.data);
// 2
```

## 路由

### 页面栈

框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：

| 路由方式   | 页面栈表现                          |
| ---------- | ----------------------------------- |
| 初始化     | 新页面入栈                          |
| 打开新页面 | 新页面入栈                          |
| 页面重定向 | 当前页面出栈，新页面入栈            |
| 页面返回   | 页面出栈                            |
| Tab 切换   | 页面全部出栈，只留下初始的 Tab 页面 |
| 重加载     | 页面全部出栈，只留下新的页面        |

**注意**：开发者可以使用 getCurrentPages() 函数获取当前页面栈。

### getCurrentPages()

getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。

[在开发者工具中预览效果](swanide://fragment/be265192b32b09af4deb17093bfb73cb1576048350631)

### 路由方式

对于路由的触发方式以及页面生命周期函数如下：

| 路由方式   | 触发时机                                                     | 路由前页面 | 路由后页面         |
| ---------- | ------------------------------------------------------------ | ---------- | ------------------ |
| 初始化     | 智能小程序打开的第一个页面                                   |            | onLoad, onShow     |
| 打开新页面 | 调用 API [swan.navigateTo](https://smartprogram.baidu.com/docs/develop/api/show/tab_swan-navigateTo/) 或使用[组件](https://smartprogram.baidu.com/docs/develop/component/nav/) < navigator open-type="navigateTo"/ > | onHide     | onLoad, onShow     |
| 页面重定向 | 调用 API [swan.redirectTo](https://smartprogram.baidu.com/docs/develop/api/show/tab_swan-redirectTo/) 或使用[组件](https://smartprogram.baidu.com/docs/develop/component/nav/) < navigator open-type="redirectTo"/ > | onUnload   | onLoad, onShow     |
| Tab 切换   | 调用 API [swan.switchTab](https://smartprogram.baidu.com/docs/develop/api/show/tab_swan-switchTab/) 或使用[组件](https://smartprogram.baidu.com/docs/develop/component/nav/) < navigator open-type="switchTab"/ > 或用户切换 Tab |            | 各种情况请参考下表 |
| 页面返回   | 调用 API [swan.navigateBack](https://smartprogram.baidu.com/docs/develop/api/show/tab_swan-navigateBack/) 或使用[组件](https://smartprogram.baidu.com/docs/develop/component/nav/) < navigator open-type="navigateBack"/ > 或用户按左上角返回按钮 | onUnload   | onShow             |
| 重启动     | 调用 API [swan.reLaunch](https://smartprogram.baidu.com/docs/develop/api/show/tab_swan-reLaunch/) 或使用[组件](https://smartprogram.baidu.com/docs/develop/component/nav/) < navigator open-type="reLaunch"/ > | onUnload   | onLoad, onShow     |

Tab 切换对应的生命周期（以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例）：

| 当前页面        | 路由后页面    | 触发的生命周期（按顺序）                           |
| --------------- | ------------- | -------------------------------------------------- |
| A               | A             | Nothing happend                                    |
| A               | B             | A.onHide(), B.onLoad(), B.onShow()                 |
| A               | B（再次打开） | A.onHide(), B.onShow()                             |
| C               | A             | C.onUnload(), A.onShow()                           |
| C               | B             | C.onUnload(), B.onLoad(), B.onShow()               |
| D               | B             | D.onUnload(), C.onUnload(), B.onLoad(), B.onShow() |
| D（从转发进入） | A             | D.onUnload(), A.onLoad(), A.onShow()               |
| D（从转发进入） | B             | D.onUnload(), B.onLoad(), B.onShow()               |

[在开发者工具中预览效果](swanide://fragment/587cfc623ceb2b4608e69b31ddb73f801577942344726)

> 建议在开发者工具中的控制台查看，工具与真机略有差异，以真机的生命周期为准。

**注意**:

- navigateTo, redirectTo 只能打开非 tabBar 页面。
- switchTab 只能打开 tabBar 页面。
- reLaunch 可以打开任意页面。
- 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。
- 调用页面路由带的参数可以在目标页面的 onLoad 中获取。

**关于页面传参:**
从其它页面跳转到由自定义组件构造的页面时，如跳转到页面 /components/custom/custom?paramA=123&paramB=xyz ，你可以在由custom组件构造的页面onLoad生命周期中获取传递的query字段。

# 框架接口

## 小程序App

### App函数

App 函数用来注册一个智能小程序。接受一个 Object 作为参数，用以指定智能小程序的生命周期函数等。

**参数**

| 属性           | 类型     | 描述                                                         | 触发时机                                                     | Web 态说明                                                   |
| -------------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 其他           | Any      | 开发者可以添加任意的函数或者数据到 Object 参数中, 用 this 可以访问。 |                                                              |                                                              |
| onLogin        | Function | 生命周期函数 -- 监听 Web 态小程序登录成功( Web 态小程序独有) | 当小程序初次登录成功后，会触发 onLogin （全局只触发一次）。  | 仅在 Web 态小程序中有效，百度 APP 端内小程序此生命周期不会触发 |
| onLaunch       | Function | 生命周期函数 -- 监听小程序的初始化 。                        | 当小程序初始化完成时，会触发 onLaunch （全局只触发一次）。   |                                                              |
| onShow         | Function | 生命周期函数 -- 监听小程序的显示 。                          | 当小程序初始化，或从后台进入前台显示，会触发 onShow 。       | 仅在小程序初始化时触发                                       |
| onHide         | Function | 生命周期函数 -- 监听小程序的隐藏 。                          | 当小程序从前台进入后台，会触发 onHide。                      | 暂不支持                                                     |
| onError        | Function | 错误监听函数。                                               | 小程序发生脚本错误，或者 api 调用失败时触发，会带上错误信息。 |                                                              |
| onPageNotFound | Function | 页面不存在监听函数。                                         | 小程序要打开的页面不存在时触发，会带上页面信息回调该函数。   |                                                              |

### 注意

App函数必须在 app.js 中被调用一次。该函数在整个小程序中不能被调用多次，否则会出现无法预期的后果

开发者可以在回调中进行页面重定向。

**Web 态：**

由于 Web 态框架暂不支持当前是否进入前、后台的状态检测，因此在下列场景中，App.onShow、App.onHide 生命周期无法触发

- 当 Web 态小程序从后台切换至前台时，如从任务管理器进入、或关闭显示在上层的语音助手等，App.onShow 生命周期无法触发
- 由于 Web 态框架暂不支持当前是否进入前、后台的状态检测，因此 Web 态小程序暂不支持 App.onHide 生命周期

**前台、后台：**

当用户点击右上角的关闭，或者按了设备的 Home 键离开智能小程序，智能小程序没有直接销毁，而是进入到了后台；当再次进入智能小程序，又会从后台进入前台。

**销毁：**

只有在以下情况小程序才可能会被动销毁，参考[运行机制](https://smartprogram.baidu.com/docs/develop/framework/operating-mechanism/):

- 进入后台超过5分钟；
- 系统资源占用过高；
- 打开小程序数量超过系统支持上限(系统按照小程序被打开的先后顺序进行销毁)。

**场景值：** 

智能小程序被打开时，其来源渠道的标识（例如: 从百度搜索结果打开、从百度信息流打开），开发者可以利用该字段统计小程序在什么场景下被打开，[更多场景值](https://smartprogram.baidu.com/docs/data/scene/)；

**调起协议：** 

宿主（例如百度App）用于识别一个小程序被打开时的初始化信息（例如: 小程序的appKey、path、query等），由该类信息构成的一个协议。

### **onLogin(options)**

使用 onLogin 生命周期的意义：Web 态小程序初次登录成功后开发者能获取登录成功的 code。

适用 onLogin 原因：与百度 App 端内小程序登录不同（在小程序内部登录），Web 态的登录需要跳转百度登录页面进行登录，登录成功后自动跳转原页面。该跳转过程会导致 Web 态的原执行上下文状态丢失，从而无法通过 swan.login 的成功回调获取登录成功的 code。因此必须通过 onLogin 生命周期获取该 code

**options参数：**

| 字段 | 类型   | 说明                                    |
| ---- | ------ | --------------------------------------- |
| code | String | 登录成功后的 code，用于换取 session_key |

### onLaunch(options)

小程序初始化完成时触发，全局只触发一次。

**options参数：**

| 字段                   | 类型   | 说明                                                         |
| ---------------------- | ------ | ------------------------------------------------------------ |
| scene                  | String | 打开智能小程序的[场景值](https://smartprogram.baidu.com/docs/data/scene/)，scene值统一由百度小程序场景值管理中心在B端平台统一配置后下发到宿主（例如百度App），调起协议中会携带相应入口的scene值。 |
| path                   | String | 打开小程序的路径。                                           |
| query                  | Object | 打开当前页面路径中的参数。                                   |
| shareTicket            | String | 标记转发对象。                                               |
| referrerInfo           | Object | 从另一个小程序打开该小程序时，返回此字段。                   |
| referrerInfo.appId     | String | 来源小程序的 appKey。                                        |
| referrerInfo.extraData | Object | 来源小程序传过来的数据。                                     |

### onShow(options)

小程序启动，或从后台进入前台显示时触发。也可以使用 [swan.onAppShow](https://smartprogram.baidu.com/docs/develop/api/base_app_event/swan-onAppShow/) 绑定监听。

**参数：**与 [swan.onPageNotFound](https://smartprogram.baidu.com/docs/develop/api/base_app_event/swan-onPageNotFound/) 一致

| 属性         | 类型   | 说明                                                         | 最低版本 |
| :----------- | :----- | :----------------------------------------------------------- | :------- |
| scene        | String | 打开智能小程序的[场景值](https://smartprogram.baidu.com/docs/data/scene/) |          |
| path         | String | 打开小程序的路径。                                           |          |
| query        | Object | 打开小程序的query。                                          |          |
| shareTicket  | String | 标记转发对象。                                               |          |
| referrerInfo | Object | 从另一个小程序打开该小程序时，返回此字段。                   |          |
| entryType    | String | 页面展现的来源标识，可取的值为: 'user'、'schema'、'sys'，对应代表的意义如下表。 | 2.10.7   |
| appURL       | String | 展现时的调起协议，仅当entryType值为 schema 时存在。          | 2.10.7   |

**referrerInfo 的结构**

| 属性      | 类型   | 说明                   |
| :-------- | :----- | :--------------------- |
| appId     | String | 来源小程序的 appKey。  |
| extraData | Object | 来源小程序传过来的数据 |

**entryType 的取值说明**

| 属性   | 类型   | 说明                                         |
| :----- | :----- | :------------------------------------------- |
| user   | String | 表示通过home前后台切换或解锁屏幕等方式调起。 |
| schema | String | 表示通过协议调起。                           |
| sys    | String | 其它。                                       |

### onHide()

小程序从前台进入后台时触发。也可以使用 [swan.onAppHide](https://smartprogram.baidu.com/docs/develop/api/base_app_event/swan-onAppHide/) 绑定监听。

### onError(err)

小程序发生脚本错误或 API 调用报错时触发。也可以使用 [swan.onError](https://smartprogram.baidu.com/docs/develop/api/base_app_event/swan-onError/) 绑定监听。

**参数：** 错误信息，包含堆栈。与 [swan.onError](https://smartprogram.baidu.com/docs/develop/api/base_app_event/swan-onError/) 一致

### onPageNotFound(options)

小程序要打开的页面不存在时触发。也可以使用 [swan.onPageNotFound](https://smartprogram.baidu.com/docs/develop/api/base_app_event/swan-onPageNotFound/) 绑定监听。注意事项请参考 [swan.onPageNotFound](https://smartprogram.baidu.com/docs/develop/api/base_app_event/swan-onPageNotFound/)。

**参数：** 与 [swan.onPageNotFound](https://smartprogram.baidu.com/docs/develop/api/base_app_event/swan-onPageNotFound/) 一致

| 属性        | 类型    | 说明                                                         |
| :---------- | :------ | :----------------------------------------------------------- |
| path        | string  | 不存在页面的路径                                             |
| query       | Object  | 打开不存在页面的 query 参数                                  |
| isEntryPage | boolean | 是否本次启动的首个页面（例如从分享等入口进来，首个页面是开发者配置的分享页面） |

### getApp()

全局的 getApp 函数可以用来获取到智能小程序实例。

**参数**

| 属性         | 类型    | 默认值 | 必填 | 说明                                                         | 最低版本 |
| ------------ | ------- | ------ | ---- | ------------------------------------------------------------ | -------- |
| allowDefault | boolean | false  | 否   | 在 App 未定义时返回默认实现。当App被调用时，默认实现中定义的属性会被覆盖合并到App中。一般用于[独立分包](https://smartprogram.baidu.com/docs/develop/framework/subpackages/)。 | 3.60.2   |

```js
// other.js 获取以上经过App方法注册后的app实例
var appInstance = getApp();
console.log(appInstance.globalData); // This is global data
```

若以上写法不能获取到全局实例，建议按照以下写法。

```js
Page({
    data: {
        appData: getApp().globalData
    },
    onShow() {
        console.log(this.data.appData);
    }
)}
```

**注意：**

- App() 必须在 app.js 中注册，且不能注册多个；
- 不要在 App() 内的函数中调用 getApp() 函数，可以通过 this 获取 app 实例；
- 不要在 onLaunch 中调用 getCurrentPages() ，因为此时 page 还没有生成。

## 页面Page

### 参数说明

Page 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、页面事件处理函数、组件事件处理函数等。

| 属性              | 类型     | 描述                                                         |
| ----------------- | -------- | ------------------------------------------------------------ |
| data              | Object   | 页面的初始数据                                               |
| onLoad            | Function | 页面的生命周期函数 -- 监听页面加载                           |
| onShow            | Function | 页面的生命周期函数 -- 监听页面显示                           |
| onReady           | Function | 页面的生命周期函数 -- 监听页面初次渲染完成                   |
| onHide            | Function | 页面的生命周期函数 -- 监听页面隐藏                           |
| onUnload          | Function | 页面的生命周期函数 -- 监听页面卸载                           |
| onForceReLaunch   | Function | 页面的生命周期函数 -- 监听页面重启，单击右上角菜单栏的重启按钮时触发 |
| onPullDownRefresh | Function | 页面的事件处理函数 -- 监听用户下拉动作                       |
| onReachBottom     | Function | 页面的事件处理函数 -- 上拉触底事件的处理函数                 |
| onShareAppMessage | Function | 页面的事件处理函数 -- 用户点击右上角转发                     |
| onPageScroll      | Function | 页面的事件处理函数 -- 页面滚动触发事件的处理函数             |
| onTabItemTap      | Function | 页面的事件处理函数 -- 当前是 tab 页时，点击 tab 时触发       |
| onURLQueryChange  | Function | 页面的事件处理函数 -- 监听页面 URL query 改变                |
| 其他              | Any      | 开发者可以添加任意的函数或数据到 object 参数中               |

### 初始化数据

初始化数据将作为页面的第一次渲染数据。data 将会以 JSON 的形式由逻辑层传至渲染层，所以其数据必须是可以转成 JSON 的格式：字符串(例如: 数字，布尔值，对象，数组)。

渲染层，通过SWAN模板，对数据进行绑定。

```js
// index.js
Page({
    data: {
        text: 'init data',
        arr: [{name: 'swan'}, {name: 'Baidu'}]
    }
});
```

### 生命周期函数

#### onLoad(Object query)

页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。

**参数：**

| 属性名 | 类型   | 说明                     |
| ------ | ------ | ------------------------ |
| query  | Object | 打开当前页面路径中的参数 |

```js
// 添加onLoad代理示例

var originPage = Page

function MyPage(config) {
   this.lifetimeProxy = {
     onLoad: config.onLoad
   }
   config.onLoad = function(options) {
     // 自定义代码
     // 公共的初始化代码
     this.userData = getUserData()
   }
  
  // ...

  originPage(config)
}
```

#### onShow()

页面显示/切入前台时触发。

#### onReady()

页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。

#### onHide()

页面隐藏/切入后台时触发。 如通过调用 [swan.navigateTo](https://smartprogram.baidu.com/docs/develop/api/show/tab_swan-navigateTo/) 或底部 tab 切换到其他页面，小程序切入后台等时触发。

#### onUnload()

页面卸载时触发。如通过调用 [swan.redirectTo](https://smartprogram.baidu.com/docs/develop/api/show/tab_swan-redirectTo/) 或 [swan.navigateBack](https://smartprogram.baidu.com/docs/develop/api/show/tab_swan-navigateBack/) 到其他页面时触发。

### 页面事件处理函数

#### onPullDownRefresh

在 Page 中定义 onPullDownRefresh 处理函数，监听该页面用户下拉刷新事件。

[在开发者工具中预览效果](swanide://fragment/f98d38475a52642dc24881e1c63bc47b1578383993104)

**说明**：

- 需要在`app.json`的`window`选项中开启 `enablePullDownRefresh`；
- 如果需要单个页面支持下拉刷新，可以直接在页面目录下的 json 配置文件中开启`enablePullDownRefresh`；
- 当处理完数据刷新后，[`swan.stopPullDownRefresh`](https://smartprogram.baidu.com/docs/develop/api/show/pull_swan-startPullDownRefresh/#swan-stopPullDownRefresh/)可以停止当前页面的下拉刷新。

#### onReachBottom

在`Page`中定义 onReachBottom 处理函数，监听该页面用户上拉触底事件。

[在开发者工具中预览效果](swanide://fragment/19863fc91f9ea66d1154820bc01769171577102326931)

```js
// page.js
Page({
    onReachBottom(e) {
        console.log('onReachBottom')
        // 常见的业务场景是开发者在这里请求分页数据
    }
});
```

**说明**：

- 可以在 app.json 的 window 选项中或页面配置中设置触发距离 onReachBottomDistance 。
- 在触发距离内滑动期间，该事件只会被触发一次。

#### onPageScroll(object)

在 Page 中定义 onPageScroll 处理函数，监听用户滑动页面事件。

**Object参数说明**：

| 字段      | 类型   | 说明                                 |
| --------- | ------ | ------------------------------------ |
| scrollTop | Number | 页面在垂直方向已滚动的距离（单位px） |

[在开发者工具中预览效果](swanide://fragment/d702c48d19da7bf5f3fee2aaaf9788361578384055818)

```js
// page.js
Page({
    onPageScroll(e) {
        console.log(e)
    }
});
```

**注意：**

- 请在需要的时候定义此方法，以减少不必要的事件派发对渲染层-逻辑层通信造成影响；
- 请避免在 onPageScroll 中过于频繁的执行 setData 等引起逻辑层-渲染层通信的操作（尤其是每次传输大量数据的时候）。

#### onShareAppMessage(object)

在 Page 中定义 onShareAppMessage 函数，设置该页面的分享信息。

用户点击页面内的"分享"按钮([`button`](https://smartprogram.baidu.com/docs/develop/component/formlist_button/) 组件 open-type="share")或者页面右上角菜单的"分享"按钮的时候会调用；

此事件需要 return 一个`Object`，用于自定义分享内容。

**Web 态说明**：Web 态下，由于暂不支持分享，该方法不生效。

**Object参数说明**：

| 参数名 | 类型   | 必填 | 默认值 | 说明                                                         |
| ------ | ------ | ---- | ------ | ------------------------------------------------------------ |
| from   | String | 是   |        | 分享事件来源。button：页面内转发按钮；menu：右上角分享菜单 。 |
| target | Object | 是   |        | 如果 from 值是 button，则 target 是触发这次转发事件的 button，否则为 undefined。 |

**自定义分享字段**：

| 参数名   | 类型     | 必填 | 说明                                             |
| -------- | -------- | ---- | ------------------------------------------------ |
| title    | String   | 否   | 分享标题                                         |
| content  | String   | 否   | 分享内容                                         |
| imageUrl | String   | 否   | 分享图标                                         |
| path     | String   | 否   | 页面 path，必须是以 / 开头的完整路径。           |
| success  | Function | 否   | 接口调用成功的回调函数                           |
| fail     | Function | 否   | 接口调用失败的回调函数                           |
| complete | Function | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

**场景一：分享页面为 tab 页**

[在开发者工具中预览效果](swanide://fragment/6b1e6d28c542397d04f5408242ac55a21573032765644)

```js
Page({
    data: {
        title: '全球实时财经行情'//推荐设置为具有小程序特色的标题  
    },
    onShareAppMessage() {
        return {
            title: this.data.title,
            content: '世界很复杂，百度更懂你——小程序简介或详细描述',//推荐设置为小程序简介或描述  
            imageUrl: 'https://b.bdstatic.com/miniapp/images/bgt_icon.png',
            path: '/index/index',
            success(res) {
                // 分享成功
            },
            fail(err) {
                // 分享失败
            }
        };
    }
});
```

**场景二：分享页面为详情落地页**

```js
Page({
    data: {
        // 实际应用中动态获取
        title: '美的集团(000333)',//推荐设置为详情页title
        price: '58.2',
        quoteChange: '+1.3%',
        id: '000333'
    },

    onLoad(res) {
        swan.setNavigationBarTitle({
            title: this.data.title
        })
    },

    onShareAppMessage(res) {
        return {
            title: this.data.title + ' 最新报价' + this.data.price,
            content: '更精简的股票小程序——股票精灵，快来查看热门股票吧',//推荐设置为详情页简介
            imageUrl: 'https://b.bdstatic.com/miniapp/images/bgt_icon.png',
            path: `/stockDetail/stockDetail?id=${this.data.id}`
        }
    }
});
```

**场景三：分享页面为资讯落地页**

```js
Page({
    data: {
        title: '瑞信：予美团“跑赢大市”评级',//推荐设置为文章标题
        content: [
            // 第一自然段
            '瑞信发布报告称，美团(03690)第三季外送业务同比增长约36%，加上盈利能力的持续改善，期内季绩将强劲增长，预计全年收入可同比增长38%至264亿元人民币，非国际财务报告准则净收益或达4.78亿元人民币。',
            // 第二自然段
            '该行称，尽管受季节性因素影响，第四季成本及补贴费用可能会较高，但预期业务正在稳步发展，期内订单量强劲增长或有助部分抵消季节性负面影响，相信今年全年可实现收支平衡，上调2019年盈利预测，调整后净利润达11亿元人民币。'
        ]//推荐设置为文章第一段
    },
    onLoad(options) {
        this.data.id = options.id || '';
    },
    onShareAppMessage() {
        return {
            title: this.data.title,
            content: this.data.content[0],
            imageUrl: 'https://b.bdstatic.com/miniapp/images/bgt_icon.png',
            path: '/article/article?id=${this.data.id}',
        };
    }
});

```

**Tips**
Page 中没有定义 onShareAppMessage 函数也可以正常调起分享功能，分享数据会优先使用setPageInfo中设置的页面标题和描述信息，其次使用小程序标题、小程序简介、小程序头像，再其次会使用默认智能小程序文案作为兜底，所以推荐开发者优先使用setPageInfo完善页面信息。

#### **分享渠道及字段说明图示**

![image-20200416091848488](Swan/image-20200416091848488.png)

![image-20200416091942583](Swan/image-20200416091942583.png)

![image-20200416092002286](Swan/image-20200416092002286.png)

![image-20200416092024100](Swan/image-20200416092024100.png)

![image-20200416092039648](Swan/image-20200416092039648.png)

### onTabItemTap(Object object)

点击 tab 时触发。

**Object参数说明**：

| 参数名   | 类型   | 说明                         | 最低版本                                                     |
| -------- | ------ | ---------------------------- | ------------------------------------------------------------ |
| index    | String | 被点击tabItem的序号，从0开始 | [3.0.2](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| pagePath | String | 被点击tabItem的页面路径      | [3.0.2](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| text     | String | 被点击tabItem的按钮文字      | [3.0.2](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |

[在开发者工具中预览效果](swanide://fragment/31512b7bbfc12330f054e50873b05b8b1560700621686)

```js
// tab.js
Page({
    onTabItemTap(item) {
        console.log(item.index);
        console.log(item.pagePath);
        console.log(item.text);
    }
});
```

### onURLQueryChange

在 Page 中定义 onURLQueryChange 处理函数，监听页面 URL query 改变。引起页面 URL query 更新的原因有：调用 [swan.setURLQuery](https://smartprogram.baidu.com/docs/develop/api/url_query/swan-setURLQuery/) 。

**Object参数说明**：

| 字段        | 类型   | 说明               |
| ----------- | ------ | ------------------ |
| newURLQuery | Object | 改变后的 URL query |
| oldURLQuery | Object | 改变前的 URL query |

[在开发者工具中预览效果](swanide://fragment/5bb1ffbf3d23686cf27bf5ba40329d491567219843686)

```js
Page({
    onURLQueryChange({newURLQuery, oldURLQuery}) {
        console.log(newURLQuery, oldURLQuery) //  输出结果为 {channel: 'movie'} {}
    },
    onLoad(query) {
        if(!query.channel) {
            swan.setURLQuery({channel: 'movie'})
        }
    }
})
```

### 注意

**Web 态说明：**

由于 Web 态框架暂不支持当前是否进入前、后台的状态检测，因此在下列场景中，Page.onShow、Page.onHide 生命周期无法触发

- 当 Web 态小程序从后台切换至前台时，如从任务管理器进入、或关闭显示在上层的语音助手等，Page.onShow 生命周期无法触发
- 当 Web 态小程序从前台切换至后台时，如按下 Home 键，Page.onHide 生命周期无法触发
- 当从 Web 态小程序跳转至其它第三方网页或应用时，如从 Web 态小程序打开拨号界面，Page.onHide 生命周期无法触发
- 关闭 Web 态小程序，Page.onHide 生命周期无法触发

更多内容参见[生命周期](https://smartprogram.baidu.com/docs/develop/framework/process_life/)。

**菜单栏：**

页面右上角获取菜单按钮（右上角胶囊按钮）中三个点的图标，点击会弹出菜单面板(包含: 分享、评价、重启小程序等功能)。

### 组件事件处理函数

除了初始化数据和生命周期函数，Page 中还可以定义一些特殊的函数：事件处理函数。在渲染层可以在组件中加入事件绑定，当达到触发事件时，就会执行 Page 中定义的事件处理函数。

```html
<!-- page.swan -->
<view bindtap="onTap"> tap </view>
```

```js
// page.js
Page({
    onTap() {
        console.log('tap');
    }
});
```

## setData 机制

setData 函数用于将数据，从逻辑层发送到视图层，当开发者调用 setData 后，数据的变化会引起视图层的更新。

**参数说明**

| 属性     | 类型     | 默认值 | 必填 | 描述                                      |
| -------- | -------- | ------ | ---- | ----------------------------------------- |
| data     | Object   |        | 是   | 这次要改变的数据                          |
| callback | Function |        | 否   | setData引起的界面更新渲染完毕后的回调函数 |

**说明**：

- Object 以`key: value`的形式表示，将`this.data`中的`key`对应的值改变成`value`。
  `key`可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性，如`array[2].message`、`a.b.c.d`，并且不需要在 `this.data`中预先定义；
- 直接修改`this.data`而不调用`this.setData`是无法改变页面的状态的，还会造成数据不一致；
- 仅支持设置可 JSON 化的数据；
- 请不要把`data`中任何一项的`value`设为`undefined`，否则将会有一些潜在问题出现；
- data 的键名必须遵守 camelCase (驼峰式)的命名规范，不得使用 kebab-case (短横线隔开式)规范。

连续使用 setData 来改变界面的方法也可以达到动画的效果。这样可以任意地改变界面，但通常会产生较大的延迟或卡顿，甚至导致小程序僵死。此时可以通过将页面的 setData 改为 自定义组件 中的 setData 来提升性能。下面的例子是使用 setData 来实现秒表动画的示例。

[在开发者工具中预览效果](swanide://fragment/cf67007a80abff300e2d312e73356ee71577267116005)

## getCurrentPages

getCurrentPages 全局函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。

[在开发者工具中预览效果](swanide://fragment/a79428623e5ec684cacf94009c3c1d271578384211646)

**注意: 不要尝试修改页面栈，会导致路由以及页面状态错误。**。

## 模块化

可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块可以通过 module.exports、exports 或者 export 对外暴露接口，使用require 或者 import 进行导入。

```js
// utils.js
var name = 'swan';
var age = 0;
function logName() {
    console.log(name);
}
function logAge() {
    console.log(age);
}
module.exports.logName = logName;
module.exports.logAge = logAge;
```

可以在需要使用这些模块的文件中，对模块进行引用：

```js
var utils = require('./utils');
Page({
    onLoad: function () {
        utils.logName();
    }
});
```

### 模块化编译方式

编译工具提供**依赖分析模式**和**普通编译模式**两种编译模式：

**依赖分析模式**

无用文件（不包含图片）不会被打包到产出中,支持node_modules的使用。

在依赖分析编译模式下正确的模块引用方式：

```js
// 在app.js中引用util文件夹下的a.js的方式:
require('./util/a.js');
// b.js中引用a.js
require('./a.js');
// 从当前目录到项目根目录下递归寻找node_modules文件夹中是否存在a.js，没有则报错；
require('a.js');
```

**普通编译模式**

不支持node_modues的使用。

在普通模式下正确的模块引用方式:

```js
// 在app.js中引用util文件夹下的a.js的方式:
1. require('/util/a.js');
2. require('./util/a.js');
3. require('util/a.js');
```

## AOP机制

小程序的开发者或者服务商会提供一些lib库，用来代理小程序的生命周期或API等，进而想要进行一些通用逻辑的处理(例如: 打点/事件触发/统一登录等等通用逻辑)。

通常，小程序开发者们使用这些扩展包时，不得不在各个使用点（生命周期、事件触发等）处显式调用。

为解决该类问题，智能小程序在框架层提供切面。让扩展包的开发者可以在小程序运行的生命周期/事件触发/API调用等处，注入通用逻辑。

### App.after(object)

App.after可以增加APP级的切面，触发的时机是在所拦截的对应生命周期方法执行之后。

> 基础库 3.20.+ 版本才支持。

**Object 参数说明**：

| 属性名  | 类型   | 默认值 | 必填 | 说明                             |
| ------- | ------ | ------ | ---- | -------------------------------- |
| methods | Object |        | 否   | 所有需要拦截的生命周期方法的集合 |

可拦截的所有方法：

- onLaunch
- onShow
- onHide
- onError
- onPageNotFound

```js
// app.js
App({
    onShow() {
        console.log('normal onShow');
    }
});

App.after({
    methods: {
        onShow() {
            console.log('after app onshow');
        }
    }
});
/**
 * 打印结果
 * normal onShow
 * after app onshow
 */
```

### Page.after(object)

Page.after可以增加Page级的切面，触发的时机是在所拦截的对应生命周期方法执行之后，也可以拦截所有页面上发生的事件（对于要拦截的事件，在swan文件上必须显示绑定了相应事件）。

#### **Object 参数说明**：

| 属性名  | 类型   | 默认值 必填 |      | 说明                                                         |
| ------- | ------ | ----------- | ---- | ------------------------------------------------------------ |
| url     | String |             | 否   | 要增加切面的页面的URL规则, 当URL参数不填时，则默认拦截所有页面 |
| methods | Object |             | 否   | 所有需要拦截的生命周期方法的集合                             |
| events  | Object |             | 否   | 所有要拦截的事件的集合                                       |

可拦截的所有方法：

- onLoad
- onReady
- onShow
- onHide
- onUnload
- onForceReLaunch
- onPullDownRefresh
- onReachBottom
- onPageScroll
- onTabItemTap
- onURLQueryChange

```js
// 为url中含有page/index的page实例增加切面
Page.after({

    url: /pages\/index/,

    // 拦截页面中的生命周期onShow
    methods: {
        onShow(context) {
            console.log('message after normal show function');
        }
    },

    // 拦截页面中，属性有data-tag="1"的节点的tap事件
    events: {
        '[data-tag="1"]:tap': function (context) {
            console.log('message after a tag is tapped');
        }
    }
});
```

### swan.after(object)

 swan.after可以拦截所有当前运行小程序对于API的调用，默认传入`function`时，只在API函数调用的返回阶段拦截。如果传入Object，则可以选择拦截的阶段（例如: 返回阶段、回调调用阶段）。

**Object 参数说明**：

| 属性名  | 类型              | 默认值 必填 |      | 说明                                                        |
| ------- | ----------------- | ----------- | ---- | ----------------------------------------------------------- |
| [key]   | String            |             | 否   | 要拦截的API的名称                                           |
| [value] | Object / Function |             | 否   | 拦截之后的处理器(如果为function，则默认在returning阶段调用) |

**可拦截的所有方法：**参见API文档，API中所有swan调用的均可以拦截

```js
swan.after({

    // 默认在returning阶段进行拦截
    request: function (context) {
        console.log('do something after request returning');
    },

    // 可以拦截success返回，fail返回，与returning
    request: {

        success(context) {
            console.log('do something after request success callback');
        },

        fail(context) {
            console.log('do something after request fail callback');
        },

        returning(context) {
            console.log('do something after request returning');
        }
    }
});
```

# 运行时原理

## 小程序的运行环境

智能小程序运行在三端：iOS、Android 和 用于调试的开发者工具。

三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：

### iOS

旧版本，小程序的逻辑层、视图层，均运行在 webview 中，并进行渲染。

新版本，小程序的逻辑层的 js 代码运行在 jscore 中，视图层在 webview 中渲染。

### Android

旧版本，小程序的逻辑层、视图层，均运行在 webview 中，并进行渲染。

新版本，小程序的逻辑层的 js 代码运行在 V8 中，视图层基于自研的 T7 内核在 webview 渲染。

### 开发工具

小程序逻辑层的 javascript 代码是运行在 electron 中，视图层是由 Chromium 59.0.3071.115 Webview 来渲染的。

### 平台差异

尽管三端的环境是十分相似的，但是还是有些许区别，例如 ES6、CSS 的差异，还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现。

开发者工具仅供调试使用，最终的表现以客户端为准。

### ES6 支持情况

智能小程序基础库内置了 polyfill 的解决方案，已经支持了绝大部分的 ES6 API。具体如下：

https://smartprogram.baidu.com/docs/develop/framework/operating-environment/

其他不在列表中说明的新特性，例如 await async等，目前暂不支持。

## 运行机制

### 启动方式

智能小程序的启动方式分为两种:

- 首次加载智能小程序的冷启动；
- 一定时间内重新打开智能小程序的热启动。

**名词解释:**

- **冷启动:** 通常是用户首次打开智能小程序，或者在手机百度客户端主动销毁了智能小程序之后，用户又重新打开了智能小程序，在这两种情况下，智能小程序都会初始化启动。
- **热启动:** 用户已经访问过该智能小程序，短暂退出后，又重新回到智能小程序。这时手机百度不会销毁该智能小程序，而只是控制智能小程序的显隐。

### 销毁机制

客户端主动触发智能小程序销毁的场景：

- 当用户退出智能小程序超过5分钟后；
- 打开小程序数量超过系统支持上限6个(系统按照小程序被打开的先后顺序进行销毁)。

### 更新机制

当智能小程序冷启动时，客户端会使用本地已有的基础包加载智能小程序，同时会自动检测云端是否有新的基础包版本，并异步下载。下载完成后，当用户下一次触发冷启动时，将使用新版本的基础包。

### 再次打开逻辑

客户端单纯控制使智能小程序的前台展示，再次打开时会保留之前智能小程序的页面栈等所有内容。

## 页面生命周期

### 原理图

以下内容详细的描述了一个页面被渲染的全过程。

![图片](Swan/framework-01.png)

1. FCP: First Contentful Paint，即首次有内容的绘制；
2. FMP: First Meaningful Paint，即首次有意义的绘制；

下列加载时间线屏幕截图直观的介绍了`FCP`与`FMP`的含义：

![图片](Swan/FMP.jpeg)

### 首页初次渲染全过程

**初始化**

渲染线程和`App`服务线程同步的进行初始化，在`App`服务线程初始化时收集`App`和`Page`的初始化数据，并且执行`App.onLaunch`回调中的相关逻辑。

此处我们以一个例子进行说明：

```js
// app.js
App({
    globalData: 'init data',
    onLaunch(options) {
        this.globalData = 'onLaunch data';
    }
});
```

```js
// /pages/index/index.js
Page({
    data: {
        title: 'Index',
        appData: getApp().globalData // onLaunch data
    }
})
```

初始化后`App`服务线程收集到的`initData`如下:

```js
{
    value: {
        title: 'Index',
        appData: 'onLaunch data'
    },
    otherMsg: ... // 其他信息
}
```

**notify**

当渲染线程初始化后，向`App`服务线程派发消息，请求获取初始化渲染数据。
同时，如果开发者有配置骨架屏，小程序会优先加载骨架屏，此时即为`FCP`完成。**如果骨架屏的高度撑满整个页面，那么我们认为此时为`FMP`完成，如果骨架屏信息不足以撑满整个屏幕，那么我们认为此次渲染非有效的`FMP`**。

**setInitData**

`APP`服务线程将初始化渲染数据派发给渲染线程，渲染进程拿到这些初始化数据后，会初始化页面及自定义组件，最后将所有内容渲染到页面上。

**firstRender**

渲染线程完成首次渲染后，此时已经可以获取整个页面的所有信息，渲染线程派发`firstRender`消息通知`APP`服务线程。`App`服务线程收到此消息后执行页面和自定义组件相关的生命周期。

整个生命周期执行顺序如下所示：

```js
// 初始化时同步执行
app onLaunch
// 收到 firstRender，并且客户端派发onShow事件
-> app onShow
-> cpnt created -> cpnt attached -> page onLoad
-> cpnt show    -> page onShow
-> cpnt ready   -> page onReady
```

> cpnt 指一个自定义组件。

**setData**

`APP`服务线程触发以上生命周期后，逻辑层一般执行了众多的`setData`，每次`setData`均会使得`App`服务线程向渲染线程传送数据，引起页面的重新渲染。

# 组件

## 自定义组件

### 定义

一个自定义组件由4个文件 (.swan .css .js .json) 组成, 例如包含自定义组件 `custom` 的项目结构：

```json
// 包含自定义组件custom的项目结构
├── app.js
├── app.json
├── project.swan.json
└── components
    └── custom
        ├── custom.swan
        ├── custom.css
        ├── custom.js
        └── custom.json
```

要编写一个自定义组件，首先需要在 json 文件中进行自定义组件声明（在 json 文件中将 component 字段设为 true 可将这一组文件设为自定义组件）：

```js
// 自定义组件配置 (custom.json)
{
    "component": true
}
```

在自定义组件的 js 文件中，需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法。

组件的属性值和内部数据将被用于组件 swan 模板的渲染，其中，属性是可以由组件外部传入的。

```js
// 自定义组件逻辑 (custom.js)
Component({
  properties: {
    // 定义了name属性，可以在使用组件时，由外部传入。此变量可以直接在组件模板中使用
    name: {
      type: String,
      value: 'swan',
    }
  },
  data: {
    // 这里是一些组件内部数据
    age: 1
  },
  methods: {
    // 这里是一个自定义方法
    tap: function(){}
  }
})
```

```html
<!-- 自定义组件内部的模板 (custom.swan) -->
<view class="name" bindtap="tap">
    {{name}}{{age}}
</view>
```

### 使用

使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。除了在页面使用自定义组件，你还可以在自定义组件引用自定义组件，类似于页面引用自定义组件。

以下举例页面级（pages/home/home）的使用场景:

```
// 项目目录结构
├── app.js
├── app.json
├── project.config.json
└──  pages
    └── home
        ├── home.swan
        ├── home.css
        ├── home.js
        └── home.json
└── components
    └── custom
        ├── custom.swan
        ├── custom.css
        ├── custom.js
        └── custom.json
```

首先需要提供每个自定义组件的标签名与其对应的自定义组件文件路径。

> 1.自定义组件文件路径: 自定义组件swan、css、js、json文件所在路径 + 该类文件的basename, 例如以上项目目录结构，该路径即是`/components/custom/custom`；
> 2.创建自定义组件，推荐内层的文件(swan、css、js、json)与其自定义组件目录保持同名。

**代码示例**

```json
// 页面json配置 home.json
{
    "usingComponents": {
        "custom": "/components/custom/custom"
    }
}
```

这样，在页面的 swan 文件中，就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

```html
<!-- 页面模板 (home.swan) -->
<view>
    <!-- 在页面中对自定义组件进行引用 -->
    <custom name="swanapp"></custom>
</view>
```

自定义组件的 swan 节点结构在与数据结合之后，将被插入到引用位置内。

**注意**：

- 自定义组件只能在`1.10.13`以上的 swan.js 中使用；
- 同一页面引用的自定义组件，不同路径的自定义组件暂时不能使用相同的自定义组件名字；
- 在页面级的配置（json文件）中不能添加 `"component": true`，因为将page当做自定义组件使用是不允许的；
- 对于自定义组件中的资源引用路径，使用相对路径目前针对的是自定义组件SWAN文件所对应的目录层级，故暂时推荐使用绝对路径。

## 组件模板

类似于页面（Page），自定义组件拥有自己的 swan 模板和 css 样式。

### 组件模板

组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。

### 模板数据绑定

与普通的 SWAN 模板类似，可以使用数据绑定，这样就可以向子组件的属性传递动态数据。

```html
<view>
    <custom-component prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
        <view>这里是插入到组件slot中的内容</view>
    </custom-component>
</view>
```

在以上例子中，组件的属性 propA 和 propB 将收到页面传递的数据。页面可以通过 setData 来改变绑定的数据字段。

### 组件的slot

在组件的视图模板中可以通过 slot 声明一个插槽的位置，其位置的内容可以由外层组件或者页面定义。

[在开发者工具中预览效果](swanide://fragment/2f9e341159539941e2c5ca6efe8022901578384723623)

```html
<!-- 组件内部模板 -->
<view class="wrapper">
    <view>组件内部节点</view>
    <slot></slot>
</view>
```

```html
<view>
    <custom-component>
        <view>这里是插入到组件slot中的内容</view>
    </custom-component>
</view>
```

#### slot命名

通过 name 属性可以给 slot 命名。一个视图模板的声明可以包含**一个默认 slot 和多个命名 slot**。外层组件或页面的元素通过 slot="name" 的属性声明，可以指定自身的插入点。

```html
<!-- 组件内部模板 -->
<view>
    <slot name="slot1"></slot>
    <slot name="slot2"></slot>
</view>
```

```html
<view>
    <custom-component>
        <view slot="slot1">我会被插入到组件上方</view>
        <view slot="slot2">我会被插入到组件下方</view>
    </custom-component>
</view>
```

#### slot指令应用

在 slot 声明时应用 if 或 for 指令，可以让插槽根据组件数据动态化。

```xml
<view>
    <slot s-if="!visible" name="subcomponent"></slot>
</view>
```

#### 数据环境

插入 slot 部分的内容，其数据环境为变量声明时的环境。

[在开发者工具中预览效果](swanide://fragment/cbbd50cbb74f64cfad4d5ada7b7fba041578384852492)

```html
<!-- custom-component自定义组件 -->
<view class="component-range">
    <slot name="inner"></slot>
</view>
```

```js
Component({
    data: {
        name: 'swan-inner'
    }
});
```

```html
<!-- 使用组件的页面或者组件 -->
<view>
    <custom-component>
        <view>{{name}}</view>
    </custom-component>
</view>
```

```js
Page({
    data: {
        name: 'swan-outer'
    }
});
```

渲染结果：

```HTML
<view>
    <view class="component-range">
        <view>swan-outer</view>
    </view>
</view>
```

#### scoped slot

如果 slot 声明中包含 s-bind 或 1 个以上 var- 数据前缀声明，该 slot 为 scoped slot。scoped slot 具有独立的 数据环境。 scoped slot 通常用于组件的视图部分期望由 外部传入视图结构，渲染过程使用组件内部数据。

[在开发者工具中预览效果](swanide://fragment/5e80a0cb75229f0fd1704255f47960ab1578384891595)

```html
<!-- custom-component自定义组件 -->
<view class="component-range">
    <slot var-name="name"></slot>
</view>
```

```js
Component({
    data: {
        name: 'swan-inner'
    }
});
```

```html
<!-- 使用组件的页面或者组件 -->
<view>
    <custom-component>
        <view>{{name}}</view>
    </custom-component>
</view>
```

```js
Page({
    data: {
        name: 'swan-outer'
    }
});
```

渲染结果：

```html
<view>
    <view class="component-range">
        <view>swan-inner</view>
    </view>
</view>
```

## 组件样式

组件的样式，可以在组件的 css 文件中编写，并且**只对当前组件内节点生效**。使用时，需要注意以下几点：

1. 只可以使用 class 选择器，其他的选择器，请改为 class 选择器实现；
2. 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用；
3. 继承样式，如 font 、 color，会从组件外继承到组件内。

```html
<!-- custom-component自定义组件 -->
<view class="wrapper wrapperTwo">
     <view>这里是组件的内部节点</view>
</view>
```

### 外部样式类

当组件希望接受外部传入的样式类（类似于 view 组件的 hover-class 属性）时，可以**在 Component 中用 externalClasses 定义段**定义若干个外部样式类。 > 小程序基础库版本 1.13.29 开始支持。

**注意**：在同一个节点上使用普通样式类和外部样式类时，请避免出现两个类的优先级是未定义的情况。

[在开发者工具中预览效果](swanide://fragment/43117d103194c692608133457f5e55a81578385052225)

```js
/* 组件 custom-component.js */
Component({
    externalClasses: ['external-class']
});
```

```html
<!-- 组件 custom-component.swan -->
<view class="external-class">这段文本的颜色由组件外的 class 决定</view>
```

组件的使用者可以像使用其他属性一样，指定这个样式类对应的 class 。

```html
<!-- 使用组件的页面或者组件 -->
<custom-component external-class="red-text" />
```

```css
.red-text {
    color: red;
}
```

### 全局样式类

使用外部样式类可以让组件使用指定的组件外样式类，如果希望组件外样式类能够完全影响组件内部，可以将组件构造器中的options.addGlobalClass字段置为true。 > 小程序基础库版本 1.13.29 开始支持。

[在开发者工具中预览效果](swanide://fragment/cd76518d74f16d684f3d7e38d437cf0b1578385088131)

```js
/* 组件 custom-component.js */
Component({
    options: {
        addGlobalClass: true,
    }
});
```

```html
<!-- 组件 custom-component.swan -->
<text class="global-class">这段文本的颜色由组件外的 class 决定</text>
```

```css
/* 组件外的样式定义 */
.global-class {
    color: red;
}
```

## Component构造器

### 定义段

Component构造器可用于定义组件，调用Component构造器时可以指定组件的属性、数据、方法等。

| 字段             | 类型           | 是否必填 | 描述                                                         | 最低版本                                                     |
| ---------------- | -------------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| properties       | Object Map     | 否       | 组件的对外属性，是属性名到属性设置的映射表，属性设置中可包含三个字段， type 表示属性类型、 value 表示属性初始值、 observer 表示属性值被更改时的响应函数 |                                                              |
| data             | Object         | 否       | 组件的内部数据，和 properties 一同用于组件的模板渲染         |                                                              |
| methods          | Object         | 否       | 组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见 [组件事件](https://smartprogram.baidu.com/docs/develop/framework/custom-component_cont/) |                                                              |
| behaviors        | Array.<string> | 否       | 类似于mixins和traits的组件间代码复用机制，参见 [behaviors](https://smartprogram.baidu.com/docs/develop/framework/custom-component_behaviors/) |                                                              |
| created          | Function       | 否       | 组件生命周期函数，在组件实例进入页面节点树时执行，注意此时不能调用setData，参见 [组件生命周期](https://smartprogram.baidu.com/docs/develop/framework/custom-component_lifetimes/) |                                                              |
| attached         | Function       | 否       | 组件生命周期函数，在组件实例进入页面节点树时执行，参见 [组件生命周期](https://smartprogram.baidu.com/docs/develop/framework/custom-component_lifetimes/) |                                                              |
| ready            | Function       | 否       | 组件生命周期函数，在组件布局完成后执行，此时可以获取节点信息，参见 [组件生命周期](https://smartprogram.baidu.com/docs/develop/framework/custom-component_lifetimes/) |                                                              |
| detached         | Function       | 否       | 组件生命周期函数，在组件实例被从页面节点树移除时执行，参见 [组件生命周期](https://smartprogram.baidu.com/docs/develop/framework/custom-component_lifetimes/) |                                                              |
| externalClasses  | Array.<string> | 否       | 组件接受的外部样式类，参见[组件模板和样式](https://smartprogram.baidu.com/docs/develop/framework/custom-component_temp/) | [1.13.27](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| options          | Object Map     | 否       | 一些选项（文档中介绍相关特性时会涉及具体的选项设置，这里暂不列举） | [1.13.27](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| lifetimes        | Object         | 否       | 组件生命周期声明对象，组件的生命周期：created、attached、ready、detached将收归到lifetimes字段内进行声明，原有声明方式仍旧有效，如同时存在两种声明方式，则lifetimes字段内声明方式优先级最高，参见 [组件生命周期](https://smartprogram.baidu.com/docs/develop/framework/custom-component_lifetimes/) | [1.13.27](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| pageLifetimes    | Object         | 否       | 组件所在页面的生命周期声明对象，目前仅支持页面的show和hide两个生命周期，参见 [组件生命周期](https://smartprogram.baidu.com/docs/develop/framework/custom-component_lifetimes/) | [1.13.27](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| definitionFilter | Function       | 否       | 定义段过滤器，用于自定义组件扩展，参见[自定义组件扩展](https://smartprogram.baidu.com/docs/develop/framework/custom-component_extend/) | [1.13.27](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |

### this

生成的组件实例可以在组件的方法、生命周期函数和属性 observer 中通过 this 访问。

### 属性和方法

组件包含一些通用属性和方法。

| 属性名     | 类型   | 描述                                               | 最低版本                                                     |
| ---------- | ------ | -------------------------------------------------- | ------------------------------------------------------------ |
| is         | String | 组件的文件路径                                     | [1.13.27](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| id         | String | 节点id                                             | [1.13.27](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| dataset    | String | 节点dataset                                        | [1.13.27](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| data       | Object | 组件数据，**包括内部数据和属性值**                 |                                                              |
| properties | Object | 组件数据，**包括内部数据和属性值**（与data一致）。 |                                                              |

| 方法名                     | 参数                       | 描述                                                         | 最低版本                                                     |
| -------------------------- | -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| setData                    | Object newData             | 设置data并执行视图层渲染                                     |                                                              |
| hasBehavior                | Object                     | 检查组件是否具有 behavior （检查时会递归检查被直接或间接引入的所有behavior） | [1.13.27](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| triggerEvent               | String name, Object detail | 触发事件，参见 [组件事件](https://smartprogram.baidu.com/docs/develop/framework/custom-component_cont/) |                                                              |
| createSelectorQuery        |                            | 创建一个 [SelectorQuery](https://smartprogram.baidu.com/docs/develop/api/show/query_SelectorQuery/) 对象，选择器选取范围为这个组件实例内, 与 swan.createSelectorQuery().in(this) 是等效 | [2.5.3](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| createIntersectionObserver | Object options             | 创建一个 [IntersectionObserver](https://smartprogram.baidu.com/docs/develop/api/show/query_IntersectionObserver/) 对象，选择器选取范围为这个组件实例内 | [2.5.3](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| selectComponent            | String selector            | 使用选择器选择组件实例节点，返回匹配到的第一个组件实例对象（会被 swan://component-export 影响），在生命周期 onReay 开始时生效 |                                                              |
| selectAllComponents        | String selector            | 使用选择器选择组件实例节点，返回匹配到的全部组件实例对象组成的数组 |                                                              |
| groupSetData               | Function callback          | 立刻执行 callback ，其中的多个 setData 之间不会触发界面进行重复绘制 | [2.10.7](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |

### 示例代码

```js
// 自定义组件js
Component({
    properties: {
        propName: { // 属性名
            type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）
            value: 'val', // 属性初始值（必填）
            observer: function(newVal, oldVal) {
                // 属性被改变时执行的函数（可选）
            }
        }
    },

    data: {}, // 私有数据，可用于模板渲染

    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
    attached: function () {},

    detached: function () {},

    methods: {
        onTap: function () {
            this.setData({
               // 更新属性和数据的方法与更新页面数据的方法类似
            });
        }
    }
});
```

**注意**：

+ 在 properties 定义段中，属性名应该采用驼峰写法（propsName）

+ 在 `swan` 模板中，指定属性值时则对应使用连字符写法

  > `component-tag-name props-name="props value"`

### 使用 Component 构造器构造页面

事实上，一个自定义组件也可以视为一个页面，故页面也可以使用 Component 构造器构造，拥有与普通组件一样的定义段与实例方法，其必要配置项（json）与正常自定义组件一致，即需要有`component: true`字段。

> **关于页面传参:**从其它页面跳转到由自定义组件构造的页面时，如跳转到页面 /components/custom/custom?paramA=123&paramB=xyz ，你可以在由custom组件构造的页面onLoad生命周期中获取传递的query字段。

**注意**：页面的生命周期方法（即 on 开头的方法），应写在 methods 定义段中。

```js
{
    "component": true,
    "usingComponents": {}
}
```

```js
/* /components/custom/custom.js */
Component({
    methods: {
        onLoad: function(options) {
            console.log(options.paramA); // 123
            console.log(options.paramB); // xyz
        }
    }
});
```

**优点**：使用 Component 构造器来构造页面的一个好处是可以使用 behaviors 来提取所有页面中公用的代码段。例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到 behaviors 中。

参考如下示例：[在开发者工具中预览效果](swanide://fragment/01345089b6cffb000ed1e9aeb9604f751581935236837)

```js
// behavior.js
module.exports = Behavior({
    attached: function() {
        // 页面创建时执行
        console.info('Page loaded!')
    },
    detached: function() {
        // 页面销毁时执行
        console.info('Page unloaded!')
    }
})
```

```js
// 自定义组件 A
var pageCommonBehavior = require('../behavior.js')
Component({
    behaviors: [pageCommonBehavior],
    data: { /* ... */ },
    methods: { /* ... */ },
})
```

```js
// 自定义组件 B
var pageCommonBehavior = require('../behavior.js')
Component({
    behaviors: [pageCommonBehavior],
    data: { /* ... */ },
    methods: { /* ... */ },
})
```

### **注意**

- 使用 this.data 可以获取内部数据和属性值，但不要直接修改它们，应使用 setData 修改；
- 属性名应避免以 data- 开头，因为在 SWAN 中，`data-name='swan'` 会被作为节点 dataset 来处理；
- 属性名应避免以 prop- 开头 在处理过程中会将该前缀删除；
- 属性名应避免包含 “ _ ” 字符, 因为在渲染过程中将会以 “ _ ” 字符进行拆分。

## js模块引用和导出

默认是使用Node的模块，AMD？

## 组件间通信与事件

### 组件间通信

组件间的基本通信方式有以下几种：

- 在父组件中可以通过设置子组件的properties来向子组件传递数据；
- 在父组件中定义messages对象，对子组件dispatch方法进行拦截，从而达到子组件向上通信；
- 子组件可以通过triggerEvent方法触发父组件的自定义事件进行传参；
- 如果以上几种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。

### 监听事件

事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。

监听自定义组件事件的方法与监听基础组件事件的方法完全一致：

```html
<!-- 父组件模板 -->
<component-tag-name bindmyevent="onMyEvent" />
```

### 通过dispatch方法与父组件通信

通过 dispatch 方法，子组件可以向组件树的上层派发消息。消息将沿着组件树向上传递，直到遇到第一个处理该消息的组件，则停止。
通过 messages 可以声明组件要处理的消息，messages 是一个对象，key 是消息名称，value 是消息处理的函数，接收一个包含 target(派发消息的组件) 和 value(消息的值) 的参数对象。

[在开发者工具中预览效果](swanide://fragment/683f5028c6e0e74036d14d46b25e80b81582160575148)

```js
/* 父组件逻辑 */
Component({
    messages: {
        'childmessage': function (e) {
            console.log('childmessage', e);
        }
    }
});
```

```js
/* 子组件逻辑 */
Component({
    created() {
        this.dispatch('childmessage', {
            name: 'swan'
        });
    }
});
```

### 通过triggerEvent方法与父组件通信

自定义组件触发事件时，需要使用 triggerEvent 方法，指定事件名和detail对象：

[在开发者工具中预览效果](swanide://fragment/c9e4f0cdb75fadf693ad2be32be4182d1578990218734)

```html
/* 组件child页面 */
<button bindtap="onTap">点击这个按钮将触发 myevent 事件</button>
```

```js
/* 组件child逻辑 */
Component({
    properties: {},
    methods: {
        onTap: function() {
            var myEventDetail = {} // detail对象，提供给事件监听函数
            var myEventOption = {bubbles:true} // 触发事件的选项
            this.triggerEvent('myevent', myEventDetail,myEventOption);
        }
    }
});
```

```html
/* 使用该组件的页面 */
<child bindmyevent="listener"></child>
```

```js
/* 使用该组件的逻辑 */
Page({
    listener: function (e) {
        console.log(e);
    }
})
```

触发事件的可配置选项包括：

| 属性名       | 类型    | 是否必填 | 默认值 | 描述                 |
| ------------ | ------- | -------- | ------ | -------------------- |
| bubbles      | Boolean | 否       | false  | 事件是否冒泡         |
| capturePhase | Bollean | 否       | false  | 事件是否拥有捕获阶段 |

关于自定义组件的冒泡和捕获阶段。

```html
<!-- 页面 index.swan -->
<parent bindcustomevent="pageEventListener1">
  <child bindcustomevent="pageEventListener2"></child>
</parent>
```

```html
<!-- 组件 parent.swan -->
<view bindcustomevent="anotherEventListener">
  <slot />
</view>
```

```html
 <!-- 组件 child.swan -->
<view bindcustomevent="myEventListener">
  <button bindtap="onTap">点我触发</button>
</view>
```

```js
// 组件 child.js
Component({
  methods: {
    onTap: function(){
      this.triggerEvent('customevent', {}) // 只会触发 pageEventListener2
    //   this.triggerEvent('customevent', {}, { bubbles: true }) // 会依次触发 pageEventListener2 、 pageEventListener1
    //   this.triggerEvent('customevent', {}, { bubbles: true, capturePhase: true }) // 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1
    }
  }
})
```

### **注意**

- 对于 triggerEvent 方法，在基础库版本 2.0.3 之前（不包含2.0.3）只支持传递类型为object的数据，从 2.0.3 开始支持传递其它数据类型（不包括function和undefined），其它低版本请做好[兼容](https://smartprogram.baidu.com/docs/develop/swan/compatibility/)。
- 对于很多UI组件库需要实现组件间关系，实际上组件间通信同样可以满足此需求。（之前组件间通信无法在存在 slot 环境使用，我们将于基础版本库 3.110.14 修复此问题）[详细内容](https://smartprogram.baidu.com/forum/topic/show/71953)
- 通过triggerEvent方式触发的自定义事件，只能在拥有父子关系的组件之间传播。
- 只能触发绑定在组件自身标签上的事件监听方法。

## 组件生命周期

自定义组件的生命周期，指的是组件自身的一些可自执行的方法，这些方法会在特殊的时间点或遇到一些特殊页面行为时被自动触发而执行。

**组件的生命周期**：created、 attached、 ready 、detached, 这些方法包含了一个组件实例生命流程的主要时间点，具体的使用场景如下:

- **created**：组件实例刚刚被创建好时， created 生命周期被触发，通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段；
- **attached**：在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行；
- **ready**：在attached生命被触发之后，组件的ready生命周期会被触发；
- **detached**：在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 方法会被触发。

### 定义生命周期方法

生命周期方法可以直接定义在 Component 构造器的第一级参数中。

除了以上声明方式，还可以在 lifetimes 字段内进行声明（推荐使用这种方式进行管理，其优先级最高）。

```js
// 自定义组件js文件
Component({
    // ...
    lifetimes: {
        attached: function() {
            // 在组件实例进入页面节点树时执行
        },
        detached: function() {
            // 在组件实例被从页面节点树移除时执行
        }
    }
    // ...
});
```

在内置 behaviors 中也可以编写生命周期方法，但不会与其他 behaviors 中的同名生命周期相互覆盖。

当前自定义自身可用的全部生命周期及其描述如下表所示：

| 生命周期 | 参数 | 描述                               | 最低版本                                                     |
| -------- | ---- | ---------------------------------- | ------------------------------------------------------------ |
| created  | 无   | 在组件实例刚刚被创建时执行         | [1.10.13](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| attached | 无   | 在组件实例进入页面节点树时执行     | [1.10.13](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| ready    | 无   | 在组件在视图层布局完成后执行       | [1.10.13](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| detached | 无   | 在组件实例被从页面节点树移除时执行 | [1.10.13](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |

### 组件所在页面的生命周期

还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。其中可用的生命周期包括：

| 生命周期 | 参数 | 描述                       | 最低版本                                                     |
| -------- | ---- | -------------------------- | ------------------------------------------------------------ |
| show     | 无   | 组件所在的页面被展示时执行 | [1.13.27](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| hide     | 无   | 组件所在的页面被隐藏时执行 | [1.13.27](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |

```js
// 自定义组件js文件
Component({
    // ...
    pageLifetimes: {
        show: function() {
        // 组件所在的页面被展示时触发
        },
        hide: function() {
        // 组件所在的页面被隐藏时触发
        }
    }
    // ...
});
```

## behaviors

### 定义和使用 behaviors

behaviors 用于组件间代码共享，类似于一些编程语言中的“mixins”或“traits”。

每个 behavior 可以包含一组属性、数据、生命周期函数和方法，组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。

每个组件可以引用多个 behavior 。 同时 该behavior 也可以引用其它 behavior 。

**behavior 需要使用 Behavior() 构造器定义。**

[在开发者工具中预览效果](swanide://fragment/6a6f5627360a8d320d1e8629e21174481578385334645)

```js
// my-behavior.js
module.exports = Behavior({
    behaviors: [],
    properties: {
        myBehaviorProperty: {
            type: String,
            value: 'behavior'
        }
  },
  data: {
      myBehaviorData: {}
  },
  attached: function(){},
  methods: {
      myBehaviorMethod: function(){}
  }
});
```

组件引用时，需在 behaviors 定义段中将它们逐个列出。

```js
// my-component.js
var myBehavior = require('my-behavior')
Component({
    behaviors: [myBehavior],
    properties: {
        myProperty: {
            type: String,
            value: 'component'
        }
  },
  data: {
      myData: {}
  },
  attached: function(){},
  methods: {
      myMethod: function(){}
  }
});
```

通过上面的例子可知：my-behavior 中包含有 myBehaviorProperty 属性、 myBehaviorData 数据字段、 myBehaviorMethod 方法和一个 attached 生命周期函数。

在 my-component 组件定义中引入了 my-behavior.js 。

这将使得 my-component 中最终包含 myBehaviorProperty 、 myProperty 两个属性， myBehaviorData 、 myData 两个数据字段，和 myBehaviorMethod 、 myMethod 两个方法。
当组件触发 attached 生命周期时，会依次触发 my-behavior.js 中的 attached 生命周期函数和 my-component.js 中的 attached 生命周期函数。

### 字段的覆盖和组合规则

组件和它引用的 behavior 中可以包含同名的字段，对这些字段的处理方法如下：

- 如果有同名的属性或方法，组件本身的属性或方法会覆盖 behavior 中的属性或方法；
- 如果引用了多个 behavior，在定义段中靠后 behavior 中的属性或方法会覆盖靠前的属性或方法；
- 如果有同名的数据字段，如果数据是对象类型，会进行对象合并，如果是非对象类型则会进行相互覆盖；
- 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用。如果同一个 behavior 被一个组件多次引用，它定义的生命周期函数只会被执行一次。

### 内置 behaviors

自定义组件可以通过引用内置的 behavior 来获得内置组件的一些行为。

[在开发者工具中预览效果](swanide://fragment/0768da895b5ac410eae2f1147ab6a1371578385388763)

```js
Component({
    behaviors: ['swan://form-field']
});
```

在上例中， swan://form-field 代表一个内置 behavior，它使得这个自定义组件有类似于表单控件的行为。

内置 behavior 往往会为组件添加一些属性。在没有特殊说明时，组件可以覆盖这些属性来改变它的 type 或添加 observer 。

### swan://form-field

使自定义组件有类似于表单控件的行为。
form 组件可以识别这些自定义组件，并在 submit 事件中返回组件的字段名及其对应字段值。这将为它添加以下两个属性：

| 属性名 | 类型   | 描述             | 最低版本                                                     |
| ------ | ------ | ---------------- | ------------------------------------------------------------ |
| name   | String | 在表单中的字段名 | [1.13.29](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |
| value  | 任意   | 在表单中的字段值 | [1.13.29](https://smartprogram.baidu.com/docs/develop/swan/compatibility/) |

### swan://component-export

> 从基础库版本 2.0.5 开始提供支持。

使自定义组件支持 export 定义段。这个定义段可以用于指定组件被 selectComponent 调用时的返回值。

未使用这个定义段时， selectComponent 将默认返回自定义组件的 this 。使用这个定义段时，将以这个定义段的函数返回值代替。

[在开发者工具中预览效果](swanide://fragment/3a98ebfe78e0fbb3f2c8015b3ec5beec1578385427348)

```js
// 自定义组件的js文件
Component({
    behaviors: ['swan://component-export'],
    export() {
        return { componentField: 'componentValue' }
    }
});
```

```html
<!-- 使用自定义组件时，对于自定义组件的引用模板 -->
<my-component id="custom-id" />
```

```js
this.selectComponent('#custom-id') // 等于 { componentField: 'componentValue' }
```

### 在页面中使用 behaviors

页面可以引用 behaviors 。 behaviors 可以用来让多个页面有相同的数据字段和方法。

```js
// my-behavior.js
module.exports = Behavior({
  data: {
    sharedText: 'data shared between pages.'
  },
  methods: {
    sharedMethod: function() {
      this.data.sharedText === 'data shared between pages.'
    }
  }
})
```

```js
// page-a.js
var myBehavior = require('./my-behavior.js')
Page({
  behaviors: [myBehavior],
  onLoad: function() {
    this.data.sharedText === 'data shared between pages.'
  }
})
```

## 数据监听器

> 数据监听器自小程序基础库版本 3.105.9 开始支持。

数据监听器可以用于监听和响应任何属性和数据字段的变化。

### 使用数据监听器

有时，需要组合监听一些数据字段。

例如，`this.data.sum`永远是 `this.data.numberA`与`this.data.numberB`的和。此时，可以使用数据监听器进行如下实现。

[在开发者工具中预览效果](swanide://fragment/d3f85183f54ec67cc54c1334b40beeca1577099991584)

```js
Component({
    properties: {
        numberA: {
            type: Number,
            value: 0
        },
        numberB: {
            type: Number,
            value: 0
        }
    },
    attached: function() {
        this.setData({
            numberA: 1,
            numberB: 2
        })
    },
    observers: {
        'numberA, numberB': function (numberA, numberB) {
            // 在 numberA 或者 numberB 被设置时，执行这个函数
            this.setData({
                sum: numberA + numberB
            })
        }
    }
});
```

### 监听字段语法

数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次`setData`最多触发每个监听器一次。

同时，监听器可以监听子数据字段，如下例所示。

```js
Component({
    observers: {
        'some.subfield': function(subfield) {
            // 使用 setData 设置 this.data.some.subfield 时触发
            // （除此以外，使用 setData 设置 this.data.some 也会触发）
            subfield === this.data.some.subfield
        },
        'arr[12]': function(arr12) {
            // 使用 setData 设置 this.data.arr[12] 时触发
            // （除此以外，使用 setData 设置 this.data.arr 也会触发）
            arr12 === this.data.arr[12]
        },
    }
});
```

如果需要监听所有子数据字段的变化，可以使用通配符`**`。

```js
Component({
    observers: {
        'some.field.**': function(field) {
            // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
            // （除此以外，使用 setData 设置 this.data.some 也会触发）
            field === this.data.some.field
        },
    },
    data: {
        some: {
            field: {
                subfield: [1, 2, 3]
            }
        }
    },
    attached: function() {
        // 会触发 observers
        this.setData({
            'some.field': {}
        });
        
        // 会触发 observers
        // this.setData({
        //     'some.field.xxx': {}
        // });

        // 会触发 observers
        // this.setData({
        //     'some': {}
        // });
    }
});
```

特别地，仅使用通配符`**`可以监听全部`setData`。

```js
Component({
    observers: {
        '**': function(value) {
            // 数据发生变化即触发，这里的 value 是 properties 和 data 的合集
        }
    }
})
```

### 注意

- 数据监听器监听的是`setData`中涉及的数据字段，并且只有这些字段发生改变时才会触发，类似`observer`;
- 在数据监听器中再次进行`setData`设置被监听的字段，可能会造成循环监听，请注意使用；
- 由于小程序对`setData`进行了优化操作，所以如果同步的多次设置`setData`那么实际上之后执行最后一次`setData`引起的`observers`。

```js
Component({
    properties: {
        numberA: {
            type: Number,
            value: 0
        },
        numberB: {
            type: Number,
            value: 0
        }
    },
    attached: function() {
        this.setData({
            numberA: 1,
            numberB: 2
        });
        this.setData({
            numberA: 2,
            numberB: 3
        })
    },
    observers: {
        'numberA, numberB': function (numberA, numberB) {
            // 在 numberA 或者 numberB 被设置时，执行这个函数
            this.setData({
                sum: numberA + numberB
            })
        }
    }
});
```

以上只会执行一次`observers`。

## 抽象节点

> 抽象节点自小程序基础库版本 3.90.18 、开发者工具正式版 2.9.1，beta版 2.9.0-beta 开始支持。

### 在组件中使用抽象节点

自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是由自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。

例如，我们现在来实现一个“选框组”（selectable-group）组件，它其中可以放置单选框（custom-radio）或者复选框（custom-checkbox）。这个组件的 swan 可以这样编写：

**定义**

```html
<!-- selectable-group.swan -->
<view s-for="{{labels}}">
    <label bindtap="itemTap" data-index="{{index}}">
        <selectable disabled="{{false}}" selected="{{selected[index]}}" name="{{name}}"></selectable>
        {{item}}
    </label>
</view>
```

其中，"selectable"不是任何在`json`文件的`usingComponents`字段中声明的组件，而是一个抽象节点。它需要在 `componentGenerics` 字段中声明：

```json
{
    "componentGenerics": {
        "selectable": true
    }
}
```

**使用**

在使用`selectable-group`组件时，必须指定"selectable"具体是哪个组件：

```html
<selectable-group generic:selectable="custom-radio" />
```

这样，在生成这个`selectable-group`组件的实例时，"selectable"节点会生成“custom-radio”组件实例。类似地，如果这样使用：

```html
<selectable-group generic:selectable="custom-checkbox" />
```

“selectable”节点则会生成“custom-checkbox”组件实例。

**注意**：上述的 `custom-radio` 和 `custom-checkbox` 需要包含在这个 `swan` 对应 `json` 文件的 `usingComponents` 定义段中。

```js
{
    "usingComponents": {
        "custom-radio": "path/to/custom/radio",
        "custom-checkbox": "path/to/custom/checkbox"
    }
}
```

### 抽象节点的默认组件

抽象节点可以指定一个默认组件，当具体组件未被指定时，将创建默认组件的实例。默认组件可以在 `componentGenerics` 字段中指定：

```json
{
    "componentGenerics": {
        "selectable": {
            "default": "path/to/default/component"
        }
    }
}
```

节点的`generic`引用`generic:xxx="yyy"`中，值`yyy`只能是静态值，不能包含数据绑定。因而抽象节点特性并不适用于动态决定节点名的场景。

## 自定义组件扩展 @@@

为了更好定制自定义组件的功能，可以使用自定义组件扩展机制。

> 从小程序基础库版本 2.0.5 开始支持。

为了更好的理解扩展后的效果，在此举例说明：[在开发者工具中预览效果](swanide://fragment/5262a060bf8642ac809a8b116ad35dae1574058224954)

```js
// behavior.js
module.exports = Behavior({
    definitionFilter(defFields) {
        defFields.data.from = 'behavior'
    }
})

// component.js
Component({
    data: {
        from: 'component'
    },
    behaviors: [require('./behavior.js')],
    ready() {
        console.log(this.data.from) // 此处会发现输出 behavior 而不是 component
    }
});
```

通过例子可以发现，自定义组件的扩展其实就是提供了修改自定义组件定义段的能力。

### 使用扩展

Behavior() 构造器提供了新的定义段 definitionFilter，用于支持自定义组件扩展。 definitionFilter 是一个函数，在被调用时会注入两个参数：

- 第一个参数是使用该 behavior 的 component/behavior 的定义对象；
- 第二个参数是该 behavior 所使用的 behavior 的 definitionFilter 函数列表。

[在开发者工具中预览效果](swanide://fragment/f345c27e9d5cead64e6ca47bc090e8fa1545996451082)

```js
// behavior3.js
module.exports = Behavior({
    definitionFilter(defFields, definitionFilterArr) {}
});

// behavior2.js
module.exports = Behavior({
    behaviors: [require('./behavior3.js')],
    definitionFilter(defFields, definitionFilterArr) {
        // definitionFilterArr[0](defFields)
    }
});

// behavior1.js
module.exports = Behavior({
    behaviors: [require('./behavior2.js')],
    definitionFilter(defFields, definitionFilterArr) {}
});

// component.js
Component({
    behaviors: [require('./behavior1.js')]
});
```

**说明**：

上述代码中声明了1个自定义组件和3个 behavior，每个 behavior 都使用了 definitionFilter 定义段。按照声明的顺序会有如下事情发生：

- 当进行 behavior2 的声明时就会调用 behavior3 的 definitionFilter 函数，其中 defFields 参数是 behavior2 的定义段， definitionFilterArr 参数即为空数组，因为 behavior3 没有使用其他的 behavior 。
- 当进行 behavior1 的声明时就会调用 behavior2 的 definitionFilter 函数，其中 defFields 参数是 behavior1 的定义段， definitionFilterArr 参数是一个长度为1的数组，`definitionFilterArr[0]` 即为 behavior3 的 definitionFilter 函数，因为 behavior2 使用了 behavior3。用户在此处可以自行决定在进行 behavior1 的声明时要不要调用 behavior3 的 definitionFilter 函数，如果需要调用，在此处补充代码 `definitionFilterArr[0](defFields)` 即可，definitionFilterArr 参数会由基础库补充传入。
- 同理，在进行 component 的声明时就会调用 behavior1 的 definitionFilter 函数。

简单概括，definitionFilter 函数可以理解为当 A 使用了 B 时，A 声明就会调用 B 的 definitionFilter 函数并传入 A 的定义对象让 B 去过滤。此时如果 B 还使用了 C 和 D，那么 B 可以自行决定要不要调用 C 和 D 的 definitionFilter 函数去过滤 A 的定义对象。

### 真实案例

下面利用扩展简单实现自定义组件的计算属性功能:

[在开发者工具中预览效果](swanide://fragment/bddd008a6896cad4e61e8ef266300b141582160313202)

```js
// behavior1.js
module.exports = Behavior({
  lifetimes: {
    created() {
      this._originalSetData = this.setData // 原始 setData
      this.setData = this._setData // 封装后的 setData
    }
  },
  definitionFilter(defFields) {
    const computed = defFields.computed || {}
    const computedKeys = Object.keys(computed)
    const computedCache = {}

    // 计算 computed
    const calcComputed = (scope, insertToData) => {
      const needUpdate = {}
      const data = defFields.data = defFields.data || {}

      for (let key of computedKeys) {
        const value = computed[key].call(scope) // 计算新值
        if (computedCache[key] !== value) needUpdate[key] = computedCache[key] = value
        if (insertToData) data[key] = needUpdate[key] // 直接插入到 data 中，初始化时才需要的操作
      }

      return needUpdate
    }

    // 重写 setData 方法
    defFields.methods = defFields.methods || {}
    defFields.methods._setData = function (data, callback) {
      const originalSetData = this._originalSetData // 原始 setData
      originalSetData.call(this, data, callback) // 做 data 的 setData
      const needUpdate = calcComputed(this) // 计算 computed
      originalSetData.call(this, needUpdate) // 做 computed 的 setData
    }

    // 初始化 computed
    calcComputed(defFields, true) // 计算 computed
  }
})
```

```js
// 在组件js中
const beh = require('./behavior1.js')
Component({
  behaviors: [beh],
  data: {
    a: 0,
  },
  computed: {
    b() {
      return this.data.a + 100
    },
  },
  methods: {
    onTap() {
      this._originalSetData({
        a: ++this.data.a,
      })
    }
  }
})
```

```html
<!-- 在组件swan中 -->
<view>data: {{a}}</view>
<view>computed: {{b}}</view>
<button bindtap="onTap">click</button>
```

### 第三方自定义组件

https://smartprogram.baidu.com/docs/develop/framework/custom-component_trdparty/

# 模板语法

## 数据绑定

SWAN 模板中的动态数据，都从逻辑层 Page 中 data 对象来。

### 基础数据绑定

数据绑定和许多模板引擎一样，数据包裹在双大括号里面。

双向绑定的数据需包裹在`{= =}`中。

> 组件 [scroll-view](https://smartprogram.baidu.com/docs/develop/component/view_scroll-view/) 中，scroll-top 和 scroll-left的使用方法分别为：
>
> - `scroll-top="{= scrollTop =}"`
> - `scroll-left="{= scrollLeft =}"`

```html
<!-- data-demo.swan -->
<view>
    Hello My {{ name }}
</view>

<!-- 被渲染成: Hello My SWAN App -->
```

```js
// data-demo.js
Page({
    data: {
        name: 'SWAN App'
    }
});
```

### 属性绑定

```html
<!-- attr-demo.swan -->
<view class="c-{{className}}">属性绑定</view>
```

```js
// attr-demo.js
Page({
    data: {
        className: 'blue'
    }
});
```

### 控制属性

**注:** 控制属性不需要被双大括号包裹

```html
<!-- condition-demo.swan -->
<view s-if="flag">如果为flag为true，你看得到我。</view>
```

```js
// condition-demo.js
Page({
    data: {
        flag: true
    }
});
```

### 表达式

SWAN 模板 提供了丰富的表达式类型支持，让使用者在编写视图模板时更方便。

- 数据访问(普通变量、属性访问)
- 一元否定
- 二元运算
- 二元关系
- 三元条件
- 括号
- 字符串
- 数值
- 布尔

通过下面例子列举支持的表达式类型。

```html
<!-- operation-demo.swan -->

<!-- 普通变量 -->
<text>{{name}}</text>

<!-- 属性访问 -->
<text>{{person.name}}</text>
<text>{{persons[1]}}</text>

<!-- 一元否定 -->
<text>{{!isOK}}</text>
<text>{{!!isOK}}</text>

<!-- 二元运算 -->
<text>{{num1 + num2}}</text>
<text>{{num1 - num2}}</text>
<text>{{num1 * num2}}</text>
<text>{{num1 / num2}}</text>
<text>{{num1 + num2 * num3}}</text>

<!-- 二元关系 -->
<text>{{num1 > num2}}</text>
<text>{{num1 !== num2}}</text>

<!-- 三元条件 -->
<text>{{num1 > num2 ? num1 : num2}}</text>

<!-- 括号 -->
<text>{{a * (b + c)}}</text>

<!-- 数值 -->
<text>{{num1 + 200}}</text>

<!-- 字符串 + 三元条件 -->
<text>{{item ? ',' + item : ''}}</text>

<!-- 三元运算 -->
<checkbox checked="{{flag ? true : false}}"></checkbox>

<!-- 数组字面量 -->
<text>{{ ['john', 'tony', 'lbj'] }}</text>
```

对象字面量(对象字面量是三个大括号包裹)

**注意：**对象字面量支持了在模板里重组对象以及使用扩展运算符 ... 来展开对象。

```html
<!-- template-demo.swan-->
<template name="tag-card">
    <view>
        <text>标签: {{tag}}</text>
        <text>昵称: {{nickname}}</text>
    </view>
</template>

<template name="person-card">
    <view>
        <text>位置: {{pos}}</text>
        <text>姓名: {{name}}</text>
    </view>
</template>

<template name="team-card">
    <view s-for="item, index in teams">
        <text>球队: {{index}} - {{item}}</text>
    </view>
</template>

<template name="age-card">
    <view>
        <text>年龄: {{age}}</text>
    </view>
</template>

<template is="person-card" data="{{person}}" />
<!-- 对象字面量 -->
```

```js
// template-demo.js
Page({
    data: {
        person: {name: 'Lebron James', pos: 'SF', age: 33},
        teams: ['Cleveland Cavaliers', 'Miami Heat', 'Los Angeles Lakers'],
        tag: 'basketball'
    }
});
```

> Swan有没有属性整体绑定？没有，这种绑定仅适用于template 的 data

## template标签模板

SWAN 提供模板 template 的用法，旨在提高工程化和代码可维护性，可以在模板中定义代码片段，并被外界注入值，然后在合适的时机调用。

### 定义模板

name 属性，定义了模板的名字。`内定义代码片段，如：

```html
<!-- template-demo.swan-->
<template name="person-card">
    <view>
        <text>位置: {{pos}}</text>
        <text>姓名: {{name}}</text>
    </view>
</template>
```

**注意**：模板之间不可嵌套

### 使用模板

通过 is 属性，声明需要使用的模板，data 是所需要传入到模板的值，注意对象字面量的使用方法，对象字面量是三个大括号包裹。

```html
<!-- template-demo.swan-->
<template is="person-card" data="{{{...person}}}" />
```

```js
// template-demo.js
Page({
    data: {
        person: {
            name: 'Lebron James',
            pos: 'SF', age: 33
        }
    }
});
```

is可以动态决定具体需要渲染哪个模板。

# 模板指令 $$$

## 条件

### s-if

**通过 s-if 指令我们可以实现以下操作：**

- 为元素指定条件:当条件成立时元素可见，当条件不成立时元素从当前页面中移除，而不是隐藏；
- 使用`s-elif/s-else-if`为 s-if 增加一个额外条件分支块；
- 使用`s-else`为 s-if 增加一个不满足条件的分支块。s-else 指令没有值；

```html
<!-- if-demo.swan-->
<view s-if="is4G">4G</view>
<view s-elif="isWifi">Wifi</view>
<view s-else>Other</view>
```

```js
// if-demo.js
Page({
    data: {
        is4G: true,
        isWifi: false
    }
});
```

### **注意**

+ s-if  s-elif 指令的值可以是任何类型的[表达式](https://baidu.github.io/san/tutorial/template/#表达式)，即使是表达式仍然是字符串包裹

  ```html
  <span s-if="isReady && isActive">Hello San!</span>
  
  <div s-if='test===123'>123</div>
  <div s-elif='test===456'>456</div>
  <div s-if='test===789'>789</div>
  ```

+ s-if 的条件判断不是严格的 === false。所以，一切 JavaScript 的假值都会认为条件不成立：0、空字符串、null、undefined、NaN等。

+ s-if 与 s-else 之间加入多余标签会报错，导致后面的元素无法匹配 if

+ **s-elif** 指令元素必须跟在 **s-if** 或 **s-elif** 指令元素后，否则将抛出 **elif not match if** 的异常。

+ **s-else** 指令元素必须跟在 **s-if** 或 **s-elif** 指令元素后，否则将抛出 **else not match if** 的异常。

+ s-if 与 s-for 不可在同一标签下同时使用。经过测试并没有发现报错的情况

  ```html
  <div s-if='test===123' s-for='item in arr'>123</div>
  ```

### block s-if

 block 虚拟组件，在渲染时不会包含自身，只会渲染其内容。可以用来渲染一组组件或者标签。

```html
<!-- if-demo.swan-->
<block s-if="flag">
    <view> name </view>
    <view> age </view>
</block>
```

> 在San中是template元素，在SWan中 template好像也不会渲染？？

## 循环

### s-for

通过循环渲染列表是常见的场景，在元素上作用 s-for 指令，我们可以渲染一个列表。

**s-for** 指令的语法形式如下：

```
item-identifier[, index-identifier] in expression[ trackBy accessor-expression]
```

#### **默认情况**

默认不写情况下，下标索引是为 index，数组当前变量名默认为 item。

```html
<!-- for-demo.swan-->
<view>
    <view s-for="persons">
        {{index}}: {{item.name}}
    </view>
</view>
```

```js
// for-demo.js
Page({
    data: {
        persons: [
            {name: 'Curry'},
            {name: 'Thompson'},
            {name: 'Durant'},
            {name: 'Green'},
            {name: 'Cousins'}
        ]
    }
})
```

#### **简写**

通过简写的方式，指定下标索引和数组当前变量名。

```html
<!-- for-demo.swan-->
<view>
    <view s-for="p,index in persons">
        {{index}}: {{p.name}}
    </view>
</view>
```

#### **指令语法**

也可以通过使用 s-for-index 来指定下标索引，s-for-item 来指定数组当前变量名。

```html
<!-- for-demo.swan-->
<view>
    <view s-for="persons" s-for-index="idx" s-for-item="p">
        {{idx}}: {{p.name}}
    </view>
</view>
```

> San 并没有指令语法

### owner组件数据

在列表渲染的元素内部，可以正常访问到 owner 组件上的其他数据（下面例子中的dept）

```html
<!-- Template -->
<dl>
  <dt>name - email</dt>
  <dd s-for="p in persons" title="{{p.name}}">{{p.name}}({{dept}}) - {{p.email}}</dd>
</dl>
```

### trackBy

**其实就是key**

如果列表中的项目会动态地增加、删除，并且希望列表中的项目保持自己的特征和状态（例如 input 中的输入内容），需要在 s-for 指令声明中指定 trackBy。

trackBy 后跟的值可以是 s-for 的 array 中 item 本身或者其属性（如 item.id），该值需要是列表中唯一的字符串或数字，且不能动态改变。

当数据更新触发重新渲染时，将自动跟踪项的变更，原先列表内的项位置会移动，新添加的项会被渲染，以确保组件保持自身的状态，并且省去一部分重新渲染带来的消耗。

[在开发者工具中预览效果](swanide://fragment/014b4d7f802a3fdadbbf35fe7195cab31568198084119)

```html
<input s-for="list trackBy item" placeholder="请输入内容" />
<button bindtap="delete">删除首项</button>
```

```js
Page({
    data: {
        list: [1, 2, 3, 4]
    },
    delete() {
        const list = this.data.list
        console.log('当前删除项目 id', list.splice(0, 1)[0])
        this.setData({list})
    }
})
```

**注意：**当循环渲染自定义组件列表时，不指定 trackBy 而动态增删数组中的元素，可能会导致调用错误的 attached detached 生命周期函数。

# 事件处理

事件提供了一种可以将用户的行为从视图层反馈到逻辑层进行处理的通讯方式。触发绑定在组件上的事件的时候，就会执行逻辑层中对应的事件处理函数，同时也可以传递数据，例如 id , dataset 等。

### 事件绑定

事件绑定在组件上，与属性的写法相同（以 key、value 的形式）：

- key 以 bind 或 catch 开头，衔接事件类型，例如 bindtap、catchtouchcancel。也可以在 bind 和 catch 后可以紧跟一个冒号，如 bind:tap、catch:touchstart，其功能不变。
- bind 与 catch 的区别是 bind 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡；
- value 对应的是在 Page 中定义同名的函数，否则在事件触发时执行函数会抛出异常。

**示例**

在组件中绑定一个事件处理函数 bindtap 。

```html
<view id="swanTap" data-say="hello" bindtap="tapHandle"> 点击 </view>
```

```js
Page({
    tapHandle(e) {
        swan.showToast(e.currentTarget.dataset.say);
    }
});
```

### 冒泡

与浏览器的 DOM 事件类似，智能小程序的视图中事件分为`冒泡事件`和`非冒泡事件`。

- 冒泡事件指的是当组件上的事件被触发后，该事件会向父节点传递；
- 非冒泡事件指的是当组件上的事件被触发后，该事件不会向父节点传递；
- 原生组件`video`、`live-player`、`canvas`、`cover-view`、`cover-image`等从[`基础库1.12.0`](https://smartprogram.baidu.com/docs/develop/swan/compatibility/)开始支持冒泡。

**冒泡事件如下表，不在列表的事件均为非冒泡事件。**

| 事件类型           | 触发时机                                                     |
| ------------------ | ------------------------------------------------------------ |
| tap                | 触摸后马上离开                                               |
| longtap            | 触摸后超过350ms再离开（推荐使用 longpress 事件代替）         |
| longpress          | 触摸后超过350ms再离开，如果是指定了事件回调函数并触发了这个事件，tap 事件将不被触发 |
| touchstart         | 触摸开始时                                                   |
| touchmove          | 触摸后移动时                                                 |
| touchcancel        | 触摸后被打断时，如来电等                                     |
| touchend           | 触摸结束时                                                   |
| touchforcechange   | 支持 3D Touch 的 iPhone 设备，重按时会触发。                 |
| transitionend      | 会在 transition 或 swan.createAnimation 动画结束后触发       |
| animationstart     | 会在 animation 动画开始时触发                                |
| animationiteration | 会在 animation 一次迭代结束时触发                            |
| animationend       | 会在 animation 动画完成时触发                                |

**示例**

```html
<view id="wrap" bindtap="handleTap1">
    wrap
    <view id="module" catchtap="handleTap2">
        module
        <view id="text" bindtap="handleTap3">
            text
        </view>
    </view>
</view>
```

用户单击 text 会先后调用 handleTap3 和 handleTap2。这是因为 tap 事件冒泡到了 module，而 module 阻止了 tap 事件冒泡，不再向父节点传递；

用户单击 module 会触发 handleTap2；

用户单击 wrap 会触发 handleTap1。

### 捕获

捕获阶段是位于冒泡阶段之前，在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。
在捕获阶段监听的方式是采用`capture-bind`、`capture-catch`关键字，后者将中断捕获阶段和取消冒泡阶段。

**示例：capture-bind**

```html
<view id="wrap" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2">
    wrap
    <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4">
        text
    </view>
</view>
```

用户单击 text 会先后调用 handleTap2、handleTap4、handleTap3、handleTap1。

**示例：capture-catch**

```html
<view id="wrap" bind:touchstart="handleTap1" capture-catch:touchstart="handleTap2">
    wrap
    <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4">
        text
    </view>
</view>
```

用户单击 text 只会调用 handleTap2。

### 事件对象

默认当组件触发事件时，逻辑层绑定事件的处理函数会收到一个默认参数，即事件对象。

下面是事件对象详细属性列表：

| 属性           | 类型    | 说明                                                         |
| -------------- | ------- | ------------------------------------------------------------ |
| type           | String  | 事件的类型                                                   |
| timeStamp      | Integer | 事件触发的时间戳（毫秒）                                     |
| target         | Object  | 触发事件的组件的属性值集合，详细属性参见 [target](https://smartprogram.baidu.com/docs/develop/framework/view_incident/#target) |
| currentTarget  | Object  | 当前组件的一些属性值集合，详细属性参见 [currentTarget](https://smartprogram.baidu.com/docs/develop/framework/view_incident/#currentTarget) |
| detail         | Object  | 自定义事件对象属性列表，详细属性参见 [detail](https://smartprogram.baidu.com/docs/develop/framework/view_incident/#detail) |
| touches        | Array   | 触摸事件类型存在，存放当前停留在屏幕中的触摸点信息的数组，touch 详细属性参见 [touch](https://smartprogram.baidu.com/docs/develop/framework/view_incident/#touch) |
| changedTouches | Array   | 触摸事件类型存在，存放当前变化的触摸点信息的数组, changedTouch [changedTouch](https://smartprogram.baidu.com/docs/develop/framework/view_incident/#changedTouch) |

这里需要注意的是target和currentTarget的区别,currentTarget为当前事件所绑定的组件，而target则是触发该事件的源头组件。

**target**

| 属性    | 类型   | 说明                                                         |
| ------- | ------ | ------------------------------------------------------------ |
| id      | String | 触发事件组件的 id                                            |
| tagName | String | 触发事件组件的类型                                           |
| dataset | Object | 触发事件组件上由data-开头的自定义属性组成的集合,详细属性参见 [dataset](https://smartprogram.baidu.com/docs/develop/framework/view_incident/#dataset) |

**currentTarget**

| 属性    | 类型   | 说明                                                         |
| ------- | ------ | ------------------------------------------------------------ |
| id      | String | 事件绑定的组件的 id                                          |
| tagName | String | 事件绑定的组件的类型                                         |
| dataset | Object | 事件绑定的组件上由data-开头的自定义属性组成的集合,详细属性参见 [dataset](https://smartprogram.baidu.com/docs/develop/framework/view_incident/#dataset) |

**detail**

是自定义事件所携带的数据，具体详见[组件](https://smartprogram.baidu.com/docs/develop/component/component/)定义中各个事件的定义。

**dataset**

在组件的事件被触发时，也可以传递自定义的数据。
书写方式： 以 data- 开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)，最终的 - 在 dataset 中会将连字符转成驼峰式写法。
如组件上`data-car-color`属性值的读取方式是: event.currentTarget.dataset.carColor。

**touch**

| 属性             | 类型   | 说明                                                       |
| ---------------- | ------ | ---------------------------------------------------------- |
| identifier       | Number | 触摸点的标识符                                             |
| clientX, clientY | Number | 距离页面可显示区域（屏幕除去导航条）左上角的X轴与Y轴的距离 |
| pageX, pageY     | Number | 距离文档左上角的X轴与Y轴的距离                             |

**changedTouch**

数据格式同 touches，指的是有变化的触摸点，如 touchstart（开始），touchmove（变化），touchend，touchcancel（结束）等。

点击事件的 detail 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离。

# 复用

## 模板复用

SWAN 可以通过`import`和`include`来引用模板文件。

### import

通过`import`和`template`配合使用，可以将代码分离以及复用。

[在开发者工具中预览效果](swanide://fragment/7877d4d677e59f56fc8986baadc1f0151560740060734)

首先，在`person-card.swan`中定义了一个叫`person-card`的`template`：

```html
<!-- person-card.swan-->
<template name="person-card">
    <view>
        <text>位置: {{pos}}</text>
        <text>姓名: {{name}}</text>
    </view>
</template>
```

然后，在`index.swan`里引用文件`person-card.swan`，并使用它的模板：

```html
<!-- index.swan-->
<import src="./person-card.swan" />
<template is="person-card" data="{{person}}" />
```

```js
// index.js
Page({
    data: {
        person: {
            pos: 'Baidu',
            name: 'SWAN'
        }
    }
});
```

**递归特性**

import 具有递归的特性。 例如：C 引用 B，B 引用A，在C中可以使用B定义的 template，在B中可以使用A定义的 template ，C也可以使用A定义的template

[在开发者工具中预览效果](swanide://fragment/4748d42321cc2f7b8fa61024e1053bff1577175849286)

```html
<!-- templateA.swan-->
<template name="A">
  <text> A template </text>
</template>
```

```html
<!-- templateB.swan-->
<import src="../templateA/templateA.swan"/>

<template name="B">
  <text> B template </text>
</template>

<template is="A"/>
```

```html
<!-- templateC.swan-->
<import src="../templateB/templateB.swan"/>

<template is="A"/>

<template is="B"/>
```

提升特性？

上例中，无论import位置在哪里，A template 总是在 B template之前

### include

通过`include`可以将目标模板整个**(除了 template)**引入到当前的位置，相当于`inline`。

[在开发者工具中预览效果](swanide://fragment/079d4ff72c324d30cce884f42f06d2e41560741170023)

```html
<!-- index.swan-->
<include src="header.swan" />
<view class="index">body</view>
```

```html
<!-- header.swan-->
<view class="header">header</view>
```

[在开发者工具中预览效果](swanide://fragment/c90964e07af04a2995b8bef2646795d61560741223711)

```html
<!-- index.swan -->
<include src="header.swan"/>
<view> body </view>
<include src="footer.swan"/>
```

```html
<!-- header.swan -->
<view> header </view>
```

```html
<!-- footer.swan -->
<view> footer </view>
```

# 样式

CSS 是描述 SWAN 的样式语言。支持 CSS 的属性。
在此基础上，做了一些编译支持：

- 尺寸单位
- 样式导入

### 尺寸单位

对于自适应的单位，推荐使用 CSS3 vw 为单位，vw 代表视窗( Viewport )的宽度为1%；

同时也支持 rpx，规定屏幕宽为750rpx。在 iPhone X 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。

### 样式导入

为了工程化和代码复用，我们支持 @import 语句，导入 CSS 文件。

```css
/* header.css */
.header {
    padding: 8px;
}
```

```js
/* index.css */
@import "header.css";
.body {
    padding: 12px;
}
```

### 适配样式

为了兼容iPhoneX底部安全区，我们提供了一组兼容样式：

```css
.swan-security-padding-bottom {
    padding-bottom: 34px;
}
.swan-security-margin-bottom {
    margin-bottom: 34px;
}
.swan-security-fixed-bottom {
    bottom: 34px;
}
```

**注意:** 该组样式会自动在需要适配安全区的场景动态注入，**开发者不需要自行添加**，只要在`.swan`文件中使用这组类名即可。

```html
<!--test.swan-->
<view class="swan-security-padding-bottom">test</view>
<!--在iPhoneX等机型下，该view节点会自动获得一个“padding-bottom:34px”的样式-->
```

基础库 3.140.17 开始我们将同时支持 safe-area-inset-* 的写法，建议使用以下css进行兼容

```css
padding-bottom: constant(safe-area-inset-bottom);
padding-bottom: env(safe-area-inset-bottom);
```

### 内联样式

内联样式与Web开发一致,且支持动态更新

```html
<view style="color: {{eleColor}}; font-size: {{eleFontsize}}"> swan </view>
```

```js
Page({
    data: {
        eleColor: 'red',
        eleFontsize: '48rpx'
    }
});
```

### 选择器权重

与css一致

### 注意

- 使用时请注意 box-sizing 属性为非默认值的场景；
- 百度APP 11.0 版本开始支持 iPhoneX，11.0.5 开始支持 iPhoneXS iPhoneXSMax iPhoneXR。

## 常见问题

https://smartprogram.baidu.com/docs/develop/framework/view_css/

# 与San的差异

$$$ 代表比对完成

### 属性绑定

Swan没有整体绑定，即是没有s-bind指令，单可以通过template name is data 实现相同效果

San有s-bind，template没有 name和is属性，也没有data

### 虚拟元素

swan block s-if  

> 在Swan中 template好像也不会渲染，因为swan调试工具之可以看到swan node，平常的dom node 都不会显示
>
> 通过`include`可以将目标模板整个**(除了 template)**引入到当前的位置，相当于`inline`。

san template s-if

### s-for

San 没有指令语法

### 事件处理

绑定的方式，冒泡捕获的关键字不同

