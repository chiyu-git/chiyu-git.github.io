---
layout: post
#标题配置
title:  H5核心 Note
#时间配置
date:   2019-3-15 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note front-end
---

* content
{:toc}


# 1. 细节

### 区别

- 需要变换的是画布里的图像，CSS3只能控制画笔，所以Canvas需要有自己的变换
- 类似的，画布里的图像是没有办法添加事件的，事件只能给到画布

## attribute&propety

### demo

```html
<input type="checkbox" checked="checked" qhf="qhf"/>
<input type="checkbox" checked="true" />
<input type="checkbox" checked="false" />
<input type="checkbox" checked="" />
<input type="checkbox" checked=null />
<input type="checkbox" checked=undefined />
<input type="checkbox" checked=0 />
<input type="checkbox" checked />
<input type="checkbox" checked="daudhauikdhiuawshd" />
<input type="checkbox"  />

```

- 结果:![1547454022556](F:\OneDrive\JS\纲略合集\assets\1547454022556.png) 
- 原因:![1547454032019](F:\OneDrive\JS\纲略合集\assets\1547454032019.png) 
- html有自己的渲染规则（浏览器决定），它既不是css也不是js，本身就是一套技术
- 只要写了`checked`无论如何都会被选中
- html预定义属性: checked
- html自定义属性:qhf

### attribute和property

- html标签的预定义和自定义属性我们统称为attribute
  - ![1547454734272](F:\OneDrive\JS\纲略合集\assets\1547454734272.png) 
  - attributes属性下，有着所有的预定义和自定义属性
- **js原生对象的直接属性**，我们统称为property

### 什么是布尔值属性，什么是非布尔值属性

- property的属性值为布尔类型的  我们统称为布尔值属性

- property的属性值为非布尔类型的  我们统称为非布尔值属性

### attribute和property的同步关系

- 非布尔值属性:实时同步

```js
//修改attribute
qhf.setAttribute("name","qhf1")
qhf.setAttribute("name","qhf2")
qhf.setAttribute("name","qhf3")
//修改property
qhf.name="qhf4";
qhf.name="qhf5";
qhf.name="qhf6";
```

- 布尔值属性:

  - 修改property，attribute不会同步，

  - 在没有动过property的情况下，修改attribute，property会同步

  - 在动过property的情况下 ，修改attribute，property不会同步

### 用户操作的是property

![1547456777771](F:\OneDrive\JS\纲略合集\assets\1547456777771.png)

- 点击打钩之后，只有property改变了

### 浏览器认的是property

![1547456711944](F:\OneDrive\JS\纲略合集\assets\1547456711944.png)

- 先设置一下property，确保修改attribute时，property不会同步，然后设置attribute，发现input的勾，没有打上，说明浏览器判断true or false ，跟的是property

### 结论

```js
$(function(){
	$("#CheckedAll").click(function(){
		$(":checkbox[name=items]").prop("checked", true);
		$("#checkedAll_2").prop("checked", true);
	});
});
```

- 布尔值属性，用prop
- 非布尔值属性，用prop
- 做出区别的是jQuery的attr() prop()，因为封装之后prop()返回的只有true和false，所以才会有成本区别，在原生JS中，别用setAttribute()即可，直接读取prop

## 新增API

### classList

- 方便对class做CRUD
  - textNode.classList.add("className")
  - textNode.classList.remove("className")
  - textNode.classList.toggle("className")
- 兼容性还行

### **HTMLElement.dataset**

- textNode.setAttibute.qhf
- **HTMLElement.dataset**
  - 驼峰的转换
  - 读写均可

```html
<div id="user" data-id="1234567890" data-user="johndoe" data-date-of-birth>John Doe
</div>

<script>
  var el = document.querySelector('#user');

  // el.id == 'user'
  // el.dataset.id === '1234567890'
  // el.dataset.user === 'johndoe'
  // el.dataset.dateOfBirth === ''

  el.dataset.dateOfBirth = '1960-10-03'; // set the DOB.

  // 'someDataAttr' in el.dataset === false

  el.dataset.someDataAttr = 'mydata';
  // 'someDataAttr' in el.dataset === true
</script>
```

### **contenteditable**

```html
<div id="test" contenteditable="true">
  djhaldhaskj
</div>
```

- 设置该属性之后，可以直接在页面，编辑div的标签体内容

- 该属性必须是下面的值之一:
  - `true` 或空字符串，表示元素是可编辑的；
  - `false` 表示元素不是可编辑的。
- 如果没有设置该属性，其默认值继承自父元素。
- 该属性是一个**枚举属性（enumerated one）**，而不是**布尔属性（Boolean one）**。这意味着必须显式设置其值为 `true`、`false` 或空字符串中的一个，并且不允许简写为 `<label contenteditable>Example Label</label> （注:这在大部分浏览器中是有效的）正确的用法是` `<label contenteditable="true">Example Label</label>`。

### querySelector()

- 借鉴jQuery
- 是一个快照属性，有坑，只能保持DOM元素的快照

# 2. H5

### Html5

- HTML5 是定义 HTML 标准的最新的版本。 该术语表示两个不同的概念:

  - 它是一个新版本的HTML语言，具有新的元素，属性和行为，

  - 它有更大的技术集，允许更多样化和强大的网站和应用程序。

  - 这个集合有时称为HTML5和朋友，通常缩写为HTML5。

  - HTML5     约等于     HTML + CSS + JS

​        

### Html5优势

- 跨平台:唯一一个通吃PC MAC Iphone Android等主流平台的跨平台语言

- 快速迭代

- 降低成本

- 导流入口多

- 分发效率高

## DOCTYPE和浏览器渲染模式

DOCTYPE，或者称为 Document Type Declaration（文档类型声明，缩写 DTD）

通常情况下，DOCTYPE 位于一个 HTML 文档的最前面的位置，位于根元素 HTML 的起始标签之前。

因为浏览器必须在解析 HTML 文档正文之前就确定当前文档的类型，以决定其需要采用的渲染模式，不同的渲染模式会影响到浏览器对于 CSS 代码甚至 JavaScript 脚本的解析

到目前为止，各浏览器主要包含了三种模式。在 HTML5 草案中，更加明确的规定了模式的定义:

| 传统名称                    | HTML5 草案名称      | document.compatMode 返回值 |
| --------------------------- | ------------------- | -------------------------- |
| standards mode(strict mode) | no-quirks mode      | CSS1Compat                 |
| almost standards mode       | limited-quirks mode | CSS1Compat                 |
| quirks mode                 | quirks mode         | BackCompat                 |


### document.compatMode

- document.compatMode 属性最初由微软在 IE 中创造出来，这是一个只读的属性，返回一个字符串，只可能存在两种返回值:

  - BackCompat:标准兼容模式未开启（怪异模式）

  -  CSS1Compat:标准兼容模式已开启（标准模式）



### 浏览器渲染

- 在现代主流浏览器中，其实怪异模式的渲染和标准与几乎标准间没有太大的差别（ie9+ 谷歌 火狐 ...）

  - ie5.5之前都是ie自己的渲染模式，怪异模式

  - ie6才开始慢慢支持标准，标准模式，在ie6 中怪异和标准模式的区别最大

  - ie7 8 9都是基于标准模式升级的，他们理论上存在怪异模式

- HTML5提供的<DOCTYPE html>是标准模式，向后兼容的,等同于开启了标准模式，

  - 那么浏览器就得老老实实的按照W3C的 标准解析渲染页面

  - 一个不含任何 DOCTYPE 的网页将会以 怪异(quirks) 模式渲染。
  - 在<DOCTYPE html>之前的标签和注释也可能会导致怪异模式

### 怪异盒模型

- 怪异模式下的盒模型就是后来的border-box

### DTD

- **`<!DOCTYPE html>`**
  - 当 doctype 信息如上时，表明该页面是遵守了 HTML5 规范的，浏览器会选择 Standards Mode，这种 doctype 是最推荐的一种，我们平时设计页面都应该加上这一个 doctype。

- HTML5 不基于 SGML,所以不需要引用 DTD,浏览器内部本身有对标签进行解析渲染验证的模块

- **`<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">`**
  - 当 doctype 如上时，浏览器同样会选择 Standards Mode，虽然和第一种 doctype 有一些区别，但是几乎可以认为是一样的。

- **`<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">`**
  - 当 doctype 如上时，浏览器会选择 Almost Standards Mode，渲染时和标准会有一些区别

- 当 doctype 缺失的时候，浏览器会选择 Quirks Mode，这是非常不推荐的方式，

- 当 doctype上面有注释，标签或者空行时，某些浏览器都会认为该页面不具有doctype。

- 我们应该尽量避免 Quirks Mode，这对一个 web 应用是非常不利的地方。

- 每种doctype在浏览器中对应的渲染模式

> https://en.wikipedia.org/wiki/Quirks_mode

## 根元素

#### H4中的根元素

- ` <html xmlns="http://www.w3.org/1999/xhtml">`

- 首先这个标记没有任何问题，你喜欢的话,那就背下来继续用。它是有效的。但这个标记中的很多字节在Html5中我们都可以省略了

- xmlns:这是XHTML1.0的东西，它的意思是在这个页面上的元素都位于http://www.w3.org/1999/xhtml这个命名空间内

- 但是HTML5中的每个元素都具有这个命名空间，不需要在页面上再显示指出 

### H5中的根元素

- ` <html></html>`

## head元素

### MIME类型:

- 每当浏览器请求一个页面时，web服务器会在发送实际页面内容之前，先发送一些头信息。

- 浏览器需要这些信息来决定如何解析随后的页面内容。最重要的是Content-Type

- 比如: **`Content-Type:text/html`**

- text/html:即这个页面的"内容类型",或者称为**MIME类型**。这个头信息将唯一确定某个资源的本质是什么也决定了它应该如何被呈现。

- 图片也有自己的MIME类型       

  - **jpg:image/jpeg**   

  - **png:image/png**

- js也有自己的MIME类型，css也有自己的MIME类型，

- 任何资源都有自己的MIME类型，整个web都依靠MIME类型来运作

- **`<meta charset="UTF-8">:`**

- 告诉浏览器你应该使用哪种编码来解析网页

### HTTP协议整合MIME类型

- ![1547468425704](F:\OneDrive\JS\纲略合集\assets\1547468425704.png) 
- ![1547468438453](F:\OneDrive\JS\纲略合集\assets\1547468438453.png) 
- ![1547468454926](F:\OneDrive\JS\纲略合集\assets\1547468454926.png) 

## 语义化标签

### 产生

- 在HTML 5出来之前，我们用div来表示页面头部，章节，页脚等。但是这些div都没有实际意义。

- 各大浏览器厂商分析了上百万的页面，从中发现了DIV名称的通用id名称大量重复。例如，很多开发人员喜欢使用

- div id="footer"来标记页脚内容，所以Html5元素引入了语义化标签（一组新的片段类元素）

  - https://dev.opera.com/blog/presentation-html5-and-accessibility-sitting-in-a-tree-4/idlist-url.htm

  - https://dev.opera.com/blog/presentation-html5-and-accessibility-sitting-in-a-tree-4/classlist-url.htm

```html
<hgroup></hgroup>
<header></header>
<nav></nav>
<section></section>
<footer></footer>
<article></article>
<aside></aside>
```

### 语义化的好处

1. HTML5可以让很多更语义化结构化的代码标签代替大量的无意义的div标签

2. 这种语义化的特性提升了网页的质量和语义

3. 对搜索引擎更加的友好

4. 他们这些标签功能就是代替<div>功能中的一部分，他们没有任何的默认样式，除了会让文本另起一行外；
   - https://gsnedders.html5.org/outliner/

### hgroup元素

- hgroup元素代表 网页 或 section 的标题，当元素有多个层级时，该元素可以将h1到h6元素放在其内，譬如文章的主标题和副标题的组合

```html

```

- hgroup使用注意:

1. 如果只需要一个h1-h6标签就不用hgroup

2. 如果有连续多个h1-h6标签就用hgroup

3. 如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签

### header元素

- header 元素代表 网页 或 section 的页眉。

- 通常包含h1-h6元素或hgroup

```html
<header>
  <hgroup>
    <h1>网站标题</h1>
    <h2>网站副标题</h2>
  </hgroup>
</header>
```

- header使用注意:

1. 可以是“网页”或任意“section”的头部部分

2. 没有个数限制。

3. 如果hgroup或h1-h6自己就能工作的很好，那就不要用header。

### nav元素

- nav元素代表页面的导航链接区域。用于定义页面的主要导航部分。

```html
<nav>
  <ul>
    <li>HTML 5</li>
    <li>CSS3</li>
    <li>JavaScript</li>
  </ul>
</nav>
```

- nav使用注意:用在整个页面主要导航部分上，不合适就不要用nav元素；

### section元素

section元素代表文档中的 节 或 段，段可以是指一篇文章里按照主题的分段；节可以是指一个页面里的分组。

```html
<section>
  <h1>section是啥？</h1>
  <article>
    <h2>关于section</h1>
    <p>section的介绍</p>
    <section>
      <h3>关于其他</h3>
      <p>关于其他section的介绍</p>
    </section>
  </article>
</section>
```

- section使用注意:

1. section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。

2. article、nav、aside可以理解为特殊的section，

3. 所以如果可以用article、nav、aside就不要用section，没实际意义的就用div     

### article元素

- article元素最容易跟section和div容易混淆，其实article代表一个在文档，页面或者网站中自成一体的内容

```html
<article>
  <h1>一篇文章</h1>
  <p>文章内容..</p>
  <footer>
    <p><small>版权:html5jscss网所属，作者:damu</small></p>
  </footer>
</article>
```

- article使用注意:

1. 独立文章:用article

2. 单独的模块:用section

3. 没有语义的:用div

### aside元素

- aside元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等

- 在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。

```html
<article>
  <p>内容</p>
  <aside>
    <h1>作者简介</h1>
    <p>小北，前端一枚</p>
  </aside>
</article>
```

- aside使用总结:

1. aside在article内表示主要内容的附属信息，

2. 在article之外则可做侧边栏

3. 如果是广告，其他日志链接或者其他分类导航也可以用

### footer元素

footer元素代表 网页 或 section 的页脚，通常含有该节的一些基本信息，譬如:作者，相关文档链接，版权资料。

```html
<footer>
COPYRIGHT@damu
</footer>
```

- footer使用注意:

1. 可以是 网页 或任意 section 的底部部分；
2. 没有个数限制，除了包裹的内容不一样，其他跟header类似。

## 其他新增标签

### 状态标签:meter

- 用来显示已知范围的标量值或者分数值。

1. value:当前的数值。

2. min:值域的最小边界值。如果设置了，它必须比最大值要小。如果没设置，默认为0

3. max:值域的上限边界值。如果设置了，它必须比最小值要大。如果没设置，默认为1

4. low:定义了低值区间的上限值,如果设置了，它必须比最小值属性大，并且不能超过high值和最大值。未设置或者比最小值还要小时，其值即为最小值。

5. high:定义了高值区间的下限值。如果设置了，它必须小于最大值，同时必须大于low值和最小值。如果没有设置，或者比最大值还大，其值即为最大值。

6. optimum:这个属性用来指示最优/最佳取值。

```html
<meter value="60" min="20" max="100"></meter>
<meter value="80" min="20" max="100" low="40" high="60"></meter>
<meter value="30" min="20" max="100" low="40" high="60" optimum="80"></meter>
```

- ![1548060303729](F:\OneDrive\JS\纲略合集\assets\1548060303729.png) 
- 最优值不是中间档的时候，会出现红色，绿色代表最优

### 状态标签:progress

- 用来显示一项任务的完成进度

1. max:该属性描述了这个progress元素所表示的任务一共需要完成多少工作.

2. value:该属性用来指定该进度条已完成的工作量.如果没有value属性,则该进度条的进度为"不确定",也就是说,进度条不会显示任何进度,你无法估计当前的工作会在何时完成

```html
<progress value="50" max="100"></progress>
<progress  max="100"></progress>
```

### 列表标签:datalist

- datalist会包含一组**option元素**，这些元素表示其表单控件的可选值，它的id必须要和**input中的list属性**一致

```html
<input type="text" placeholder="你最喜欢的女明星是？" list="zdy"></input>
<!--placehoder其实是h5新增的属性-->
<datalist id="zdy">
  <option value="1">10岁的周冬雨</option>
  <option value="2">20岁的周冬雨</option>
  <option value="3">30岁的周冬雨</option>
  <option value="4">40岁的周冬雨</option>
</datalist>
```

### 列表标签:details

- 一个ui小部件，用户可以从其中检索附加信息。

- open**属性**来控制附加信息的显示与隐藏

- summary**标签**:用作 一个<details>元素的一个内容摘要（标题）

```html
<details>
  <summary>尚硅谷男生张晓飞</summary>
  <p>一个神一样的男人</p>
  <p>一个神一样的男人</p>
  <p>一个神一样的男人</p>
</details>
```

-  ![1548061076971](F:\OneDrive\JS\纲略合集\assets\1548061076971.png) 

### 注释标签:ruby

- rt: ruby的子标签，展示文字注音或字符注释。

### 标记标签:mark

- mark:黄色高亮文字

## H5表单

### Html5 Forms概述

- 在Html5中:

1. 表单仍然使用<form>元素作为容器,我们可以在其中设置基本的提交特性，form的action指向一个服务器地址（接口）

2. 当用户或开发人员提交页面时,表单仍然用于向服务端发送表单中控件的值，注意表单项的**name属性**必须有值，服务器才能获取表单

3. 所有之前的表单控件都保持不变

4. 仍然可以使用脚本操作表单控件

5. Htnl5之前的表单:

- 标签为input

   - type:text

   - type:password

   - type:radio

     - 注意**以name分组**，确保单选关系，也为了后台能成功获取

     - 必须有value属性，为了后台获取后的识别（不写统一为on）

     - checked属性,选中控制

   - type:checkbox:复选框

     - 注意以name分组，确保为一组，也为了后台能成功获取

     - 必须有value属性，为了后台获取后的识别（不写统一为on）

     - checked属性,选中控制

   - type:submit:提交按钮

   - type:reset:重置按钮

   - type:button:普通按钮

- 标签为select:下拉框

  - name属性在select标签上

  - multiple:可选多项

  - 子项可以通过optgroup来进行分组

  - label属性用来定义组名

  - 子项为option标签
    - selected属性,选中控制

    - 必须有value属性,为了后台获取后的识别

- 标签为textarea:文本域

- 标签为button:按钮

  - type:submit:提交按钮

  - type:reset:重置按钮

  - type:button:普通按钮

- 标签为lable:控制文本与表单的关系
  - for属性指向一个input的id

- 标签fieldset 标签legend:来为表单分组  

6. attr & prop
7. h5新增

### 新增表单控件

1. type:email :email地址类型

   - 当格式不符合email格式时，提交是不会成功的，会出现提示；只有当格式相符时，提交才会通过

   - 在移动端获焦的时候会切换到英文键盘

2. type:tel :电话类型
   - 在移动端获焦的时候会切换到数字键盘
   - 没有正则验证

3. type:url :url类型
   - 当格式不符合url格式时，提交是不会成功的，会出现提示；只有当格式相符时，提交才会通过

4. type:search :搜索类型
   - 有清空文本的按钮

5. type:range  :  特定范围内的数值选择器
   - 属性:min、max、step

6. 其他
   - type:number:只能包含数字的输入框

   - type:color :  颜色选择器

   - type:datetime:  显示完整日期(移动端浏览器支持)

   - type:datetime-local :  显示完整日期，不含时区

   - type:time :  显示时间，不含时区

   - type:date :  显示日期

   - type:week :  显示周

   - type:month :  显示月

### 新增表单属性

- **placeholder**  :  输入框提示信息

  - 适用于form,以及type为text,search,url,tel,email,password类型的input

- **autofocus**  :  指定表单获取输入焦点

- **required**  :  此项必填，不能为空

- pattern : 正则验证，pattern="\d{1,5}"，不用转义

- formaction:在submit里定义提交地址

  - ```html
    <form action="http://www.baidu.com">
      <input type="submit"  value="提交" />
      <input type="submit"  value="提交" formaction="http://atguigu.com"/>
    </form>
    ```

- list和datalist:为输入框构造一个选择列表，list值为datalist标签的id

### 表单验证反馈

- validity对象，通过下面的valid可以查看验证是否通过，如果八种验证都通过返回true，一种验证失败返回false
  - node.addEventListener("invalid",fn1,false);
  - 表单验证失败时触发事件

```js
window.onload=function(){
  var inputEl = document.querySelector("input");
  inputEl.addEventListener("invalid",function(){
    console.log(this.validity)
  })
}
```

- ![1548063481942](F:\OneDrive\JS\纲略合集\assets\1548063481942.png) 

- valueMissing:输入值为空时返回true

- typeMismatch:控件值与预期类型不匹配返回true
  - 邮箱格式错误

**以下4个比较鸡肋**

- patternMismatch:输入值不满足pattern正则返回true

- tooLong:超过**maxLength属性**最大限制返回true
  - 设置了就不可能验证失败

- rangeUnderflow:验证的range最小值返回true

- rangeOverflow: 验证的range最大值返回true

- stepMismatch:验证range 的当前值 是否符合min、max及step的规则返回true

**自定义验证**

- customError:不符合自定义验证返回true

- **setCustomValidity()**

```js
window.onload=function(){
  var inputEl = document.querySelector("input");
  var submit = document.querySelectorAll("input")[1];
  submit.onclick=function(){
    var val = inputEl.value;
    if(val=="xfz"){
      submit.setCustomValidity("请不要输入敏感词")
    }else{
      //传入空串才能通过验证
      submit.setCustomValidity("")
    }
  }

  submit.addEventListener("invalid",function(){
    console.log(submit.validity)
  })
}
```



### 关闭验证

- formnovalidate属性

# 3. Canvas画布

## canvas细节

- 默认背景颜色和谁一样
- 宽高是canvas标签的属性，attribute，而不是style样式的一种
- html属性设置width height时只影响画布本身不影画布内容
- css属性设置width height时不但会影响画布本身的高宽，还会使画布中的内容等比例缩放（缩放参照于画布默认的尺寸）

```html
<canvas id="test" width="300" height="300" > <!--宽高是html属性-->
  <span>您的浏览器不支持画布元素 请您换成萌萌的谷歌</span>
</canvas>
```

- canvas没有单位，像素，弧度都不需要单位
- canvas本身也是一张图片，可以保存为png格式
- canvas图片操作，必须要等到图片加载之后
- canvas的像素点，默认是黑色透明（0，0，0，0）

## canvas基本用法

### 理解

- **`<canvas>`** 是 HTML5 新增的**元素**，可用于通过使用**JavaScript**中的脚本来绘制图形

- 可以用于绘制图形，创建动画。
- **`<canvas>`**最早由Apple引入WebKit

- 我们可以使用**`<canvas>`**标签来定义一个canvas元素

  - 使用<canvas>标签时，建议要成对出现，不要使用闭合的形式。

  - canvas元素默认具有高宽

  - width:  300px

  - height:150px

### 替换内容

- **`<canvas>`**很容易定义一些替代内容。由于某些较老的浏览器（尤其是IE9之前的IE浏览器）不支持HTML元素"canvas"，但在这些浏览器上你应该要给用户展示些替代内容。

- 这非常简单:我们只需要在**`<canvas>`**标签中提供替换内容就可以。

  - 支持**`<canvas>`**的浏览器将会忽略在容器中包含的内容，并且只是正常渲染canvas。

  - 不支持**`<canvas>`**的浏览器会显示代替内容

```html
<canvas>您的浏览器不支持canvas，请尽快升级</canvas>
```



### canvas标签的两个属性

- **`<canvas>`**看起来和**`<img> `**元素很相像，唯一的不同就是它并**没有 src 和 alt 属性**。

- 实际上，**`<canvas>`** 标签**只有两个属性**—— width和height，这些都是可选的。
  - 当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。

- 画布的高宽

  - html属性设置width height时只影响画布本身不影画布内容

  - css属性设置width height时不但会影响画布本身的高宽，还会使画布中的内容等比例缩放（缩放参照于画布默认的尺寸），只设置其中一个，另一个也会等比例缩放
  - 实际使用的时候，不建议在css属性设置画布的宽高

### 渲染上下文（画笔）

- **`<canvas>`** 元素只是创造了一个固定大小的画布，要想在它上面去绘制内容，我们需要找到它的渲染上下文

- **`<canvas>`** 元素有一个叫做 **getContext()** 的方法，这个方法是用来获得渲染上下文和它的绘画功能。

- **getContext()**只有一个参数，**上下文的格式**

```js
//获取方式
var canvas = document.getElementById('box');
var ctx = canvas.getContext('2d');
//检查支持性
var canvas = document.getElementById('tutorial');
if (canvas.getContext){
var ctx = canvas.getContext('2d');
} 
```

## 绘制矩形路径

- HTML中的元素canvas只支持一种**原生**的图形绘制:矩形。所有其他的图形的绘制都至少需要生成一条**路径**

### 绘制矩形的方法

- canvas提供了三种方法绘制矩形:

1. 绘制一个填充的矩形（填充色默认为黑色）
   - `fillRect(x, y, width, height)`
   - 矩形路径+fill方法

2. 绘制一个矩形的边框（默认边框为:一像素实心黑色）
   - `strokeRect(x, y, width, height)`
   - 矩形路径+stroke方法


### **3. clearRect(x, y, width, height)**

3. 清除指定矩形区域，让清除部分**完全透明**。    
   - 本质:画了一个**底色填充**的矩形
   - `clearRect(x, y, width, height)`

- x与y指定了在canvas**画布上**所绘制的矩形的**左上角**（相对于**画布的左上角**）的坐标
- **不可以加单位px**

- width和height设置矩形的尺寸。（存在边框的话，**边框会在width上占据半个边框的宽度**，height同理，border-box）

### strokeRect时，边框像素渲染问题

- 按理渲染出的边框应该是1px的，

- canvas在渲染矩形边框时，边框宽度是平均分在偏移位置的两侧。

- context.strokeRect(10,10,50,50):边框会渲染在10.5 和 9.5之间,浏览器是不会让一个像素只用自己的一半的，相当于边框会渲染在9到11之间

- context.strokeRect(10.5,10.5,50,50):边框会渲染在10到11之间

```js
//拿到画布
var canvas = document.querySelector("#test");
if(canvas.getContext){
  var ctx = canvas.getContext("2d");
  //注意不加单位
  //填充的矩形
  ctx.fillRect(0,0,100,100) //2px边框
  //带边框的矩形  
  // 100	: 99.5 --- 100.5(99-101)
  // 100.5: 100  --- 101 
  ctx.strokeRect(100.5,100.5,100,100) //1px边框
  
  /*
  刚好留下1px的边框
  ctx.strokeRect(100,100,100,100)
  ctx.clearRect(100,100,100,100)
  */
}  
```

### 添加样式和颜色

- fillStyle() :设置图形的**填充**颜色。
  - 作用于fillRect方法的画笔
  - 作用于fill()

- strokeStyle() :设置图形**轮廓**的颜色。
  - 作用于strokeRect方法的画笔
  - 作用于描边路径
  - 默认情况下，线条和填充颜色都是黑色（CSS 颜色值 #000000）

- lineWidth() : 这个属性设置当前**绘线**的粗细。属性值必须为正数

  - 作用于strokeRect方法的画笔
  - 作用于描边路径
  - 描述线段宽度的数字。 0、 负数、 Infinity 和 NaN 会被忽略。
  - 默认值是1.0。
  - 同样会被均分到偏移边界的两边

### Canvas独特的渲染机制

- 因为JS性能远大于浏览器渲染的能力，所以在渲染之前，相关的渲染信息都被保存到内存里了，再渲染到页面
  - 异步渲染
- Canvas自己的渲染机制，同样性能极高，绘制的样式必须在绘制之前指定
  - 同步渲染
- 画图形之前画笔就沾好颜色、浓度了

```js
ctx.fillStyle="deeppink";
ctx.strokeStyle="pink";
ctx.lineWidth=25;
ctx.lineJoin="round";

ctx.strokeRect(100,100,100,100)
ctx.fillRect(0,0,100,100)

ctx.fillStyle="blue";
ctx.strokeStyle="blue";
ctx.lineWidth=1;
ctx.lineJoin="round";

//还是粉色系的
```

### lineWidth & 覆盖渲染

- 类似于ps的图层，所有的矩形都是一层层画上去的，后面的会覆盖前面的
- 所以clearRect必须指定在后面才有用

### lineJoin

- 只作用于strokeRect方法的画笔

- 设定线条与线条间接合处的样式（默认是 miter）

  - round : 圆角

  - bevel : 斜角

  - miter : 直角

## 绘制直线路径

- 图形的基本元素是**路径**。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。

### 步骤

1. 首先，你需要创建路径**起始点**。

2. 然后你使用画图命令去画出路径

3. 之后你把路径**封闭**。

4. 一旦路径生成，你就能通过描边或填充路径区域来渲染图形。

### **moveTo(x, y)**

- **抬起画笔**，将笔触移动到指定的坐标x以及y上
- **设置起点**（路径）

- 当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点

### lineTo(x, y)

- **不抬起画笔**，将笔触移动到指定的坐标x以及y上

- **绘制**一条从当前位置到指定x以及y位置的**路径**。
- **设置锚点**

### closePath()

- 闭合**路径**之后图形绘制命令又重新指向到**上下文**中。

- 闭合路径closePath(),不是必需的。这个方法会通过绘制一条从**当前点到开始点的直线**来闭合图形。

- 如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做

- 当你调用**fill()**函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。

- 但是调用**stroke()**时不会自动闭合

### stroke()

- 通过线条来绘制图形轮廓。
- 给**路径**填色

- 不会自动调用closePath()，所以不会有当前点到开始点的线条

```js
var ctx = canvas.getContext("2d");

ctx.strokeStyle="deeppink";
ctx.lineWidth=10;

ctx.moveTo(100,100);
ctx.lineTo(100,200);
ctx.lineTo(200,200);
// ctx.closePath();
ctx.stroke();
```

- ![1547519122564](F:\OneDrive\JS\纲略合集\assets\1547519122564.png) 

### fill()

- 通过填充路径的内容区域生成**实心的**图形。

- 自动调用closePath()

### **beginPath()**

- 新建一条路径，生成之后，图形绘制命令被指向到路径上准备生成路径。

- 生成路径的第一步叫做beginPath()。本质上，路径是由很多子路径构成，这些子路径都是在一个列表中，

- 所有的子路径（线、弧形、等等）构成图形。而每次这个方法调用之后，**列表清空**重置，然后我们就可以重新绘制新的图形。
- **moveTo,lineTo,**本质上画的都是**路径**，路径本身是没有颜色、粗细的，所以看不见，stroke是给路径填色，fill是给路径封闭的区域填色

```js
ctx.moveTo(100,100);
ctx.lineTo(100,200);
ctx.lineTo(200,200);
ctx.closePath();
ctx.fill();

//清空路径容器
ctx.beginPath();
ctx.moveTo(200,200);
ctx.lineTo(200,300);
ctx.lineTo(300,300);
ctx.closePath();
ctx.stroke(); //上一个三角形不会被描边
```

```js
ctx.strokeStyle="pink";
ctx.fillStyle="green"
ctx.lineWidth=4;

ctx.moveTo(100,100);
ctx.lineTo(50,200);
ctx.lineTo(150,80);
ctx.lineTo(150,100);

ctx.moveTo(200,200); //新的路径起点，同一个路径容器
// ctx.lineTo(200,200);
ctx.lineTo(200,300);
ctx.stroke();
```

<img src='.\assets\1547519876763.png'>

### rect(x, y, width, height)

- 绘制一个左上角坐标为（x,y），宽高为width以及height的**矩形路径**。

- 当该方法执行的时候，**moveTo()**方法自动设置坐标参数（0,0）。

- 也就是说，当前笔触自动重置会默认坐标

### lineCap

- lineCap 是 Canvas 2D API 指定如何绘制每一条线段末端的属性。

- 有3个可能的值，分别是:

1. butt  :线段末端以方形结束。 

2. round :线段末端以圆形结束，**增加了**半径为厚度一半的一个圆形区域

3. square:线段末端以方形结束，但是**增加了**一个宽度和线段相同，高度是线段厚度一半的矩形区域

- 默认值是 butt。

### **save**

- save() 是 Canvas 2D API 通过将当前状态放入**栈**中，保存 canvas 全部状态的方法

- 保存到栈中的绘制状态有下面部分组成:

1. 当前的变换矩阵。
   - Canvas的变换也是以矩阵的形式进行的

2. 当前的剪切区域。

3. 当前的虚线列表.

4. 以下属性当前的值: 

   - strokeStyle, 

   - fillStyle,  

   - lineWidth, 

   - lineCap, 

   - lineJoin...

### **restore**

- restore() 是 Canvas 2D API 通过在绘图状态栈中**弹出**顶端的状态，将 canvas 恢复到最近的保存状态的方法。 

- 如果没有保存状态，此方法不做任何改变。 

### 样式栈、样式容器（堆）、路径容器（堆）

- 每次调用样式api时,都会往样式容器里做登记
- save方法，把当前样式容器的状态压入到栈中
- restore把栈顶的状态弹出，覆盖当前样式容器的状态
- 路径容器与绘图状态无关，仅保存路径相关的信息，每次调用路径api时,都会往路径容器里做登记，调用beginPath时,清空整个路径容器

```js
/*canvas绘制模板*/
ctx.save();
//关于样式的设置
//save  restore成对出现
ctx.beginPath();
//关于路径
ctx.restore();
```

### **deomo:签名**

```js
window.onload=function(){
  var canvas =document.getElementById("test");
  if(canvas.getContext){
    var ctx = canvas.getContext("2d");
  }

  canvas.onmousedown=function(event){
    event = event || window.eventent;
    if(canvas.setCapture){
      canvas.setCapture();
    }
    ctx.beginPath();
    ctx.moveTo(event.clientX -canvas.offsetLeft,event.clientY -canvas.offsetTop);
    
    document.onmousemove=function(event){
      ctx.save();
      ctx.strokeStyle="pink";
      event = event || eventent;
      ctx.lineTo(event.clientX -canvas.offsetLeft,event.clientY -canvas.offsetTop);
      ctx.stroke();
      ctx.restore();
    }
    
    document.onmouseup=function(){
      document.onmousemove=document.onmouseup=null;
      if(document.releaseCapture){
        document.releaseCapture();
      }
    }
    return false;
  }
}
```

## 绘制曲线路径

### 角度与弧度的js表达式:

- **radians=(Math.PI/180)*degrees**

### arc(x, y, radius, startAngle, endAngle, anticlockwise)

- 画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，

- 按照anticlockwise给定的方向（默认为顺时针）来生成。

  - ture:逆时针

  - false:顺时针

- x,y为绘制圆弧所在圆上的圆心坐标
- radius为半径

- startAngle以及endAngle参数用弧度定义了开始以及结束的**弧度**。这些都是以x轴为基准

- 参数anticlockwise 为一个布尔值。为true时，是逆时针方向，否则顺时针方向。
- `ctx.arc(100,100,50,0,90*Math.PI/180,true);`

### arcTo(x1, y1, x2, y2, radius)

- 根据控制点和半径绘制圆弧路径，使用当前的描点(前一个moveTo或lineTo等函数的**止点**)。根据当前描点与给定的控制点1连接的直线，和控制点1与控制点2连接的直线，作为使用指定半径的圆的**切线**，画出两条切线之间的弧线路径。

```js
var ctx = canvas.getContext("2d");
ctx.beginPath();
ctx.moveTo(50,50);
ctx.lineTo(300,0);
ctx.lineTo(200,200);
ctx.stroke();

ctx.beginPath();
ctx.moveTo(50,50)
ctx.arcTo(300,0,200,200,50);
ctx.stroke();
```



- <img src='.\assets\1547526803526.png'> 

### 二次贝塞尔:quadraticCurveTo(cp1x, cp1y, x, y)

- 绘制二次贝塞尔曲线
- cp1x,cp1y为一个控制点
- x,y为结束点。

- 起始点为moveTo时指定的点

```js
var ctx = canvas.getContext("2d");
ctx.beginPath();
ctx.moveTo(50,50);
ctx.lineTo(300,0);
ctx.lineTo(200,200);
ctx.stroke();

ctx.beginPath();
ctx.moveTo(50,50)
ctx.quadraticCurveTo(300,0,200,200);
ctx.stroke();
```

- <img src='.\assets\1547527297658.png'> 

### 三次贝塞尔:bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)

- 绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。

- 起始点为moveTo时指定的点

```js
var ctx = canvas.getContext("2d");
ctx.beginPath();
ctx.moveTo(50,50);
ctx.lineTo(300,0);
ctx.lineTo(0,300);
ctx.lineTo(300,300);
ctx.stroke();


ctx.beginPath();
ctx.moveTo(50,50)
ctx.bezierCurveTo(300,0,0,300,300,300);
ctx.stroke();
```

- ![1547527356325](F:\OneDrive\JS\纲略合集\assets\1547527356325.png) 

## Canvas 变换

### 注意

- 需要变换的是**画布里的图像**，CSS3只能控制画布，所以Canvas需要有自己的变换
- 类似的，画布里的图像是没有办法添加事件的，事件只能给到画布
- 虽然是画笔上的API，但是，实际操作的是**画布，坐标轴**

### translate(x, y)

- 我们先介绍 translate 方法，它用来移动 canvas的**原点**到一个不同的位置。

- translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，

- 在canvas中translate是累加的

```js
var ctx = canvas.getContext("2d");
/*
ctx.translate(50,50);
ctx.translate(50,50);
*/
//因为累加，相当于
ctx.translate(100,100)
ctx.beginPath();
ctx.fillRect(0,0,100,100);
```

- ![1547528365743](F:\OneDrive\JS\纲略合集\assets\1547528365743.png) 
- 

### rotate(angle)

- 这个方法只接受一个参数:旋转的**弧度**(angle)，它是顺时针方向的，以弧度为单位的值。

- 旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法

- 在canvas中rotate是累加的

```js
var ctx = canvas.getContext("2d");
ctx.translate(50,50);
ctx.rotate(45*Math.PI/180)
/*
ctx.rotate(45*Math.PI/180)
ctx.translate(50,50)
交换顺序，表现不一样
*/

ctx.beginPath();
ctx.fillRect(100,100,100,100);
```

- ![1547530367971](F:\OneDrive\JS\纲略合集\assets\1547530367971.png) 
- 

### scale(x, y)

- scale 方法接受两个参数。x,y 分别是**横轴和纵轴**的缩放因子，它们都必须是正值。

- 值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。

- 缩放一般我们用它来增减图形在 canvas 中的**像素数目**，对形状，位图进行缩小或者放大
  - 这里的像素数目，其实是一个抽象概念，屏幕物理上的像素没有改变

- 在canvas中scale是累乘的
- 累加、累乘，都是同步性的表现

### demo 变换实例

```js
var ctx = canvas.getContext("2d");

/* ctx.save();
				ctx.translate(150,150);

				ctx.beginPath();

				ctx.fillRect(-50,-50,100,100);


				ctx.restore();
 				*/
setInterval(function(){
  flag++;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(150,150);
  ctx.rotate(flag*Math.PI/180);


  if(scale==100){
    flagScale=-1;
  }else if(scale==0){
    flagScale=1;
  }
  scale+=flagScale;
  ctx.scale(scale/50,scale/50);

  ctx.beginPath();
  ctx.fillRect(-50,-50,100,100);
  ctx.restore();
},10)
```

### demo 表盘

1. 初始化

   将圆心调整到画布的中间
   由于canvas中画圆与旋转所参照的坐标系于正常坐标系有出入，将整个画布逆时针旋转90度
   初始化一些样式数据

```js
ctx.lineWidth = 8;
ctx.strokeStyle = "black";
ctx.lineCap = "round";
```

2. 外层空心圆盘

3. 时针刻度

4. 分针刻度

5. 时针

6. 分针

7. 秒针

8. 中心实心圆盘

9. 秒针头
10. Date
11. 定时器，清除画布，clock()

- **save restore 与 同步累加性**

```js
/* 时针刻度*/
/* 
//画法一:
//save在内部，每次画刻度都是分开的，所以需要*I
for (let i = 0; i < 12; i++) {
	ctx.save()
	ctx.lineWidth=8
	// 每次坐标轴都旋转360/12=30度
	ctx.rotate(30*i*Math.PI/180)
	ctx.beginPath()
	ctx.moveTo(0, -75)
	ctx.lineTo(0,-55)
	ctx.stroke()
	ctx.restore()
} 
*/

//画法二:
//save在外，相当于内部执行了12次累加的旋转，不用*i，也可以画出刻度
ctx.save()
ctx.lineWidth=8
for (let i = 0; i < 12; i++) {
  // 每次坐标轴都旋转360/12=30度
  ctx.rotate(30*Math.PI/180)
  ctx.beginPath()
  ctx.moveTo(0, -75)
  ctx.lineTo(0,-55)
  ctx.stroke()
}
ctx.restore()
```

- **canvas动画，只能重绘整个画布**

```js
setInterval(() => {
  ctx.clearRect(-150, -150, 300, 300)
  clock ()
  // 画之前清除上一次的，不然等于没画
  // ctx.clearRect(-150, -150, 300, 300)
},1000)
```

## Canvas图片操作

### drawImage(image, x, y, width, height)

- 在canvas中插入图片(需要image对象)

1. 其中 image 是 image 或者 canvas 对象
   - canvas操作图片时，必须要等图片加载完才能操作
   - img.onload= () =>{}
2. x 和 y 是其在目标 canvas 里的起始坐标。
3. 这个方法多了2个参数:width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小

```js
var ctx = canvas.getContext("2d");

var img = new Image();
img.src="tg.png";
img.onload=function(){
  draw();
}

function draw(){
  ctx.drawImage(img,0,0,img.width,img.height)
}
```

### createPattern(image, repetition)

- 在canvas中设置背景(需要image对象)

1. image:图像源

2. epetition:

   - "repeat" 

   - "repeat-x" 

   - "repeat-y" 

   - "no-repeat" 

- 一般情况下，我们都会将createPattern返回的对象作为**fillstyle**的值

```js
var ctx = canvas.getContext("2d");

var img = new Image();
img.src="tg.png";
img.onload=function(){
  draw();
}

function draw(){
  var pattern = ctx.createPattern(img,"no-repeat")
  ctx.fillStyle=pattern;
  ctx.fillRect(0,0,300,300);
}
```

### createLinearGradient(x1, y1, x2, y2)

- canvas渐变（线性渐变）

- 表示渐变的起点 (x1,y1) 与终点 (x2,y2)

- `gradient.addColorStop(position, color)`

- gradient :createLinearGradient的返回值

- addColorStop 方法接受 2 个参数，

1. position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。
   - 例如，0.5 表示颜色会出现在正中间。
2. color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）

```js
var gradient =  ctx.createLinearGradient(0, 0, 200, 200);
gradient.addColorStop(0,"red");
gradient.addColorStop(0.5,"yellow");
gradient.addColorStop(0.7,"pink");
gradient.addColorStop(1,"green");
ctx.fillStyle=gradient;
ctx.fillRect(0,0,300,300);
```

### createRadialGradient(x1, y1, r1, x2, y2, r2)

- canvas渐变（径向渐变）  

1. 前三个参数则定义另一个以(x1,y1) 为原点，半径为 r1 的圆，

2. 后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。

```js
var gradient = ctx.createRadialGradient(150, 150, 50, 150, 150, 100)
gradient.addColorStop(0,"red");
gradient.addColorStop(0.5,"yellow");
gradient.addColorStop(0.7,"pink");
gradient.addColorStop(1,"green");
ctx.fillStyle=gradient;
ctx.fillRect(0,0,300,300);
}
```

### demo 飞鸟

## Canvas 文本操作

### fillText(text, x, y)

- 在指定的(x,y)位置填充指定的文本

### strokeText(text, x, y)

- 在指定的(x,y)位置绘制**文本边框**
- 一步空心文字

### font = value

- 当前我们用来绘制**文本的样式**. 这个字符串使用和 CSS font 属性相同的语法. 

- 默认的字体是 10px sans-serif。

- font属性在指定时，**必须**要有大小和字体 缺一不可
  - 字体可以随意指定，**无效字体会自动使用sans-serif**
  - canvas只支持趁线字体？

### textAlign = value

- **文本对齐**选项. 可选的值包括: left, right  center. 

  - left 文本左对齐。

  - right 文本右对齐

  - center 文本居中对齐

- 文本的对齐是基于你在fillText的时候所给的x的值，

- textAlign="center"时文本一半在x的左边，一半在x的右边
- left时，x在全部文字的最左边
- right，x在全部文字的最右边

### textBaseline = value

- 描述绘制文本时，当前**文本基线**的属性。

  - top 文本基线在文本块的顶部。

  - middle 文本基线在文本块的中间

  - bottom 文本基线在文本块的底部

### **measureText**

- measureText() 方法返回一个 TextMetrics 对象，包含关于文本尺寸的信息（例如文本的宽度）

```js
var ctx = canvas.getContext("2d");
ctx.fillStyle="green";
ctx.font="60px sans-serif";
ctx.fillText("邱海峰",50,50);
debugger
var obj = ctx.measureText("邱海峰");
```

### canvas文本水平垂直居中

```js
var oC =document.getElementById('c1');
var oGC = oC.getContext('2d');
oGC.font = '60px impact';
oGC.textBaseline = 'middle';  //middle bottom
var w = oGC.measureText('尚硅谷').width;
oGC.fillText('尚硅谷',(oC.width - w)/2 , (oC.height - 60)/2);
```

### shadowOffsetX = float

### shadowOffsetY = float

- shadowOffsetX 和 shadowOffsetY 用来设定**阴影(文本阴影&盒模型阴影)**在 X 和 Y 轴的延伸距离，

- 它们默认都为 0。

### shadowBlur = float

- shadowBlur 用于设定阴影的模糊程度，**其数值并不跟像素数量挂钩，也不受变换矩阵的影响**，默认为 0。

### shadowColor = color(必需项)

- shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。

## Canvas像素操作

- 到目前为止，我们尚未深入了解Canvas画布真实像素的原理，事实上，你可以直接通过**ImageData对象**操纵像素数据，直接读取或将数据数组写入该对象中

### getImageData(sx, sy, sw, sh)

- 获得一个包含画布场景**像素数据**的**ImageData对像**,它代表了画布区域的对象数据

1. sx:将要被提取的图像数据矩形区域的左上角 x 坐标。

2. sy:将要被提取的图像数据矩形区域的左上角 y 坐标。

3. sw:将要被提取的图像数据矩形区域的宽度。

4. sh:将要被提取的图像数据矩形区域的高度。

### ImageData对象

- ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性:

1. width:图片宽度，单位是像素

2. height:图片高度，单位是像素

3. data:**Uint8ClampedArray类型**的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）

   - R:0 --> 255(黑色到白色)

   - G:0 --> 255(黑色到白色)

   - B:0 --> 255(黑色到白色)

   - A:0 --> 255(透明到不透明)

### putImageData(myImageData, dx, dy)

- putImageData()方法去对场景进行**像素数据的写入**。

- dx和dy参数表示你希望在场景内左上角绘制的像素数据所得到的设备坐标

```js
//ctx.fillStyle="rgba(255, 192, 203,1)";	
var imageData = ctx.getImageData(0,0,100,100);
for(var i=0;i<imageData.data.length;i++){
imageData.data[4*i+3]=100;
}
ctx.putImageData(imageData,0,0)
```

### ctx.createImageData(width, height)

- 创建一个ImageData对象

1. width : ImageData 新对象的宽度。

2. height: ImageData 新对象的高度。

- 默认创建出来的是透明的
- 画布上像素点默认也是黑色透明

```js
var imageData = ctx.createImageData(100,100);
for(var i=0;i<imageData.data.length;i++){
imageData.data[4*i+3]=255;
}
ctx.putImageData(imageData,100,100)
```

### demo 操作单个像素（行与列）

### demo 马赛克

- 用for循环模拟网格

## 合成

### globalAlpha = value

- 全局透明度的设置

- 这个属性影响到 canvas 里所有图形的透明度，

- 有效的值范围是 0.0 （完全透明）到 1.0（完全不透明）

- 默认是 1.0

### globalCompositeOperation属性

- 定义合成:多个图形重合的时候，如何展现

- source:新的图像(源，属性定义之后的)

- destination:已经绘制过的图形(目标，属性定义之前的**，一开始(0,0,0,0)？**)

**可选值:**

1. source-over(默认值):源在上面,新的图像层级比较高

2. source-in  :只留下源与目标的重叠部分(源的那一部分)

3. source-out :只留下源超过目标的部分

4. source-atop:砍掉源溢出的部分

5. destination-over:目标在上面,旧的图像层级比较高

6. destination-in:只留下源与目标的重叠部分(目标的那一部分)

7. destination-out:只留下目标超过源的部分

8. destination-atop:砍掉目标溢出的部分

```js
ctx.fillStyle="pink";
ctx.fillRect(50,50,100,100);
ctx.globalCompositeOperation="destination-atop";
ctx.fillStyle="green";
ctx.fillRect(100,100,100,100);
```

### demo 刮刮卡

## Canvas others

### toDataURL

- 将画布导出为图像
- 注意是**canvas元素**接口上的方法
- 得到图片的base64编码url

### ctx.isPointInPath(x, y)

- 事件操作，判断在当前路径中是否包含检测点

1. x:检测点的X坐标

2. y:检测点的Y坐标

- 注意，此方法只作用于最新画出的canvas图像

```js
var ctx = canvas.getContext("2d");
ctx.beginPath();
ctx.arc(100,100,50,0,360*Math.PI/180);
ctx.fill();

ctx.beginPath(); //如果没有这个beginPath，则下面的fill()方法，会画两个圆，都是最新的，都可以触发
ctx.arc(200,200,50,0,360*Math.PI/180);
ctx.fill();

canvas.onclick=function(ev){
  ev = ev||event;
  var x = ev.clientX - canvas.offsetLeft;
  var y = ev.clientY - canvas.offsetTop;
  if(ctx.isPointInPath(x,y)){
    alert(123);
  }
}
```

- 有了beginPath()方法之后，想要让第一个圆，也可以满足isPointInPath()，需要使用到原型的知识

# 4. 音频&视频

- 大家都有在网页中浏览视频的经历，但在Html5之前，对视频乃至音频都还没有一个标准
- 因此在网页中看到的视频，都是通过第三插件的方式嵌入的，可能是QuickTime，也可能是RealPlayer 或者 Flash。浏览器很好的整合了这些插件，你完全意识不到它们的存在
  - 现在浏览器不在整合插件了，经过用户同意之后才能使用插件
- 在介绍Html5中的音视频标签前，我们需要了解一些概念

### 简单测试

```html
<video src="resource/video/test.mp4" controls="controls" width="500" height="500" ></video>
<audio src="resource/audio/test.mp3" controls></audio>
```

- 视频的默认宽高，由分辨率决定，由内容撑开，controls属性之后才能显示控件，视频可以正常播放

- 设定宽高属性，只能控制控件的宽高，无法直接控制视频的大小，视频会按照分辨率等比例压缩

- 音频标签，指定宽高属性，没有意义，因为没有内容撑开

### 浏览器间的差异

- chrome 本地音视频的进度条都不能拖拽，服务器上的可以拖拽，火狐的都可以拖拽
- chrome有下载按钮，火狐没有下载按钮
- 浏览器间控件的样式不一样


## 基础概念

### 容器

- 大多数人会认为视频文件就是 .avi .mp4,但事实上 avi和mp4仅仅是容器的格式，它只决定怎么将视频存储起来，而不关系存储的内容。有点类似于.zip

- 不管是音频文件或视频文件，实际上都只是一个容器文件。这点类似于压缩了一组文件的ZIP文件

- 视频文件（视频容器）包含了音频轨道、视频轨道和其他一些元数据。

- 视频播放的时候，**音频轨道**和**视频轨道**是绑定在一起的。

- **元数据**包含了视频的封面、标题、子标题、字幕等相关信息。

<table width="100%">
  <thead>
  	<tr>
    	<td rowspan=2>主流的视频文件格式(容器格式)</td>
      <td></td>
      <td rowspan=2>主流的音频文件格式</td>
      <td></td>
    </tr>
  </thead>
  <tr>
  	<td>MPEG-4:</td>
    <td>通常以.mp4为扩展名</td>
    <td>MPEG-3</td>
    <td>通常以.mp3为扩展名</td>
  </tr>
  <tr>
  	<td>Flash视频:</td>
    <td>通常以.flv为扩展名</td>
    <td>Acc音频</td>
    <td>通常以.acc为扩展名</td>
  </tr>
    <tr>
  	<td>Ogg::</td>
    <td>通常以.ogv为扩展名</td>
    <td>Ogg音频</td>
    <td>通常以.ogg为扩展名</td>
  </tr>
    <tr>
  	<td>WebM:</td>
    <td>通常以.webm为扩展名</td>
    <td>音频视频交错</td>
    <td>通常以.avi为扩展名</td>
  </tr>
</table>

###  编解码器

- 音频和视频编码/解码是一组算法，用来对一段特定音频或视频进行解码和编码，以便音频和视频能够播放。原始的媒体文件体积非常巨大，如果不对其进行编码，那么数据量是非常惊人的，在互联网上传播则要耗费无法忍受的时间；如果不对其进行解码，就无法将编码后的数据重组为原始的媒体数据

| 视频编解码器 | 音频编解码器 |
| ------------ | ------------ |
| H.264        | ACC          |
| VP8          | MPEG-3       |
| Ogg Theora   | Ogg Vorbis   |

- H.264: 别名 MPEG-4的第十部分,由MPEG研发并于2003年标准化它的目的支持一切设备，无论是低带宽低cpu，还是高带宽高cpu 或者是两者之间。要做到这一点，H.264标准被分成不同的几种配置。高配置使用了更多特性，这会导致在解码过程中更加消耗CPU，但视频文件本身会更小，视频效果也更好 

​    

| 苹果iphone手机   | H.264基本配置(BaseLine)                                    |
| ---------------- | ---------------------------------------------------------- |
| 正常的电视机支持 | H.264基本配置(BaseLine) 和 主配置(Main)两种                |
| 正常的电脑支持   | H.264基本配置(BaseLine) 和 主配置(Main) 高级配置(high)三种 |

- 当然有一些编解码器受专利的保护，有一些则是免费的，例如Ogg的Vorbis音频编解码器。

- Ogg的Theora视频编解码器也是可以免费使用的。而想使用H.264的话就需要支付相关的费用了

- 现在的视频编解码器会使用各种技巧减少从一帧到另一帧过程中传递的信息数量，它们不会存储每一帧的所有信息，而只是存储两帧之间的差异信息。

- 编码器也分有损和无损，无损视频文件一般太大，在网页中没有优势，所以我们重点研究有损编解码器。

- 有损编解码器中，信息在编码过程中丢失是无法避免的，反复的对视频编码会导致其画面不均匀。

### 浏览器对于容器和编解码器支持的情况

- 浏览器只能选择一款编解码器，选择的不同造成了差异

| Browser             | MP4(H.264 + AAC) | WebM(VP8 + Vorbis ) | Ogg(Theora + Vorbis) |
| ------------------- | ---------------- | ------------------- | -------------------- |
| Internet Explorer 9 | YES              | NO                  | NO                   |
| Firefox 4.0         | NO               | YES                 | YES                  |
| Google Chrome       | YES              | YES                 | YES                  |
| Apple Safari 5      | YES              | NO                  | NO                   |
| Opera 10.6          | NO               | YES                 | YES                  |
| ios                 | YES              |                     | YES                  |
| android             |                  |                     | YES                  |

>  http://www.html5videoplayer.net/html5video/html5-video-browser-compatibility/

- 目前还没有一种编解码和容器的组合能应用于所有的浏览器中！！！

### 处理视频的一个流程

1. 制作一个Ogg容器中使用Theora视频和Vorbis音频的版本

2. 制作另外一个版本，使用WebM视频容器（VP8 + Vorbis）

3. 再制作一个版本，使用MP4视频容器，并使用H.264基本配置的视频和ACC低配的音频

4. 链接上面3个文件到同一个video元素，并向后兼容基于Flash的视频播放器  

### 格式转化

- 用 FFmpeg 制作MP4 视频
  - ffmpeg -i test.mp4 -c:v libx264 -s 1280x720 -b:v 1500k -profile:v high -level 3.1 -c:a aac -ac 2 -b:a 160k -movflags faststart OUTPUT.mp4

- 用 FFmpeg 制作 WebM 视频
  - ffmpeg -i test.mp4 -c:v libvpx -s 1280x720 -b:v 1500k -c:a libvorbis -ac 2 -b:a 160k OUTPUT.webm

- FFmpeg 制作 Ogg 视频
  - ffmpeg -i test.mp4 -c:v libtheora -s 1280x720 -b:v 1500k -c:a libvorbis -ac 2 -b:a 160k OUTPUT.ogv

- FFmpeg 制作Mp3音频
  - ffmpeg -i test.mp3 -c:a libmp3lame -ac 2 -b:a 160k OUTPUT.mp3

- FFmpeg 制作Ogg音频
  - ffmpeg -i test.mp3 -c:a libvorbis -ac 2 -b:a 160k OUTPUT.ogg

- FFmpeg 制作ACC音频  
  - ffmpeg -i test.mp3 -c:a aac -ac 2 -b:a 160k OUTPUT.aac

## H5的音视频设计

### html5标签

```html
<video>:Html5提供的播放视频的标签
src:资源地址
controls:该属性定义是显示还是隐藏用户控制界面

<audio>:Html5提供的播放音频的标签
src:资源地址
controls:该属性定义是显示还是隐藏用户控制界面

<source>
视频编解码属性:
type='video/webm; codecs="vp8, vorbis"'
type='video/ogg; codecs="theora, vorbis"'
type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'

音频编解码属性:
type='audio/ogg; codecs="vorbis"'
type='audio/aac; codecs="aac"'
type='audio/mpeg'
```

### video标签的属性

- width :视频显示区域的宽度，单位是CSS像素

- height:视频展示区域的高度，单位是CSS像素

- poster :一个海报帧的URL，用于在用户播放或者跳帧之前展示

- src:要嵌到页面的视频的URL

- controls:显示或隐藏用户控制界面

- autoplay:媒体是否自动播放

- loop: 媒体是否循环播放

- muted:是否静音

- preload:该属性旨在告诉浏览器作者认为达到最佳的用户体验的方式是什么
  - none:提示作者认为用户不需要查看该视频，服务器也想要最小化访问流量；换句话说就是提示浏览器该视频不需要缓存。
  - metadata:提示尽管作者认为用户不需要查看该视频，不过抓取元数据（比如:长度）还是很合理的。
  - auto:用户需要这个视频优先加载；换句话说就是提示:如果需要的话，可以下载整个视频，即使用户并不一定会用它。
  - 空字符串:也就代指 auto 值。

### audio标签的属性 

- src     

- controls  

- autoplay  

- loop      

- muted     

- preload   

### 音视频js相关属性

- duration:媒体总时间(只读)

```js
var video = document.querySelector("video");
var audio = document.querySelector("audio");

console.log(video.duration); //Chrome:NaN，火狐做了优化，优先获取了信息
console.log(audio.duration); //Chrome:NaN

setTimeout(function(){
  console.log(video.duration); //Chrome:可以获取到
  console.log(audio.duration);
},500)

video.addEventListener("suspend",function(){
  console.log(video.duration); //几百个NaN，最后返回数据，说明调用了几百次
})

video.addEventListener("loadeddata",function(){
  console.log(video.duration); //直接返回数据，调用了一次
})
```

- **currentTime** :开始播放到现在所用的时间(可读写)
  - 不用加载完毕，直接显示0
  - 通过该属性实现跳跃播放
  - 以秒为单位，超过 duration 则无效
- muted:是否静音(可读写,相比于volume优先级要高)
  - 读写一个布尔值

- volume:0.0-1.0的音量相对值(可读写)

```JS
//muted和volume之间不会同步
//muted的优先级比较高
video.muted=true;
audio.muted=true;
video.volume=0; //如果不设置的话，volume返回1，也就是没有静音的值
audio.volume=0;
console.log(video.muted)
console.log(audio.muted)
console.log(video.volume)
console.log(audio.volume)
```



- paused: 媒体是否暂停**(只读)**
  - 注意属性时pause**d**，而方法是pause()，因为方法一直存在，如果写错了永远只能进入一个判断
- ended:媒体是否播放完毕**(只读)**
- error:媒体发生错误的时候，返回错误代码 **(只读)**
- currentSrc: 以字符串的形式返回媒体地址**(只读)**
- 视频多的部分:

  - poster:视频播放前的预览图片的**地址(读写)**

  - width、height  :设置视频的尺寸**(读写)**，与attribute对应

  - videoWidth、 videoHeight:视频的实际尺寸(只读)

### 音视频js相关方法

- play():媒体播放

- pause():媒体暂停

```js
video.pause();
audio.pause();
```

- load():重新加载媒体

```js
var video = document.querySelector("video");
var audio = document.querySelector("audio");

var source = document.querySelectorAll("source");
/*video.src="xxx";
audio.src="xxx";*/
source[0].src="xxx";
source[1].src="xxx";
//修改src值，需要load一遍，才能生效
video.load();
audio.load();
```

### js视频相关事件

abort:在播放被终止时触发,例如, 当播放中的视频重新开始播放时会触发这个事件。

canplay:在媒体数据已经有足够的数据（至少播放数帧）可供播放时触发。这个事件对应CAN_PLAY的readyState。

canplaythrough:在媒体的readyState变为CAN_PLAY_THROUGH时触发，表明媒体可以在保持当前的下载速度的情况下不被中断地播放完毕。注意:手动设置currentTime会使得firefox触发一次canplaythrough事件，其他浏览器或许不会如此。

durationchange:元信息已载入或已改变，表明媒体的长度发生了改变。例如，在媒体已被加载足够的长度从而得知总长度时会触发这个事件。

emptied:媒体被清空（初始化）时触发。

ended:播放结束时触发。

error:在发生错误时触发。元素的error属性会包含更多信息。参阅Error handling获得详细信息。

loadeddata:媒体的第一帧已经加载完毕。

loadedmetadata:媒体的元数据已经加载完毕，现在所有的属性包含了它们应有的有效信息。

loadstart:在媒体开始加载时触发。

mozaudioavailable:当音频数据缓存并交给音频层处理时

pause:播放暂停时触发。

play:在媒体回放被暂停后再次开始时触发。即，在一次暂停事件后恢复媒体回放。

playing:在媒体开始播放时触发（不论是初次播放、在暂停后恢复、或是在结束后重新开始）。

progress:告知媒体相关部分的下载进度时周期性地触发。有关媒体当前已下载总计的信息可以在元素的buffered属性中获取到。

ratechange:在回放速率变化时触发。

seeked:在跳跃操作完成时触发。

seeking:在跳跃操作开始时触发。

stalled:在尝试获取媒体数据，但数据不可用时触发。

suspend:在媒体资源加载终止时触发，这可能是因为下载已完成或因为其他原因暂停。

timeupdate:元素的currentTime属性表示的时间已经改变。

volumechange:在音频音量改变时触发（既可以是volume属性改变，也可以是muted属性改变）.。

waiting:在一个待执行的操作（如回放）因等待另一个操作（如跳跃或下载）被延迟时触发

### js音频相关事件

abort:在播放被终止时触发,例如, 当播放中的视频重新开始播放时会触发这个事件。

canplay:在媒体数据已经有足够的数据（至少播放数帧）可供播放时触发。这个事件对应CAN_PLAY的readyState。

canplaythrough:在媒体的readyState变为CAN_PLAY_THROUGH时触发，表明媒体可以在保持当前的下载速度的情况下不被中断地播放完毕。注意:手动设置currentTime会使得firefox触发一次canplaythrough事件，其他浏览器或许不会如此。

durationchange  元信息已载入或已改变，表明媒体的长度发生了改变。例如，在媒体已被加载足够的长度从而得知总长度时会触发这个事件。

emptied:媒体被清空（初始化）时触发。

ended:播放结束时触发。

error:在发生错误时触发。元素的error属性会包含更多信息。参阅Error handling获得详细信息。

loadeddata:媒体的第一帧已经加载完毕。

loadedmetadata:媒体的元数据已经加载完毕，现在所有的属性包含了它们应有的有效信息。

loadstart:在媒体开始加载时触发。

mozaudioavailable:当音频数据缓存并交给音频层处理时

pause:播放暂停时触发。

play:在媒体回放被暂停后再次开始时触发。即，在一次暂停事件后恢复媒体回放。

playing:在媒体开始播放时触发（不论是初次播放、在暂停后恢复、或是在结束后重新开始）。

progress :告知媒体相关部分的下载进度时周期性地触发。有关媒体当前已下载总计的信息可以在元素的buffered属性中获取到。

ratechange :在回放速率变化时触发。

seeked :在跳跃操作完成时触发。

seeking:在跳跃操作开始时触发。

stalled:在尝试获取媒体数据，但数据不可用时触发。

suspend:在媒体资源加载终止时触发，这可能是因为下载已完成或因为其他原因暂停。

timeupdate:元素的currentTime属性表示的时间已经改变。

volumechange:在音频音量改变时触发（既可以是volume属性改变，也可以是muted属性改变）.。

waiting:在一个待执行的操作（如回放）因等待另一个操作（如跳跃或下载）被延迟时触发

### 音视频兼容性写法

```html
<video controls width="300" height="300">
	<source src="resource/video/OUTPUT.mp4" type="video/mp4"></source>
	<source src="resource/video/OUTPUT.ogv" type="video/ogg"></source>
	<source src="resource/video/OUTPUT.webm" type="video/webm"></source>
当前浏览器不支持 video直接播放，点击这里下载视频: <a href="resource/video/OUTPUT.mp4">下载视频</a>
</video>

<audio controls >
	<source src="resource/audio/OUTPUT.mp3" type='audio/mpeg'></source>
	<source src="resource/audio/OUTPUT.aac" type='audio/aac; codecs="aac"'></source>
	<source src="resource/audio/OUTPUT.ogg" type='audio/ogg; codecs="vorbis"'></source>
当前浏览器不支持 video直接播放，点击这里下载视频: <a href="resource/audio/OUTPUT.mp3">下载视频</a>
</audio>
```

- 浏览器会查询souce的type值，如果是支持的格式，则会访问src的路径，如果是不支持的就溜了

### demo 音阶导航

- 习惯于js有关的属性，都设置为data
- 这个对应关系有点复杂了，在html上添加了js需要的属性，其实可以定义在for循环内部，给一个属性标识一下，然后map成英文字母的++

```js
<script type="text/javascript">
  //http://s8.qhimg.com/share/audio/piano1/g4.mp3
  var liNodes = document.querySelectorAll(".nav>li"); 
	var audio = document.querySelector("audio"); 
	for(var i=0;i<liNodes.length;i++){
  liNodes[i].addEventListener("mouseenter",function(){
    //var flag = this.getAttribute("data-flag");
    var flag = this.dataset.flag==undefined? this.dataset.flag: this.getAttribute("data-flag");
    if(flag){
      audio.src="http://s8.qhimg.com/share/audio/piano1/"+flag+"4.mp3";
      audio.play();
    }
  })
}
```

### demo player

### 视频与canvas结合

```js
var oc = document.querySelector("#oc");
var video = document.querySelector("video");
if(oc.getContext){
  var ctx = oc.getContext("2d");

  video.addEventListener("loadeddata",function(){
    setInterval(function(){
      ctx.drawImage(video,0,0,oc.width,oc.height)
    })
  })
}
```

