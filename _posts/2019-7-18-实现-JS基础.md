---
layout: post
#标题配置
title:  实现-JS基础
#时间配置
date:   2019-7-18 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note front-end
---


# 业务

## 请求

### 并发请求，顺序输出

+ ```js
  async function logInOrder(urls) {
    // 并发读取远程URL
    const textPromises = urls.map(async url => {
      const response = await fetch(url);
      return response.text();
    });
  
    // 按次序输出
    for (const textPromise of textPromises) {
      console.log(await textPromise);
    }
  }
  ```

+ 上面代码中，虽然`map`方法的参数是`async`函数，但它是并发执行的，因为只有`async`函数内部是继发执行，外部不受影响。后面的`for..of`循环内部使用了`await`，因此实现了按顺序输出。

# JS基础

### oneLine

+ ```js
  let message = `
  	Hi,
  	Daisy!
  	I am
  	Kevin.
  `;
  ```

+ 出于可读性或者其他原因，我希望书写的时候是换行的，但是最终输出的字符是在一行，这就需要借助模板标签来实现了，我们尝试写一个这样的函数：

  ```js
  // oneLine 第一版
  function oneLine(template, ...expressions) {
      let result = template.reduce((prev, next, i) => {
          let expression = expressions[i - 1];
          return prev + expression + next;
      });
      result = result.replace(/(\s+)/g, " ");
      result = result.trim();
      return result;
  }
  ```

+ 实现原理很简单，拼合回去然后将多个空白符如换行符、空格等替换成一个空格。

+ 使用如下：

  ```js
  let message = oneLine `
      Hi,
      Daisy!
      I am
      Kevin.
  `;
  console.log(message); // Hi, Daisy! I am Kevin.
  ```

+ 不过你再用下去就会发现一个问题，如果字符间就包括多个空格呢？举个例子：

  ```js
  let message = oneLine`
    Preserve eg sentences.  Double
    spaces within input lines.
  `;
  ```

+ 我们可以再优化一下，我们想要的效果是将每行前面的多个空格替换成一个空格，其实应该匹配的是换行符以及换行符后面的多个空格，然后将其替换成一个空格，我们可以将正则改成：

  ```js
  result = result.replace(/(\n\s*)/g, " ");
  ```

+ 就可以正确的匹配代码。最终的代码如下：

  ```js
  // oneLine 第二版
  function oneLine(template, ...expressions) {
      let result = template.reduce((prev, next, i) => {
          let expression = expressions[i - 1];
          return prev + expression + next;
      });
  
      result = result.replace(/(\n\s*)/g, " ");
      result = result.trim();
  
      return result;
  }
  ```

### 使用setTimeout模拟setInterval

+ ```js
  (function foo() {
      ...
      setTimeout(foo, delay);
  })();
  ```

+ 同时也是一个**立即执行**的setInterval

### 手动实现一个instanceof

+ instanceof的底层实现原理

  ```js
  function instanceof(left, right) {
    // 获得类型的原型
    let prototype = right.prototype
    // 获得对象的原型
    left = left.__proto__
    // 判断对象的类型是否等于类型的原型
    while (true) {
      if (left === null)
        return false
      if (prototype === left)
        return true
      left = left.__proto__
    }
  }
  ```

  

### addEventListener

+ <https://zhuanlan.zhihu.com/p/50577896>

### 数组扁平化

+ 数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。

+ 举个例子，假设有个名为 flatten 的函数可以做到数组扁平化，效果就会如下：

  ```js
  var arr = [1, [2, [3, 4]]];
  console.log(flatten(arr)) // [1, 2, 3, 4]
  ```

+ 知道了效果是什么样的了，我们可以去尝试着写这个 flatten 函数了

#### 递归

+ 我们最一开始能想到的莫过于循环数组元素，如果还是一个数组，就递归调用该方法：

  ```js
  // 方法 1
  var arr = [1, [2, [3, 4]]];
  
  function flatten(arr) {
    const len = arr.length
    let result = [];
    for (let i = 0; i < len; i++) {
      if (Array.isArray(arr[i])) {
        result = result.concat(flatten(arr[i]))
      }
      else {
        result.push(arr[i])
      }
    }
    return result;
  }
  console.log(flatten(arr))
  ```

#### toString

+ 如果数组的元素**都是数字**，那么我们可以考虑使用 toString 方法，因为：

  ```js
  [1, [2, [3, 4]]].toString() // "1,2,3,4"
  ```

+ 调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？

  ```js
  // 方法2
  var arr = [1, [2, [3, 4]]];
  
  function flatten(arr) {
      return arr.toString().split(',').map(function(item){
          return +item
      })
  }
  
  console.log(flatten(arr))
  ```

+ 然而这种方法使用的场景却非常有限，如果数组是` [1, '1', 2, '2'] `的话，这种方法就会产生错误的结果。

#### 扩展运算符

+ ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中：

  ```js
  var arr = [1, [2, [3, 4]]];
  console.log([].concat(...arr)); // [1, 2, [3, 4]]
  ```

+ 我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法：

  ```js
  // 方法4
  var arr = [1, [2, [3, 4]]];
  
  function flatten(arr) {
    while (arr.some(item => Array.isArray(item))) {
      arr = [].concat(...arr);
    }
    return arr;
  }
  
  console.log(flatten(arr))
  ```

#### undercore递归实现

+ 这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。

  ```js
  /**
   * 数组扁平化
   * @param  {Array} input   要处理的数组
   * @param  {boolean} shallow 是否只扁平一层
   * @param  {boolean} strict  是否严格处理元素，下面有解释
   * @param  {Array} output  这是为了方便递归而传递的参数
   */
  function flatten(input,{shallow=false,strict=false}={}, output=[]) {
    // 递归使用的时候会用到output
    const len = input.length
    for (let i = 0; i < len; i++) {
      const value = input[i];
      // 如果是数组，就进行处理
      if (Array.isArray(value)) {
        if (shallow) {
          // 如果是只扁平一层，遍历该数组，依此填入 output
          let j = 0, length = value.length;
          while (j < length) output.push(value[j++]);
        }else {
          // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output
          flatten(value,{shallow,strict}, output);
        }
      }else if (!strict){
        // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output
        output.push(value)
      }
    }
    return output;
  }
  ```

+ 解释下 strict，在代码里我们可以看出，当遍历数组元素时，如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，举个例子：

  ```js
  var arr = [1, 2, [3, 4]];
  console.log(flatten(arr,{shallow:true,strict=true})); // [3, 4]
  ```

+ 那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果：

  - shallow true + strict false ：正常扁平一层
  - shallow false + strict false ：正常扁平所有层
  - shallow true + strict true ：去掉非数组元素
  - shallow false + strict true ： 返回一个[]

### _.flatten

+ ```js
  _.flatten = function(array, shallow) {
      return flatten(array,{shallow,strict:false});
  };
  ```

+ 在正常的扁平中，我们并不需要去掉非数组元素。

### 交并补

#### _.union

+ 接下来是 _.union

+ 该函数传入多个数组，然后返回传入的数组的并集，

+ 举个例子：

  ```js
  _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
  => [1, 2, 3, 101, 10]
  ```

+ 如果传入的参数并不是数组，就会将该参数跳过：

  ```js
  _.union([1, 2, 3], [101, 2, 1, 10], 4, 5);
  => [1, 2, 3, 101, 10]
  ```

+ 为了实现这个效果，我们可以将传入的所有数组扁平化，然后去重，因为只能传入数组，这时候我们直接设置 strict 为 true，就可以跳过传入的非数组的元素。

  ```js
  function unique(array) {
     return Array.from(new Set(array));
  }
  
  _.union = function(...args) {
      return unique(flatten(args,{shallow:true,strict:true}));
  }
  ```

#### _.difference

+ 效果是取出来自 array 数组，并且不存在于多个 other 数组的元素。跟 _.union 一样，都会排除掉不是数组的元素。

  ```js
  _.difference([1, 2, 3, 4, 5], [5, 2, 10], [4], 3);
  => [1, 3]
  ```

+ 实现方法也很简单，扁平 others 的数组，筛选出 array 中不在扁平化数组中的值：

  ```js
  function difference(array, ...others) {
      others = flatten(rest,{shallow:true,strct:true});
      return array.filter(function(item){
          return rest.indexOf(item) === -1;
      })
  }
  ```

#### 使用set实现

+ ```js
  let a = new Set([1, 2, 3]);
  let b = new Set([4, 3, 2]);
  
  // 并集，两个集合去重
  let union = new Set([...a, ...b]);
  // Set {1, 2, 3, 4}
  
  // 交集
  let intersect = new Set([...a].filter(x => b.has(x)));
  // set {2, 3}
  
  // 差集
  let difference = new Set([...a].filter(x => !b.has(x)));
  // Set {1}
  ```

### Object.is() 

- ES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。

- ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。

- 不同之处只有两个：一是`+0`不等于`-0`，二是`NaN`等于自身。

  - ```javascript
    +0 === -0 //true
    NaN === NaN // false
    
    Object.is(+0, -0) // false
    Object.is(NaN, NaN) // true
    ```

#### +0和-0

+ 如果 a === b 的结果为 true， 那么 a 和 b 就是相等的吗？一般情况下，当然是这样的，但是有一个特殊的例子，就是 +0 和 -0。

+ JavaScript “处心积虑”的想抹平两者的差异：

  ```js
  // 表现1
  console.log(+0 === -0); // true
  
  // 表现2
  (-0).toString() // '0'
  (+0).toString() // '0'
  
  // 表现3
  -0 < +0 // false
  +0 < -0 // false
  ```

+ 即便如此，两者依然是不同的：

  ```
  1 / +0 // Infinity
  1 / -0 // -Infinity
  
  1 / +0 === 1 / -0 // false
  ```

+ 也许你会好奇为什么要有 +0 和 -0 呢？

+ 这是因为 JavaScript 采用了IEEE_754 浮点数表示法(几乎所有现代编程语言所采用)，这是一种二进制表示法，按照这个标准，最高位是符号位(0 代表正，1 代表负)，剩下的用于表示大小。而对于零这个边界值 ，1000(-0) 和 0000(0)都是表示 0 ，这才有了正负零的区别。

+ 也许你会好奇什么时候会产生 -0 呢？

  ```
  Math.round(-0.1) // -0
  ```

+ 那么我们又该如何在 === 结果为 true 的时候，区别 0 和 -0 得出正确的结果呢？我们可以这样做：

  ```js
  function eq(a, b){
      if (a === b) return a !== 0 || 1 / a === 1 / b;
      return false;
  }
  
  console.log(eq(0, 0)) // true
  console.log(eq(0, -0)) // false
  ```

#### NaN

+ 在本篇，我们认为 NaN 和 NaN 是相等的，那又该如何判断出 NaN 呢？

  ```js
  console.log(NaN === NaN); // false
  ```

+ 利用 NaN 不等于自身的特性，我们可以区别出 NaN，那么这个 eq 函数又该怎么写呢？

  ```js
  function eq(a, b) {
      if (a !== a) return b !== b;
  }
  
  console.log(eq(NaN, NaN)); // true
  ```

### deepEq

#### String 对象

+ 现在我们开始写 deepEq 函数，一个要处理的重大难题就是 'Curly' 和 new String('Curly') 如何判断成相等？

+ 两者的类型都不一样呐！不信我们看 typeof 的操作结果：

+ ```js
  console.log(typeof 'Curly'); // string
  console.log(typeof new String('Curly')); // object
  ```

+ 可是我们在[《JavaScript专题之类型判断上》](https://github.com/mqyqingfeng/Blog/issues/28)中还学习过更多的方法判断类型，比如 Object.prototype.toString：

  ```js
  var toString = Object.prototype.toString;
  toString.call('Curly'); // "[object String]"
  toString.call(new String('Curly')); // "[object String]"
  ```

+ 神奇的是使用 toString 方法两者判断的结果却是一致的，可是就算知道了这一点，还是不知道如何判断字符串和字符串包装对象是相等的呢？

+ 那我们利用隐式类型转换呢？

  ```
  console.log('Curly' + '' === new String('Curly') + ''); // true
  ```

+ 看来我们已经有了思路：如果 a 和 b 的 Object.prototype.toString的结果一致，并且都是"[object String]"，那我们就使用 '' + a === '' + b 进行判断。

+ 可是不止有 String 对象呐，Boolean、Number、RegExp、Date呢？

#### 更多对象

+ 跟 String 同样的思路，利用隐式类型转换。

+ **Boolean**

  ```js
  var a = true;
  var b = new Boolean(true);
  
  console.log(+a === +b) // true
  ```

+ **Date**

  ```js
  var a = new Date(2009, 9, 25);
  var b = new Date(2009, 9, 25);
  
  console.log(+a === +b) // true
  ```

+ **RegExp**

  ```js
  var a = /a/i;
  var b = new RegExp(/a/i);
  
  console.log('' + a === '' + b) // true
  ```

+ **Number**

  ```js
  var a = 1;
  var b = new Number(1);
  
  console.log(+a === +b) // true
  ```

+ 嗯哼？你确定 Number 能这么简单的判断？

  ```js
  var a = Number(NaN);
  var b = Number(NaN);
  
  console.log(+a === +b); // false
  ```

+ 可是 a 和 b 应该被判断成 true 的呐~

+ 那么我们就改成这样：

  ```js
  var a = Number(NaN);
  var b = Number(NaN);
  
  function eq() {
      // 判断 Number(NaN) Object(NaN) 等情况
      if (+a !== +a) return +b !== +b;
      // 其他判断 ...
  }
  
  console.log(eq(a, b)); // true
  ```

#### 基本实现

+ ```js
  var toString = Object.prototype.toString;
  
  function deepEq(a, b) {
      var className = toString.call(a);
      if (className !== toString.call(b)) return false;
  
      switch (className) {
          case '[object RegExp]':
          case '[object String]':
              return '' + a === '' + b;
          case '[object Number]':
              if (+a !== +a) return +b !== +b;
              return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
              return +a === +b;
      }
  
      // 其他判断
  }
  ```

### 通用遍历方法each的实现

#### each介绍

+ jQuery 的 each 方法，作为一个通用遍历方法，可用于遍历对象和数组。

  语法为：

  ```
  jQuery.each(object, [callback])
  ```

+ 回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。

  ```js
  // 遍历数组
  $.each( [0,1,2], function(i, n){
      console.log( "Item #" + i + ": " + n );
  });
  
  // Item #0: 0
  // Item #1: 1
  // Item #2: 2
  // 遍历对象
  $.each({ name: "John", lang: "JS" }, function(i, n) {
      console.log("Name: " + i + ", Value: " + n);
  });
  // Name: name, Value: John
  // Name: lang, Value: JS
  ```

#### 退出循环

+ 尽管 ES5 提供了 forEach 方法，但是 forEach 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。但是对于 jQuery 的 each 函数，如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略。

  ```js
  $.each( [0, 1, 2, 3, 4, 5], function(i, n){
      if (i > 2) return false;
      console.log( "Item #" + i + ": " + n );
  });
  
  // Item #0: 0
  // Item #1: 1
  // Item #2: 2
  ```

#### 分析

+ 首先，我们肯定要根据参数的类型进行判断，如果是数组，就调用 for 循环，如果是对象，就使用 for in 循环，有一个例外是类数组对象，对于类数组对象，我们依然可以使用 for 循环。

+ 中止循环的功能。

  ```js
  if (callback(i, obj[i]) === false) {
      break;
  }
  ```

+ 指定 this，我们可以使用 call 或者 apply，其实也很简单：

  ```js
  if (callback.call(obj[i], i, obj[i]) === false) {
      break;
  }
  ```

#### 实现

+ ```js
  function each(obj, callback) {
    var length, i = 0;
  
    if (isArrayLike(obj)) {
      length = obj.length;
      for (; i < length; i++) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    } else {
      for (i in obj) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    }
  
    return obj;
  }
  ```

+ each 函数和 eachWithCall 函数唯一的区别就是 eachWithCall 调用了 call，从结果我们可以推测出，call 会导致性能损失，但也正是 call 的存在，我们才能将 this 指向循环中当前的元素。

+ 现在完全可以用`for...of`代替

### freeze

- 如果真的想将对象冻结，应该使用`Object.freeze`方法。

  ```javascript
  const foo = Object.freeze({});

  // 常规模式时，下面一行不起作用；
  // 严格模式时，该行会报错
  foo.prop = 123;
  ```

- 上面代码中，常量`foo`指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。

- 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。

  ```javascript
  var constantize = (obj) => {
    Object.freeze(obj);
    Object.keys(obj).forEach( (key, i) => {
      if ( typeof obj[key] === 'object' ) {
        constantize( obj[key] );
      }
    });
  };
  ```

## call() apply() bind()

### call()

- call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。

- 让某个函数临时成为指定的 this 的方法，并且进行调用

  ```js
  var foo = {
      value: 1
  };
  
  function bar() {
      console.log(this.value);
  }
  
  bar.call(foo); // 1
  ```

- call 改变了 this 的指向，指向到 foo
- 同时，bar 函数执行了

#### 模拟实现第一步

1. 将函数设为对象的属性
2. 执行该函数
3. 删除该函数

- 改造上面的例子

  ```js
  // 第一步
  foo.fn = bar
  // 第二步
  foo.fn()
  // 第三步
  delete foo.fn
  ```

- 完整版myCall函数

  ```js
  Function.prototype.myCall = function(context){
    // context是传统意义上的this，一个obj
    // 这里的this是要执行的函数
    // foo.fn = bar
    context.fn = this 
    context.fn()
    delete context.fn
  }
  
  const foo = {
    value:1,
  }
  
  function bar(){
    console.log(this.value)
  }
  
  bar.myCall(foo) // 1
  ```

#### 模拟实现第二步

- call 函数还能给定参数执行函数，但是，传入的参数并不确定，并且传入的参数要再传入到调用的函数中

- 两种错误的做法

  ```js
  // 将数组里的元素作为多个参数放进函数的形参里
  context.fn(args.join(','))
  // 相当于是传入了一个 join 好的字符串
  
  // 相当于是传入了一个类数组对象，只有第一个形参被赋予该值
  context.fn(arguments)
  ```

- 使用ES6的做法，使用扩展运算符即可解决

  ```js
  Function.prototype.myCall = function(context,...rest){
    context.fn = this
    // {value: 1, fn: },1,2,3
    // context.fn(...arguments)
    context.fn(..rest)
    delete context.fn
  }
  
  const foo = {
    value:1,
  }
  
  function bar(a,b){
    console.log(this.value)
    console.log(a,b) // this,1
  }
  
  bar.myCall(foo,1,2,3) // 1
  ```

- 不过 call 是 ES3 的方法，模拟实现就别用ES6了

**eval()**

- 截取arguments的参数部分

- ```js
  // 以上个例子为例，此时的arguments为：
  // arguments = {
  //      0: foo,
  //      1: 'kevin',
  //      2: 18,
  //      length: 3
  // }
  // 因为arguments是类数组对象，所以可以用for循环
  var args = [];
  for(var i = 1, len = arguments.length; i < len; i++) {
      args.push('arguments[' + i + ']');
  }
  
  // 执行后 args为 ["arguments[1]", "arguments[2]", "arguments[3]"]
  ```

- 通过eval还原参数

  ```js
  eval('context.fn(' + args +')')
  // context.fn(arguments[1],arguments[2],arguments[3])
  ```
```
  
- 这里 args 会自动调用 Array.toString() 这个方法，相当于`args.join(',')`

  > 既然最终要执行的是字符串那为什么不使用字符串拼接呢？因为参数之间有个逗号，使用数组可以不用考虑去掉尾逗号

- eval()版完整代码

  ```js
  Function.prototype.myCall = function(context){
    const args = []
    context.fn = this
    for (let i = 1; i < arguments.length; i++) {
      args.push('arguments['+i+']')
    }
    eval('context.fn('+args+')')
    delete context.fn
  }
  
  const foo = {
    value:1,
  }
  
  function bar(a,b){
    console.log(this.value)
    console.log(a,b) // this,1
  }
  
  bar.myCall(foo,1,{b:2}) // 1
```

#### 模拟实现第三步

**两个注意点**

- **this 参数可以传 null，当为 null 的时候，视为指向 window**

- **函数是可以有返回值的！**

- 最终版完整代码

  ```js
  // 第三版
  Function.prototype.call2 = function (context) {
      // null
      var context = context || window;
      context.fn = this;
  
      var args = [];
      for(var i = 1, len = arguments.length; i < len; i++) {
          args.push('arguments[' + i + ']');
      }
    
      var result = eval('context.fn(' + args +')');
  
      delete context.fn
      return result;
  }
  
  // 测试一下
  var value = 2;
  
  var obj = {
      value: 1
  }
  
  function bar(name, age) {
      console.log(this.value);
      return {
          value: this.value,
          name: name,
          age: age
      }
  }
  
  bar.call2(null); // 2
  
  console.log(bar.call2(obj, 'kevin', 18));
  // 1
  // Object {
  //    value: 1,
  //    name: 'kevin',
  //    age: 18
  // }
  ```

### apply()

- ```js
  Function.prototype.apply = function (context, arr) {
      var context = Object(context) || window;
      context.fn = this;
  
      var result;
      if (!arr) {
          result = context.fn();
      }
      else {
          var args = [];
          for (var i = 0, len = arr.length; i < len; i++) {
              args.push('arr[' + i + ']');
          }
          result = eval('context.fn(' + args + ')')
      }
  
      delete context.fn
      return result;
  }
  ```

### bind()

- bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。

#### 返回函数的实现

- 返回一个函数

- 可以指定this，关于this的指定，我们可以使用 call() 或者 apply() 方法实现

  ```js
  Function.prototype.bind2 = function (context) {
  	// self = bar
    var self = this;
    return function () {
      // bar.apply(foo)
      return self.apply(context); // 调用函数可能会有返回值，所以需要再return一个
    }
  
  }
  const foo = {
    value:1,
  }
  
  function bar(){
    console.log(this.value)
  }
  
  bar.bind2(foo)
  ```

#### 分段传参的实现

- ```js
  var foo = {
      value: 1
  };
  
  function bar(name, age) {
      console.log(this.value);
      console.log(name);
      console.log(age);
  
  }
  
  var bindFoo = bar.bind(foo, 'daisy');
  bindFoo('18');
  // 1
  // daisy
  // 18
  ```

- 函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!

- 我们用 arguments 进行处理：

  ```js
  // 第二版
  Function.prototype.bind2 = function (context) {
  
    var self = this;
    // 获取bind2函数从第二个参数到最后一个参数
    var args = Array.prototype.slice.call(arguments, 1);
  
    return function () {
      // 这个时候的arguments是指bind返回的函数传入的参数
  		// 这一步仅仅是把arguments转换成了真数组
      var bindArgs = Array.prototype.slice.call(arguments);
      return self.apply(context, args.concat(bindArgs));
    }
  
  }
  ```

#### 构造函数效果的实现

- 因为 bind 还有一个特点，就是

  > 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。

- 先来看一个例子

  ```js
  var value = 2;
  
  var foo = {
      value: 1
  };
  
  function bar(name, age) {
      this.habit = 'shopping';
      console.log(this.value);
      console.log(name);
      console.log(age);
  }
  
  bar.prototype.friend = 'kevin';
  
  var bindFoo = bar.bind(foo, 'daisy');
  
  var obj = new bindFoo('18');
  // undefined
  // daisy
  // 18
  console.log(obj.habit); // shopping
  console.log(obj.friend); // kevin
  
  ```
  
- **注意：**尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。

- 我们可以通过修改返回的函数的原型来实现，让我们写一下：

  ```js
  // 第三版
  Function.prototype.bind2 = function (context) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
  
      var fBound = function () {
          var bindArgs = Array.prototype.slice.call(arguments);
          // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
          // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
          // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
          return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));
      }
      // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
      fBound.prototype = this.prototype;
      return fBound;
  }
  ```

#### 构造函数效果的优化实现

- 但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：

  ```js
  Function.prototype.bind2 = function (context) {
  
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
  
      var fNOP = function () {};
  
      var fBound = function () {
          var bindArgs = Array.prototype.slice.call(arguments);
          return self.apply(this instanceof fBount ? this : context, args.concat(bindArgs));
      }
      fNOP.prototype = this.prototype;
      // 即是fBound的实例，也是fNOP的实例
      fBound.prototype = new fNOP();
      return fBound;
  }
  ```

#### 三个小问题

- 在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是：

  ```js
  self.apply(this instanceof self ? this : context || this, args.concat(bindArgs))
  ```

  - 多了一个关于 context 是否存在的判断，然而这个是错误的！
  - 举个例子：

  ```js
  var value = 2;
  var foo = {
      value: 1,
      bar: bar.bind(null)
  };
  
  function bar() {
      console.log(this.value);
  }
  
  foo.bar() // 2
  ```

  - 以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！
  - 所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！

- **调用 bind 的不是函数咋办？**

  ```js
  if (typeof this !== "function") {
    throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
  }
  ```

#### 最终代码

- ```js
  Function.prototype.bind2 = function (context) {
  
      if (typeof this !== "function") {
        throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
      }
  
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
  
      var fNOP = function () {};
  
      var fBound = function () {
          var bindArgs = Array.prototype.slice.call(arguments);
          return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
      }
  
      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();
      return fBound;
  }
  ```

## new() #

- new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一

- 先来看一个例子

  ```js
  // Otaku 御宅族，简称宅
  function Otaku (name, age) {
      this.name = name;
      this.age = age;
  
      this.habit = 'Games';
  }
  
  // 因为缺乏锻炼的缘故，身体强度让人担忧
  Otaku.prototype.strength = 60;
  
  Otaku.prototype.sayYourName = function () {
      console.log('I am ' + this.name);
  }
  
  var person = new Otaku('Kevin', '18');
  
  console.log(person.name) // Kevin
  console.log(person.habit) // Games
  console.log(person.strength) // 60
  
  person.sayYourName(); // I am Kevin
  ```

- 从这个例子中，我们可以看到，实例 person 可以：

  - 访问到 Otaku 构造函数里的属性
  - 访问到 Otaku.prototype 中的属性

- 因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的：

  ```js
  function Otaku () {
      ……
  }
  
  // 使用 new
  var person = new Otaku(……);
  // 使用 objectFactory
  var person = objectFactory(Otaku, ……)
  ```

### 初步实现

- 因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku **构造函数里的属性**，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。

- 在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 `__proto__ `属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。

  ```js
  // 第一版代码
  function objectFactory() {
  
      var obj = new Object(),
  
      Constructor = [].shift.call(arguments);
  
      obj.__proto__ = Constructor.prototype;
  
      Constructor.apply(obj, arguments);
  
      return obj;
  
  };
  ```

  1. 用new Object() 的方式新建了一个对象 obj
  2. 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数
  3. 将 obj 的原型指向构造函数的原型，这样 obj 就可以访问到构造函数原型中的属性
  4. 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性，**其实是最传统的工厂模式**
  5. 返回 obj

### 返回值效果实现

- 接下来我们再来看一种情况，假如构造函数有返回值，举个例子：

  ```js
  function Otaku (name, age) {
      this.strength = 60;
      this.age = age;
  
      return {
          name: name,
          habit: 'Games'
      }
  }
  
  var person = new Otaku('Kevin', '18');
  
  console.log(person.name) // Kevin
  console.log(person.habit) // Games
  console.log(person.strength) // undefined
  console.log(person.age) // undefined
  ```

- 在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？

- 再举个例子：

  ```js
  function Otaku (name, age) {
      this.strength = 60;
      this.age = age;
  
      return 'handsome boy';
  }
  
  var person = new Otaku('Kevin', '18');
  
  console.log(person.name) // undefined
  console.log(person.habit) // undefined
  console.log(person.strength) // 60
  console.log(person.age) // 18
  ```

- 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。

- 所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。

- 再来看第二版的代码，也是最后一版的代码：

  ```js
  // 第二版的代码
  function objectFactory() {
  
      var obj = new Object(),
  
      Constructor = [].shift.call(arguments);
  
      obj.__proto__ = Constructor.prototype;
  
      var ret = Constructor.apply(obj, arguments);
  		// obj 已经经过工厂模式的修改
      return typeof ret === 'object' ? ret : obj;
  
  };
  ```

## 类型判断 #

### typeof:

- 在 ES6 前，JavaScript 共六种数据类型，分别是：

  > Undefined、Null、Boolean、Number、String、Object

- typeof 对这些数据类型的值进行操作的时候，返回的结果却不是一一对应，分别是：

  > undefined、object、boolean、number、string、object

- **注意：返回的字符串都是小写的**，`typeof NaN // number`

- 可以判断: undefined/ 数值 / 字符串 / 布尔值 / function

- 不能判断: null与object  object与array , 不能区分出 object 的类

  ```js
  typeof null //object
  typeof array //object
  typeof NaN // number
  ```

- 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 `null` 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，`typeof null`就错误的返回了"`object"`。（[reference](http://www.2ality.com/2013/10/typeof-null.html)）

- ECMAScript提出了一个修复（通过opt-in），但[被拒绝](http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null)。这将导致typeof null === 'object'。

### instanceof:

- instanceof运算符用于测试**构造函数**的prototype属性是否出现在对象的原型链中的任何位置
- 判断对象的是否是某个**具体类**（构造函数的实例）

**返回值**

- 如果该对象是构造函数的实例，则返回true，否则返回false

**示例**

- ```js
  语法：对象 instanceof 构造函数
  console.log(per instanceof Person); //true
  ```

**注意**

- **Object**是所有对象的祖先，所以任何对象和Object做instanceof运算符都会返回true

### ===

- 可以判断: undefined, null
- 因为这两个类型都只有一个值

### Object.prototype.toString.call(target) 

- 返回固定字符串： [object Target类型]

- `Object.prototype.toString.call(target).slice(8,-1)`，就可以返回准确的类型

- ES5开始，可以检查Null 和 undefined。ES5 规范地址：<https://es5.github.io/#x15.2.4.2>。

- 当 `Object.prototype.toString` 方法被调用的时候，下面的步骤会被执行：

  > 1. 如果 this 值是 undefined，就返回 [object Undefined]
  > 2. 如果 this 的值是 null，就返回 [object Null]
  > 3. 让 O 成为 ToObject(this) 的结果
  > 4. 让 class 成为 O 的内部属性 [[Class]] 的值
  > 5. 最后返回由 "[object " 和 class 和 "]" 三个部分组成的字符串

- 无法判断自定义类型

- Object.prototype.toString 可以识别出至少12种数据类型

  ```js
  // 以下是12种：
  var number = 1;          // [object Number]
  var string = '123';      // [object String]
  var boolean = true;      // [object Boolean]
  var und = undefined;     // [object Undefined]
  var nul = null;          // [object Null]
  var obj = {a: 1}         // [object Object]
  var array = [1, 2, 3];   // [object Array]
  var date = new Date();   // [object Date]
  var error = new Error(); // [object Error]
  var reg = /a/g;          // [object RegExp]
  var func = function a(){}; // [object Function]
  // ES6
  const sym = Symbol() // [object Symbol]
  
  function checkType() {
    for (var i = 0; i < arguments.length; i++) {
      console.log(Object.prototype.toString.call(arguments[i]))
    }
  }
  
  checkType(number, string, boolean, und, nul, obj, array, date, error, reg, func)
  ```

  ```js
  console.log(Object.prototype.toString.call(Math)); // [object Math]
  console.log(Object.prototype.toString.call(JSON)); // [object JSON]
  console.log(Object.prototype.toString.call(window)); // [object Window]
  ```

  ```js
  function a() {
      console.log(Object.prototype.toString.call(arguments)); // [object Arguments]
  }
  a();
  ```

  > **注意：**
  >
  > - Array.prototype的类型**也是数组**，类似的Number.prototype是number类型的对象
  > - 实例本身是没有`constructor`属性的，`constructor`属性在原型上，为了保持一致性，所以`Array.prototype`也是`Array`

### 封装 type 函数

- 写一个 type 函数能检测各种类型的值

  - 基本类型，就使用 typeof
  - 引用类型就使用 toString
  - 此外鉴于 typeof 的结果是小写，我也希望所有的结果都是小写。
  - 考虑到实际情况下并不会检测 Math 和 JSON，所以去掉这两个类型的检测。

  ```js
  // 第一版
  var class2type = {};
  
  // 生成class2type映射
  "Boolean Number String Function Array Date RegExp Object Error Null Undefined".split(" ").map(function(item, index) {
      class2type["[object " + item + "]"] = item.toLowerCase();
  })
  
  function type(obj) {
      return typeof obj === "object" || typeof obj === "function" ?
          class2type[Object.prototype.toString.call(obj)] || "object" :
          typeof obj;
  }
  ```

- **注意：**在 IE6 中，null 和 undefined 会被 Object.prototype.toString 识别成 [object Object]！

- 兼容IE6

  ```js
  // 第二版
  var class2type = {};
  
  // 生成class2type映射
  "Boolean Number String Function Array Date RegExp Object Error".split(" ").map(function(item, index) {
      class2type["[object " + item + "]"] = item.toLowerCase();
  })
  
  function type(obj) {
      // 一箭双雕
      if (obj == null) {
          return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ?
          class2type[Object.prototype.toString.call(obj)] || "object" :
          typeof obj;
  }
  ```

### isFunction

- 有了 type 函数后，我们可以对常用的判断直接封装，比如 isFunction:

  ```js
  function isFunction(obj) {
      return type(obj) === "function";
  }
  ```

### isArray

- ```js
  var isArray = Array.isArray || function( obj ) {
      return type(obj) === "array";
  }
  ```

- 原型和构造函数都有被修改的可能性

### isArrayLike

+ isArrayLike，看名字可能会让我们觉得这是判断类数组对象的，其实不仅仅是这样，jQuery 实现的 isArrayLike，数组和类数组都会返回 true

  ```js
  function isArrayLike(obj) {
  
    // obj 必须有 length属性
    var length = !!obj && "length" in obj && obj.length;
    var typeRes = type(obj);
  
    // 排除掉函数和 Window 对象
    if (typeRes === "function" || isWindow(obj)) {
      return false;
    }
  
    return typeRes === "array" || length === 0 ||
      typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  ```

+ 重点分析 return 这一行，使用了或语句，只要一个为 true，结果就返回 true。

+ 所以如果 isArrayLike 返回true，至少要满足三个条件之一：

  1. 是数组
  2. 长度为 0
  3. lengths 属性是大于 0 的数字类型，并且`obj[length - 1]`必须存在

+ 第一个就不说了，看第二个，为什么长度为 0 就可以直接判断为 true 呢？

  那我们写个对象：

  ```js
  var obj = {a: 1, b: 2, length: 0}
  ```

  isArrayLike 函数就会返回 true，那这个合理吗？

  回答合不合理之前，我们先看一个例子：

  ```js
  function a(){
      console.log(isArrayLike(arguments))
  }
  a();
  ```

  如果我们去掉length === 0 这个判断，就会打印 false，然而我们都知道 arguments 是一个类数组对象，这里是应该返回 true 的。

  所以是不是为了放过空的 arguments 时也放过了一些存在争议的对象呢？

  第三个条件：length 是数字，并且 length > 0 且最后一个元素存在。

  为什么仅仅要求最后一个元素存在呢？

  让我们先想下数组是不是可以这样写：

  ```json
  var arr = [,,3]
  ```

  当我们写一个对应的类数组对象就是：

  ```js
  var arrLike = {
      2: 3,
      length: 3
  }
  ```

  也就是说当我们在数组中用逗号直接跳过的时候，我们认为该元素是不存在的，类数组对象中也就不用写这个元素，但是最后一个元素是一定要写的，要不然 length 的长度就不会是最后一个元素的 key 值加 1。比如数组可以这样写

  ```
  var arr = [1,,];
  console.log(arr.length) // 2
  ```

  但是类数组对象就只能写成：

  ```js
  var arrLike = {
      0: 1,
      length: 1
  }
  ```

  所以符合条件的类数组对象是一定存在最后一个元素的！

  这就是满足 isArrayLike 的三个条件，其实除了 jQuery 之外，很多库都有对 isArrayLike 的实现，比如 underscore:

  ```js
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  
  var isArrayLike = function(collection) {
      var length = getLength(collection);
      return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };
  ```

### isPlainObject

+ plainObject 来自于 jQuery，可以翻译成纯粹的对象，所谓"纯粹的对象"，就是该对象是通过 "{}" 或 "new Object" 创建的，该对象含有零个或者多个键值对。

+ 之所以要判断是不是 plainObject，是为了跟其他的 JavaScript对象如 null，数组，宿主对象（documents）等作区分，因为这些用 typeof 都会返回object。

+ jQuery提供了 isPlainObject 方法进行判断，先让我们看看使用的效果：

  ```js
  function Person(name) {
    this.name = name;
  }
  
  console.log($.isPlainObject({})) // true
  
  console.log($.isPlainObject(new Object)) // true
  
  console.log($.isPlainObject(Object.create(null))); // true
  
  console.log($.isPlainObject(Object.assign({a: 1}, {b: 2}))); // true
  
  console.log($.isPlainObject(new Person('yayu'))); // false
  
  console.log($.isPlainObject(Object.create({}))); // false
  ```

+ 由此我们可以看到，除了 {} 和 new Object 创建的之外，jQuery 认为一个**没有原型的对象**也是一个纯粹的对象。

+ isPlainObject 的实现也在变化，我们今天讲的是 3.0 版本下的 isPlainObject，我们直接看源码：

  ```js
  // 上节中写 type 函数时，用来存放 toString 映射结果的对象
  var class2type = {};
  
  // 相当于 Object.prototype.toString
  var toString = class2type.toString;
  
  // 相当于 Object.prototype.hasOwnProperty
  var hasOwn = class2type.hasOwnProperty;
  
  function isPlainObject(obj) {
    var proto, Ctor;
  
    // 排除掉明显不是obj的以及一些宿主对象如Window
    if (!obj || toString.call(obj) !== "[object Object]") {
      return false;
    }
  
    proto = Object.getPrototypeOf(obj);
  
    // 没有原型的对象是纯粹的，Object.create(null) 就在这里返回 true
    if (!proto) {
      return true;
    }
  
    /**
     * 以下判断通过 new Object 方式创建的对象
     * 判断 proto 是否有 constructor 属性，如果有就让 Ctor 的值为 proto.constructor
     * 如果是 Object 函数创建的对象，Ctor 在这里就等于 Object 构造函数
     */
    Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
  
    // 在这里判断 Ctor 构造函数是不是 Object 构造函数，用于区分自定义构造函数和 Object 构造函数
    return typeof Ctor === "function" && hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object);
  }
  ```

+ 注意：我们判断 Ctor 构造函数是不是 Object 构造函数，用的是` hasOwn.toString.call(Ctor)`，这个方法可不是 `Object.prototype.toString`，不信我们在函数里加上下面这两句话：

  ```js
  console.log(hasOwn.toString.call(Ctor)); // function Object() { [native code] }
  console.log(Object.prototype.toString.call(Ctor)); // [object Function]
  ```

+ 发现返回的值并不一样，这是因为 `hasOwn.toString` 调用的其实是` Function.prototype.toString`，毕竟 `hasOwnProperty `可是一个函数！

+ 而且 Function 对象覆盖了从 Object 继承来的 Object.prototype.toString 方法。函数的 toString 方法会返回一个表示函数源代码的字符串。具体来说，包括 function关键字，形参列表，大括号，以及函数体中的内容。

+ **因此**：这里要判断的其实是两个函数是否一样

### isEmptyObject 

- 用`for...in`遍历

  ```js
  for (var i in obj) { // 如果不为空，则会执行到这一步，返回true
      return false
  }
  return true // 如果为空,返回false
  ```

- 其实所谓的` isEmptyObject `就是判断是否有属性，for 循环一旦执行，就说明有属性，有属性就会返回 false。

- 但是根据这个源码我们可以看出isEmptyObject实际上判断的并不仅仅是空对象。

  ````js
  console.log(isEmptyObject({})); // true
  console.log(isEmptyObject([])); // true
  console.log(isEmptyObject(null)); // true
  console.log(isEmptyObject(undefined)); // true
  console.log(isEmptyObject(1)); // true
  console.log(isEmptyObject('')); // true
  console.log(isEmptyObject(true)); // true
  ````

- 但是既然 jQuery 是这样写，可能是因为考虑到实际开发中 isEmptyObject 用来判断 {} 和 {a: 1} 是足够的吧。如果真的是只判断 {}，完全可以结合上篇写的 type 函数筛选掉不适合的情况。

- 通过 `JSON` 自带的 `stringify()` 方法来判断

  ```js
  if (JSON.stringify(data) === '{}') {
      return true // 如果为空,返回false
  }
  return false // 如果不为空，返回true
  ```

- 依靠`Object.keys()`

  ```js
  if (Object.keys(object).length === 0) {
      return true // 如果为空,返回false
  }
  return false // 如果不为空，则会执行到这一步，返回true
  ```

### isWondow

+ Window 对象作为客户端 JavaScript 的全局对象，它有一个 window 属性指向自身，这点在[《JavaScript深入之变量对象》](https://github.com/mqyqingfeng/Blog/issues/5)中讲到过。我们可以利用这个特性判断是否是 Window 对象。

  ```js
  function isWindow( obj ) {
      return obj != null && obj === obj.window;
  }
  ```

### isElement

+ isElement 判断是不是 DOM 元素。

  ```js
  isElement = function(obj) {
      return !!(obj && obj.nodeType === 1);
  };
  ```

## 克隆

### 数组的浅拷贝

#### slice() concat()

+ 可以利用数组的一些方法比如：slice、concat 返回一个新数组的特性来实现拷贝。

  ```js
  var arr = ['old', 1, true, null, undefined];
  
  var new_arr = arr.concat();
  var new_arr = arr.slice();
  ```

#### 扩展运算符

+ ```js
  var arr = ['old', 1, true, null, undefined];
  var new_arr = [...arr]
  ```

#### Array.from()

+ 如果参数是一个真正的数组，`Array.from`会返回一个一模一样的新数组，浅克隆

  ```js
  var arr = ['old', 1, true, null, undefined];
  var new_arr = Array.from(arr)
  ```

#### 对比

+ 扩展运算符背后调用的是遍历器接口（`Symbol.iterator`），如果一个对象没有部署这个接口，就无法转换。

+ `Array.from`方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有`length`属性。因此，任何有`length`属性的对象，都可以通过`Array.from`方法转为数组，而此时扩展运算符就无法转换。

  ```js
  Array.from({ length: 3 });
  // [ undefined, undefined, undefined ]
  ```

### JSON实现深拷贝

+ ```js
  var arr = ['old', 1, true, ['old1', 'old2'], {old: 1}]
  
  var new_arr = JSON.parse( JSON.stringify(arr) );
  
  console.log(new_arr);
  ```

+ 有一个问题，不能拷贝函数，我们做个试验：

  ```js
  var arr = [function(){console.log(a)}, {b: function(){console.log(b)}}]
  
  var new_arr = JSON.parse(JSON.stringify(arr));
  
  console.log(new_arr);
  ```

+ 我们会发现 new_arr 变成了：

  ![ä¸è½æ·è´å½æ°](https://github.com/mqyqingfeng/Blog/raw/master/Images/copy/copy1.png)

### 浅拷贝的实现

+ ```js
  const shallowCopy = function(obj) {
    // 只拷贝对象
    if (typeof obj !== 'object') return;
    // 根据obj的类型判断是新建一个数组还是对象
    const newObj = obj instanceof Array ? [] : {};
    // 遍历obj，并且判断是obj的属性才拷贝
    // for (var key in obj) {
    //   if (obj.hasOwnProperty(key)) newObj[key] = obj[key]
    // }
    for (const [key,value] of Object.entries(obj)) {
      newObj[key] = value
    }
    return newObj;
  }
  ```

### 深拷贝的实现

+ 那如何实现一个深拷贝呢？说起来也好简单，我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数不就好了~

  ```js
  const deepCopy = function(obj) {
    if (typeof obj !== 'object') return;
    const newObj = obj instanceof Array ? [] : {};
    for (const [key,value] of Object.entries(obj)) {
      newObj[key] = typeof value === 'object' ? deepCopy(value) : value
    }
    return newObj;
  }
  ```

+ 注意`null`，可以通过第一层判断，但是Object.entries()无法接受`null`作为参数

  ```js
  console.log(deepCopy(null))
  // TypeError: Cannot convert undefined or null to object at Function.entries (<anonymous>)
  ```

+ 如果使用ES5 API 则会赋值为一个空对象

## extend

### 基本用法

+ jQuery 的 extend 是 jQuery 中应用非常多的一个函数，今天我们一边看 jQuery 的 extend 的特性，一边实现一个 extend!

+ 先来看看 extend 的功能，合并两个或者更多的对象的内容到第一个对象中。

  ```js
  jQuery.extend( target [, object1 ] [, objectN ] )
  ```

+ 第一个参数 target，表示要拓展的目标，我们就称它为目标对象吧。

+ 后面的参数，都传入对象，内容都会复制到目标对象中，我们就称它们为待复制对象吧。

+ 当两个对象出现相同字段的时候，后者会覆盖前者，**不会进行深层次的覆盖**。

  ```js
  var obj1 = {
    a: 1,
    b: { b1: 1, b2: 2 }
  };
  
  var obj2 = {
    b: { b1: 3, b3: 4 },
    c: 3
  };
  
  var obj3 = {
    d: 4
  }
  
  console.log($.extend(obj1, obj2, obj3));
  
  // {
  //    a: 1,
  //    b: { b1: 3, b3: 4 },
  //    c: 3,
  //    d: 4
  // }
  ```

### extend 第一版

+ ```js
  function extend(target, ...options) {
    const len = options.length;
    for (let i = 0; i < len; i++) {
      option = options[i]
      if (option != null) {
        for (let [key, value] of Object.entries(option)) {
          if (value !== undefined) {
            target[key] = value;
          }
        }
      }
      return target
    }
  }
  ```

### extend 深拷贝

+ 那如何进行深层次的复制呢？jQuery v1.1.4 加入了一个新的用法：

  ```
  jQuery.extend( [deep], target, object1 [, objectN ] )
  ```

+ 也就是说，函数的第一个参数可以传一个布尔值，如果为 true，我们就会进行深拷贝，false 依然当做浅拷贝，这个时候，target 就往后移动到第二个参数。

  ```js
  var obj1 = {
    a: 1,
    b: { b1: 1, b2: 2 }
  };
  
  var obj2 = {
    b: { b1: 3, b3: 4 },
    c: 3
  };
  
  var obj3 = {
    d: 4
  }
  
  console.log($.extend(true, obj1, obj2, obj3));
  
  // {
  //    a: 1,
  //    b: { b1: 3, b2: 2, b3: 4 },
  //    c: 3,
  //    d: 4
  // }
  ```

+ 因为采用了深拷贝，会遍历到更深的层次进行添加和覆盖。

### extend 第二版

+ 我们来实现深拷贝的功能，值得注意的是：根据 copy 的类型递归 extend。
	```js
	function deepExtend(target,...options) {
	  var len = options.length;
	  // 循环遍历要复制的对象们
  for (let i = 0; i < len; i++) {
      option = options[i];
      // 要求不能为空 避免 deepExtend(a,,b) 这种情况
      if (option != null) {
        for (let [key,value] of Object.entries(option)) {
          if (value && typeof value == 'object') {
            // 是对象，进行递归调用
            target[key] = deepExtend(target[key], value)
          }
          else if (value !== undefined){
            // 不是对象，直接赋值
            target[key] = value
          }
        }
      }
    }
    return target;
  };
  ```
  
+ 在实现上，核心的部分还是跟上篇实现的深浅拷贝函数一致，如果要复制的对象的属性值是一个对象，就递归调用 extend。

### Object.assign

- `Object.assign`方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。

- 该方法的引入目的，主要是为了解决`Object.assign()`无法正确拷贝`get`属性和`set`属性的问题。

  - 上面代码中，`source`对象的`foo`属性的值是一个赋值函数，`Object.assign`方法将这个属性拷贝给`target1`对象，结果该属性的值变成了`undefined`。这是因为`Object.assign`方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。
  - 这时，`Object.getOwnPropertyDescriptors()`方法配合`Object.defineProperties()`方法，就可以实现正确拷贝。

  ```js
  const source = {
    set foo(value) {
      console.log(value);
    }
  };
  
  const target2 = {};
  Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
  Object.getOwnPropertyDescriptor(target2, 'foo')
  // { get: undefined,
  //   set: [Function: set foo],
  //   enumerable: true,
  //   configurable: true }
  
  // 合并两个函数
  const shallowMerge = (target, source) => Object.defineProperties(
    target,
    Object.getOwnPropertyDescrptors(source)
  );
  ```

### 优化

#### target 是函数

+ 在我们的实现中，`typeof target` 必须等于 `object`，我们才会在这个 `target` 基础上进行拓展，然而我们用 `typeof` 判断一个函数时，会返回`function`，也就是说，我们无法在一个函数上进行拓展！
+ 当然啦，毕竟函数也是一种对象嘛。
+ 函数的静态属性也是非常重要的

#### 类型不一致

+ 其实我们实现的方法有个小 bug ，不信我们写个 demo:

  ```js
  var obj1 = {
    a: 1,
    b: {
      c: 2
    }
  }
  
  var obj2 = {
    b: {
      c: [5],
  
    }
  }
  
  var d = extend(true, obj1, obj2)
  console.log(d);
  ```

+ 我们预期会返回这样一个对象：

  ```js
  {
    a: 1,
    b: {
      c: [5]
    }
  }
  ```

+ 实际返回了

  ```js
  {
    a: 1,
    b: {
      c: {
        0: 5
      }
    }
  }
  ```

+ 第三遍进行最终的赋值，因为 src 是一个基本类型，我们默认使用一个空对象作为目标值，所以最终的结果就变成了对象的属性！

+ 为了解决这个问题，我们需要对目标属性值和待复制对象的属性值进行判断。

+ 判断目标属性值跟要复制的对象的属性值类型是否一致:

  - 如果待复制对象属性值类型为数组，目标属性值类型不为数组的话，目标属性值就设为 []
  - 如果待复制对象属性值类型为对象，目标属性值类型不为对象的话，目标属性值就设为 {}

  ```js
  for (let [key,value] of Object.entries(option)) {
    // 排除null和undefined
    if (value && typeof value == 'object') {
      if(Array.isArray(value)){
        // 如果值是数组，保证target也是数组
        target[key] = Array.isArray(target[key])?target[key]:[]
      }
      // 进行递归调用
      target[key] = deepExtend(target[key], value)
    }
    else if (value !== undefined){
      // 不是对象，直接赋值
      target[key] = value
    }
  }
  ```

### 循环引用

+ 实际上，我们还可能遇到一个循环引用的问题，举个例子：

  ```js
  var a = {name : null}
  var b = {name : null}
  a.name = b
  b.name = a
  console.log(deepExtend(a, b))
  ```

+ 我们会得到一个可以无限展开的对象，类似于这样：

  ![å¾ªç¯å¼ç¨å¯¹è±¡](https://github.com/mqyqingfeng/Blog/raw/master/Images/extend/extend1.png)

+ 为了避免这个问题，我们需要判断要复制的对象属性是否等于 target，如果等于，我们就跳过：

  ```js
  // 对象可能存在循环引用，此时应该跳过
  if (target === value) {
    continue;
  }
  ```

### 最终代码

+ ```js
  function deepExtend(target,...options) {
    var len = options.length;
    // 如果target不是对象，我们是无法进行复制的，所以设为{}
    if (typeof target !== 'object') {
      target = {}
    }
    // 循环遍历要复制的对象们
    for (let i = 0; i < len; i++) {
      option = options[i];
      // 要求不能为空 避免 deepExtend(a,,b) 这种情况
      if (option != null) {
        for (let [key,value] of Object.entries(option)) {
          // 排除null和undefined
          if (value && typeof value == 'object') {
            // 对象可能存在循环引用，此时应该跳过
            if(target === value) continue
  
            // 如果值是数组，保证target也是数组
            if(Array.isArray(value)) target[key] = Array.isArray(target[key])?target[key]:[]
  
            // 进行递归调用
            target[key] = deepExtend(target[key], value)
          }else if (value !== undefined){
            // 不是对象，直接赋值
            target[key] = value
          }
        }
      }
    }
    return target;
  };
  ```

### 思考题

+ 如果觉得看明白了上面的代码，想想下面两个 demo 的结果：

  ```js
  var a = extend(true, [4, 5, 6, 7, 8, 9], [1, 2, 3]);
  console.log(a) // ??? 
  ```

  ![1563081418013](F:\OneDrive\JS\assets\1563081418013.png)

+ ```js
  var obj1 = {
    value: {
      3: 1
    }
  }
  var obj2 = {
    value: [5, 6, 7],
  }
  
  var b = extend(true, obj1, obj2) // ??? {value:[5,6,7]}
  var c = extend(true, obj2, obj1) // ??? {value:[5,6,7,1]}
  ```



## 私有属性

### Symbol的遍历

- Symbol 作为属性名，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。

- 但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols`方法，可以获取指定对象的所有 Symbol 属性名。

- `Object.getOwnPropertySymbols`方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。

  ```javascript
  const obj = {};
  let a = Symbol('a');
  let b = Symbol('b');
  
  obj[a] = 'Hello';
  obj[b] = 'World';
  
  const objectSymbols = Object.getOwnPropertySymbols(obj);
  
  objectSymbols
  // [Symbol(a), Symbol(b)]
  ```

- 下面是另一个例子，`Object.getOwnPropertySymbols`方法与`for...in`循环、`Object.getOwnPropertyNames`方法进行对比的例子。

  ```javascript
  const obj = {};
  
  let foo = Symbol("foo");
  
  Object.defineProperty(obj, foo, {
    value: "foobar",
  });
  
  for (let i in obj) {
    console.log(i); // 无输出
  }
  
  Object.getOwnPropertyNames(obj)
  // []
  
  Object.getOwnPropertySymbols(obj)
  // [Symbol(foo)]
  
  // 上面代码中，使用Object.getOwnPropertyNames方法得不到Symbol属性名，需要使用Object.getOwnPropertySymbols方法。
  ```

- 另一个新的 API，`Reflect.ownKeys`方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。

  ```javascript
  let obj = {
    [Symbol('my_key')]: 1,
    enum: 2,
    nonEnum: 3
  };
  
  Reflect.ownKeys(obj)
  //  ["enum", "nonEnum", Symbol(my_key)]
  ```

- 由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些**非私有的**、但又希望**只用于内部**的方法。

  ```javascript
  let size = Symbol('size');
  
  class Collection {
    constructor() {
      this[size] = 0;
    }
  
    add(item) {
      this[this[size]] = item;
      this[size]++;
    }
  
    static sizeOf(instance) {
      return instance[size];
    }
  }
  
  let x = new Collection();
  Collection.sizeOf(x) // 0
  
  x.add('foo'); x.add('foo'); // 为x添加了一个'0'属性
  Collection.sizeOf(x) // 1
  
  Object.keys(x) // ['0']
  Object.getOwnPropertyNames(x) // ['0']
  Object.getOwnPropertySymbols(x) // [Symbol(size)]
  ```

- 上面代码中，对象`x`的`size`属性是一个 Symbol 值，所以`Object.keys(x)`、`Object.getOwnPropertyNames(x)`都无法获取它。这就造成了一种非私有的内部方法的效果。

### 私有属性

+ WeakMap 也可以被用于实现私有变量，不过在 ES6 中实现私有变量的方式有很多种，这只是其中一种：

  ```
  const _counter = new WeakMap();
  const _action = new WeakMap();
  
  class Countdown {
    constructor(counter, action) {
      _counter.set(this, counter);
      _action.set(this, action);
    }
    dec() {
      let counter = _counter.get(this);
      if (counter < 1) return;
      counter--;
      _counter.set(this, counter);
      if (counter === 0) {
        _action.get(this)();
      }
    }
  }
  
  const c = new Countdown(2, () => console.log('DONE'));
  
  c.dec()
  c.dec()
  // DONE
  ```

+ 上面代码中，`Countdown`类的两个内部属性`_counter`和`_action`，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。

# 功能性实现

## co 模块

### 基本用法

- [co 模块](https://github.com/tj/co)是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。

- 下面是一个 Generator 函数，用于依次读取两个文件。

  ```javascript
  var gen = function* () {
    var f1 = yield readFile('/etc/fstab');
    var f2 = yield readFile('/etc/shells');
    console.log(f1.toString());
    console.log(f2.toString());
  };
  ```

- co 模块可以让你不用编写 Generator 函数的执行器。

  ```javascript
  var co = require('co');
  co(gen);
  ```

- 上面代码中，Generator 函数只要传入`co`函数，就会自动执行。

- `co`函数返回一个`Promise`对象，因此可以用`then`方法添加回调函数。

  ```javascript
  co(gen).then(function (){
    console.log('Generator 函数执行完成');
  });
  ```

- 上面代码中，等到 Generator 函数执行结束，就会输出一行提示。

### co 模块的原理

- 为什么 co 可以自动执行 Generator 函数？

- 前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。

- 两种方法可以做到这一点。 #

  （1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。

  （2）Promise 对象。将异步操作包装成 Promise 对象，用`then`方法交回执行权。

- co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的`yield`命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。

- 上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。

### 基于 Promise 对象的自动执行

- 还是沿用上面的例子。首先，把`fs`模块的`readFile`方法包装成一个 Promise 对象。

  ```javascript
  var fs = require('fs');
  
  var readFile = function (fileName){
    return new Promise(function (resolve, reject){
      fs.readFile(fileName, function(error, data){
        if (error) return reject(error);
        resolve(data);
      });
    });
  };
  
  var gen = function* (){
    var f1 = yield readFile('/etc/fstab');
    var f2 = yield readFile('/etc/shells');
    console.log(f1.toString());
    console.log(f2.toString());
  };
  ```

- 然后，手动执行上面的 Generator 函数。

  ```javascript
  var g = gen();
  // value值才是promise
  g.next().value.then(function(data){
    g.next(data).value.then(function(data){
      g.next(data);
    });
  });
  ```

- 手动执行其实就是用`then`方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。

- ```javascript
  function run(gen){
    var g = gen();
  
    function next(data){
      var result = g.next(data);
      if (result.done) return result.value;
      result.value.then(function(data){
        next(data);
      });
    }
  
    next();
  }
  
  run(gen);
  ```

- 上面代码中，只要 Generator 函数还没执行到最后一步，`next`函数就调用自身，以此实现自动执行。

### co 模块的源码

- co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。

- 首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。

  ```javascript
  function co(gen) {
    var ctx = this;
  
    return new Promise(function(resolve, reject) {
    });
  }
  ```

- 在返回的 Promise 对象里面，co 先检查参数`gen`是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为`resolved`。

  ```javascript
  function co(gen) {
    var ctx = this;
  
    return new Promise(function(resolve, reject) {
      if (typeof gen === 'function') gen = gen.call(ctx);
      if (!gen || typeof gen.next !== 'function') return resolve(gen);
    });
  }
  ```

- 接着，co 将 Generator 函数的内部指针对象的`next`方法，包装成`onFulfilled`函数。这主要是为了能够**捕捉抛出的错误**。

  ```javascript
  function co(gen) {
    var ctx = this;
  
    return new Promise(function(resolve, reject) {
      if (typeof gen === 'function') gen = gen.call(ctx);
      if (!gen || typeof gen.next !== 'function') return resolve(gen);
  
      onFulfilled();
      function onFulfilled(res) {
        var ret;
        try {
          ret = gen.next(res);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
    });
  }
  ```

- 最后，就是关键的`next`函数，它会反复调用自身。

  ```javascript
  function next(ret) {
    if (ret.done) return resolve(ret.value);
    var value = toPromise.call(ctx, ret.value);
    if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
    return onRejected(
      new TypeError(
        'You may only yield a function, promise, generator, array, or object, '
        + 'but the following object was passed: "'
        + String(ret.value)
        + '"'
      )
    );
  }
  ```

- 上面代码中，`next`函数的内部代码，一共只有四行命令。

- 第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。

- 第二行，确保每一步的返回值，是 Promise 对象。

- 第三行，使用`then`方法，为返回值加上回调函数，然后通过`onFulfilled`函数再次调用`next`函数。

- 第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为`rejected`，从而终止执行。

### 处理并发的异步操作

- co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。

- 这时，要把**并发的操作都放在数组或对象里面**，跟在`yield`语句后面。

  ```javascript
  // 数组的写法
  co(function* () {
    var res = yield [
      Promise.resolve(1),
      Promise.resolve(2)
    ];
    console.log(res);
  }).catch(onerror);
  
  // 对象的写法
  co(function* () {
    var res = yield {
      1: Promise.resolve(1),
      2: Promise.resolve(2),
    };
    console.log(res);
  }).catch(onerror);
  ```

- 下面是另一个例子。

  ```javascript
  co(function* () {
    var values = [n1, n2, n3];
    yield values.map(somethingAsync);
  });
  
  function* somethingAsync(x) {
    // do something async
    return y
  }
  ```

- 上面的代码允许并发三个`somethingAsync`异步操作，等到它们全部完成，才会进行下一步。

### 实例：处理 Stream

- Node 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件。

  - `data`事件：下一块数据块已经准备好了。
  - `end`事件：整个“数据流”处理完了。
  - `error`事件：发生错误。

- 使用`Promise.race()`函数，可以判断这三个事件之中哪一个最先发生，只有当`data`事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个`while`循环，完成所有数据的读取。

  ```javascript
  const co = require('co');
  const fs = require('fs');
  
  const stream = fs.createReadStream('./les_miserables.txt');
  let valjeanCount = 0;
  
  co(function*() {
    while(true) {
      const res = yield Promise.race([
        new Promise(resolve => stream.once('data', resolve)),
        new Promise(resolve => stream.once('end', resolve)),
        new Promise((resolve, reject) => stream.once('error', reject))
      ]);
      if (!res) {
        break;
      }
      stream.removeAllListeners('data');
      stream.removeAllListeners('end');
      stream.removeAllListeners('error');
      valjeanCount += (res.toString().match(/valjean/ig) || []).length;
    }
    console.log('count:', valjeanCount); // count: 1120
  });
  ```

- 上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用`stream.once`方法，在`data`、`end`、`error`三个事件上添加一次性回调函数。变量`res`只有在`data`事件发生时才有值，然后累加每个数据块之中`valjean`这个词出现的次数。

## async 函数的实现原理

- async 函数的实现原理，就是将 **Generator 函数和自动执行器**，包装在一个函数里。

  ```javascript
  async function fn(args) {
    // ...
  }
  
  // 等同于
  
  function fn(args) {
    return spawn(function* () {
      // ...
    });
  }
  ```

- 所有的`async`函数都可以写成上面的第二种形式，其中的**`spawn`函数就是自动执行器**。

- 下面给出`spawn`函数的实现，基本就是前文自动执行器的翻版。

  ```javascript
  function spawn(genF) {
    // 接受一个Generator函数，返回一个Promise对象
    return new Promise(function(resolve, reject) {
      // 获取指针对象
      const gen = genF();
      // step函数，用于不断调用指针对象的next方法
      // 它接受一个函数作为参数，函数返回指针对象next方法的执行结果
      // 即：{value，done}
      // 第一次调用next方法，启动Generator函数的指针
      step(function() { return gen.next(undefined); });
      function step(nextF) {
        let next;
        try {
          // 函数的返回结果：{value,done}
          next = nextF();
        } catch(e) {
          return reject(e);
        }
        if(next.done) {
          // 如果done 为true，指针已经到了底部
          return resolve(next.value);
        }
        // 指针未到底部，继续执行next方法
        // 使用Promise.resolve，传入next.value
        // 获得一个promise 对象Promise.resolve(next.value)，状态为resolved
        // then 方法自动执行，把获取到的value传递给next方法，作为上一次yield的返回值
        Promise.resolve(next.value).then(function(v) {
          step(function() { return gen.next(v); });
        }, function(e) {
          step(function() { return gen.throw(e); });
        });
      }
    });
  }
  ```

## 防抖

- 防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!

### 初步实现

- ```js
  function debounce(func,wait){
    let timeout
    return function(){
      clearTimeout(timeout)
      timeout = setTimeout(func,wait)
    }
  }
  ```

### 完善

- this 的指向问题，因为涉及到了定时器

  ```js
    let count = 1;
    const container = document.getElementById('container');
  
    function getUserAction() {
        container.innerHTML = count++;
        console.log(this)
    };
  
    function debounce(func,wait){
      let timeout
      return function(){
        clearTimeout(timeout)
        timeout = setTimeout(() => {
          func.call(this)
        },wait)
      }
    }
  
    container.onmousemove = debounce(getUserAction,1000);
  ```

- 不使用箭头函数的话，需要主动绑定this

  ```js
    function debounce(func,wait){
      let timeout
      return function(){
        const ctx = this // 事件回调函数指向正确的this
        clearTimeout(timeout)
        timeout = setTimeout(function() {
          func.call(ctx) // 调用call和apply方法的同时会执行函数，所以必须包裹在一个匿名函数内
        },wait)
      }
    }
  ```

- 事件event对象的缺失

  ```js
    function debounce(func,wait){
      let timeout
      return function(ev){
        clearTimeout(timeout)
        timeout = setTimeout(() => {
          func.call(this,ev)
        },wait)
      }
    }
  ```

- 关键是意识到真正作为回调函数的是 debounce函数的返回值，所以这个函数有着正确的this指向和传入的参数

### 需求

#### 立即触发

- 希望第一次可以立即触发函数，如果频繁触发，则需要在停止触发n秒后才可以继续触发

  ```js
  function debounce(func, wait, immediate) {
  
    var timeout;
    var first  = true
    var callNow = false
    return function () {
      var context = this;
      var args = arguments;
  
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        timeout = setTimeout(function(){
          callNow = true;
        }, wait)
        // 保证第一次执行，和之后可以重复执行
        if (first || callNow){
          func.apply(context, args)
          first = false
          callNow = false
        }
      }
      else {
        timeout = setTimeout(function(){
          func.apply(context, args)
        }, wait);
      }
    }
  }
  ```

- 利用定时器的返回值的特性，减少变量

  ```js
  function debounce(func, wait, immediate) {
  
    var timeout;
  
    return function () {
      var context = this;
      var args = arguments;
  
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        // timeout的值不为0，说明开启了定时器，不可执行
        var callNow = !timeout;
        // 只要在wait时间内不再触发事件，timeout会从一个数字（定时器编号）变成null
        timeout = setTimeout(function(){
          timeout = null;
        }, wait)
        if (callNow) func.apply(context, args)
      }
      else {
        timeout = setTimeout(function(){
          func.apply(context, args)
        }, wait);
      }
    }
  }
  ```

#### 取消防抖

- 希望能取消 debounce 函数，比如说我 debounce 的时间间隔是 10 秒钟，immediate 为 true，这样的话，我只有等 10 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行啦

  ```js
  function debounce(func, wait, immediate) {
  
    var timeout, result;
  
    var debounced = function () {
      var context = this;
      var args = arguments;
  
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        // 如果已经执行过，不再执行
        var callNow = !timeout;
        timeout = setTimeout(function(){
          timeout = null;
        }, wait)
        if (callNow) result = func.apply(context, args)
      }
      else {
        timeout = setTimeout(function(){
          func.apply(context, args)
        }, wait);
      }
      return result;
    };
  
    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };
  
    return debounced;
  }
  ```

- 使用

  ```js
  var count = 1;
  var container = document.getElementById('container');
  
  function getUserAction(e) {
    container.innerHTML = count++;
  };
  
  var setUseAction = debounce(getUserAction, 10000, true);
  
  container.onmousemove = setUseAction;
  
  document.getElementById("button").addEventListener('click', function(){
    setUseAction.cancel();
  })
  ```

### 返回值

- 虽然说一般事件绑定函数是没有返回值的，因为传入的是一个回调函数，想要获得回调函数的处理结果需要再传入一个回调函数接受这个结果，但是这样没办法再 immediate 为 false 的时候获得返回值，因为定时器的this指向window，且不接受额外的回调函数，最好的方法还是使用 promise

### 对比

+ 前面的防抖表现为：停止一段时间后，由定时器触发
+ 需求内的防抖变成了：立即执行，停止一段时间后，才可以再去触发
+ 后一种情况才是实际中更加多见的吧

## 节流 #

- 节流的原理很简单：如果你持续触发事件，每隔一段时间，只执行一次事件。
- 根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。
- 关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。

### 使用时间戳

- 使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。

- ```js
  let count = 1;
  const container = document.getElementById('container');
  
  function getUserAction(ev) {
    container.innerHTML = count++;
    // console.log(this)
    console.log(ev)
  };
  
  function throttle (func,wait){
    let ctx
    let prev = 0
  
    return function(...args){
      // 返回的是时间戳对象，先转换为数字
      let now = +new Date()
      ctx = this
      if(now - prev > wait){
        func.apply(ctx,args)
        prev = now
      }
    }
  
  }
  
  container.onmousemove = throttle(getUserAction,1000);
  ```

- 当鼠标移入的时候，事件立刻执行，每过 1s 会执行一次，如果在 4.2s 停止触发，以后不会再执行事件。

### 使用定时器

- 当触发事件的时候，我们设置一个定时器，**再**触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。

  ```js
  function throttle(func, wait) {
    var timeout;
  
    return function() {
      context = this;
      args = arguments;
      // timeout 为 null 的时候会启动一个定时器
      // 除非定时器执行，否则无法开启下一个定时器
      if (!timeout) {
        timeout = setTimeout(function(){
          timeout = null;
          func.apply(context, args)
        }, wait)
      }
    }
  }
  ```
  
- 当鼠标移入的时候，事件不会立刻执行，晃了 3s 后终于执行了一次，此后每 3s 执行一次，当数字显示为 3 的时候，立刻移出鼠标，相当于大约 9.2s 的时候停止触发，但是依然会在第 12s 的时候执行一次事件。

- 所以比较两个方法：

  1. 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行
  2. 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件

### 各取所长

- 可能会有这样的需求：就是鼠标移入能立刻执行，停止触发的时候还能再执行一次

  ```js
  function throttle(func, wait) {
    var timeout, context, args, result;
    var previous = 0;
  
    var throttled = function () {
      var now = +new Date();
      //下次触发 func 剩余的时间
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      // 如果没有剩余的时间了或者你改了系统时间
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          // 防止重复触发，剩余时间小于0，说明定时器马上就要执行了
          // 由于事件循环机制可能造成的误差
          clearTimeout(timeout);
          timeout = null;
          console.log('in timeout')
        }
        // 头执行
        previous = now;
        func.apply(context, args);
      } else if (!timeout) {
        // 中间节流和尾执行 调用 later 传入剩余时间
        // 还有剩余时间，且上一次设置的定时器已经执行完毕
        // 频繁触发时 remaining 都是差不多的值 990+
        timeout = setTimeout(later, remaining);
        console.log(remaining)
      }
    };
  
    var later = function () {
      // 本来 时间戳 部分的逻辑 也可以做到中间节流的，但是每次都被later抢先了
      previous = +new Date();
      timeout = null;
      func.apply(context, args)
    };
  
    return throttled;
  }
  ```

- 但是我有时也希望无头有尾，或者有头无尾，这个咋办？

- 那我们设置个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定:

- leading：false 表示禁用第一次执行

- trailing: false 表示禁用停止触发的回调

  ```js
  function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};
  
    var later = function() {
      // 不需要leading，previous为0，需要leading，previous为 时间戳
      previous = options.leading === false ? 0 : new Date().getTime();
      timeout = null;
      func.apply(context, args);
      // 防止内存泄漏
      context = args = null;
    };
  
    var throttled = function() {
      var now = new Date().getTime();
      // previous为0 不需要leading
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
    };
    return throttled;
  }
  ```

- https://github.com/mqyqingfeng/Blog/issues/26

## 函数库骨架

### 自己实现

+ 如果是我们自己去组织这些函数，我们该怎么做呢？我想我会这样做：

  ```js
  (function(){
    var root = this;
  
    var _ = {};
  
    root._ = _;
  
    // 在这里添加自己的方法
    _.reverse = function(string){
      return string.split('').reverse().join('');
    }
  
  })()
  
  _.reverse('hello');
  => 'olleh'
  ```

+ 我们将所有的方法添加到一个名为 `_` 的对象上，然后将该对象挂载到全局对象上。

+ 之所以不直接 `window._ = _` 是因为我们写的是一个工具函数库，不仅要求可以运行在浏览器端，还可以运行在诸如 Node 等环境中。

### root

+ 然而 underscore 可不会写得如此简单，我们从 `var root = this` 开始说起。

+ 之所以写这一句，是因为我们要通过 this 获得全局对象，然后将 `_` 对象，挂载上去。

+ 然而在严格模式下，this 返回 undefined，而不是指向 Window，幸运的是 underscore 并没有采用严格模式，可是即便如此，也不能避免，因为在 ES6 中模块脚本自动采用严格模式，不管有没有声明 `use strict`。

+ 如果 this 返回 undefined，代码就会报错，所以我们的思路是对环境进行检测，然后挂载到正确的对象上。我们修改一下代码：

  ```js
  var root = (typeof window == 'object' && window.window == window && window) ||
             (typeof global == 'object' && global.global == global && global);
  ```

+ 在这段代码中，我们判断了浏览器和 Node 环境，可是只有这两个环境吗？那我们来看看 Web Worker。

### Web Worker

+ Web Worker 属于 HTML5 中的内容，引用《JavaScript权威指南》中的话就是：

  > 在 Web Worker 标准中，定义了解决客户端 JavaScript 无法多线程的问题。其中定义的 “worker” 是指执行代码的并行过程。不过，Web Worker 处在一个自包含的执行环境中，无法访问 Window 对象和 Document 对象，和主线程之间的通信业只能通过异步消息传递机制来实现。

+ 在 Web Worker 中，是无法访问 Window 对象的，所以 `typeof window` 和 `typeof global` 的结果都是 `undefined`，所以最终 root 的值为 false，将一个基本类型的值像对象一样添加属性和方法，自然是会报错的。

+ 虽然在 Web Worker 中不能访问到 Window 对象，但是我们却能通过` self `访问到 Worker 环境中的全局对象。我们只是要找全局变量挂载而已，所以完全可以挂到 self 中嘛。

+ 而且在浏览器中，除了 window 属性，我们也可以通过 self 属性直接访问到 Winow 对象。

  ```js
  console.log(window.window === window); // true
  console.log(window.self === window); // true
  ```

+ 考虑到使用 self 还可以额外支持 Web Worker，我们直接将代码改成 self：

  ```js
  var root = (typeof self == 'object' && self.self == self && self) ||
             (typeof global == 'object' && global.global == global && global);
  ```

### node vm

+ 到了这里，依然没完，让你想不到的是，在 node 的 vm 模块中，也就是沙盒模块，runInContext 方法中，是不存在 window，也不存在 global 变量的，[查看代码](https://github.com/mqyqingfeng/Blog/blob/master/demos/node-vm/index.js)。

+ 但是我们却可以通过 this 访问到全局对象，所以就有人发起了一个 PR，代码改成了：

  ```js
  var root = (typeof self == 'object' && self.self == self && self) ||
             (typeof global == 'object' && global.global == global && global) ||
             this;
  ```

### 微信小程序

+ 到了这里，还是没完，轮到微信小程序登场了。

+ 因为在微信小程序中，window 和 global 都是 undefined，加上又强制使用严格模式，this 为 undefined，挂载就会发生错误，所以就有人又发了一个 PR，代码变成了：

  ```js
  var root = (typeof self == 'object' && self.self == self && self) ||
             (typeof global == 'object' && global.global == global && global) ||
             this ||
             {};
  ```

+ 这就是现在 v1.8.3 的样子。

+ 虽然作者可以直接讲解最终的代码，但是作者更希望带着大家看看这看似普通的代码是如何一步步演变成这样的，也希望告诉大家，代码的健壮性，并非一蹴而就，而是汇集了很多人的经验，考虑到了很多我们意想不到的地方，这也是开源项目的好处吧。

### 函数对象

+ 现在我们讲第二句 `var _ = {};`

+ 如果仅仅设置 _ 为一个空对象，我们调用方法的时候，只能使用 `_.reverse('hello')` 的方式，实际上，underscore 也支持类似面向对象的方式调用，即：

  ```js
  _('hello').reverse(); // 'olleh'
  ```

+ 再举个例子比较下两种调用方式：

  ```js
  // 函数式风格
  _.each([1, 2, 3], function(item){
      console.log(item)
  });
  
  // 面向对象风格
  _([1, 2, 3]).each(function(item){
      console.log(item)
  });
  ```

+ 可是该如何实现呢？

+ 既然以 `_([1, 2, 3])` 的形式可以执行，就表明 `_` 不是一个字面量对象，而是一个函数！

+ 幸运的是，在 JavaScript 中，函数也是一种对象，我们完全可以将自定义的函数定义在 `_` 函数上！

**目前的写法**

+ ```js
  var root = (typeof self == 'object' && self.self == self && self) ||
             (typeof global == 'object' && global.global == global && global) ||
             this ||
             {};
  
  var _ = function() {}
  
  root._ = _;
  ```

+ 如何做到 `_([1, 2, 3]).each(...)`呢？即 _ 函数返回一个对象，这个对象，如何调用挂在 _ 函数上的方法呢？

+ 我们看看 underscore 是如何实现的：

  ```js
  var _ = function(obj) {
      if (!(this instanceof _)) return new _(obj);
      this._wrapped = obj;
  };
  
  _([1, 2, 3]);
  ```

+ 我们分析下 `_([1, 2, 3])` 的执行过程：

  1. 执行 `this instanceof _`，this 指向 window ，`window instanceof _` 为 false，`!`操作符取反，所以执行 `new _(obj)`。
  2. `new _(obj)` 中，this 指向实例对象，`this instanceof _` 为 true，取反后，代码接着执行
  3. 执行 `this._wrapped = obj`， 函数执行结束
  4. 总结，`_([1, 2, 3])` 返回一个对象，为 `{_wrapped: [1, 2, 3]}`，该对象的原型指向 _.prototype

+ 示意图如下：

  ![_()ç¤ºæå¾](https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/underscore/new-obj.png)

+ 然后问题来了，我们是将方法挂载到 _ 函数对象上，并没有挂到函数的原型上呐，所以返回了的实例，其实是无法调用 _ 函数对象上的方法的！

+ 所以我们还需要一个方法将 _ 上的方法复制到 `_.prototype` 上，这个方法就是 `_.mixin`。

### _.functions

+ 为了将 _ 上的方法复制到原型上，首先我们要获得 _ 上的方法，所以我们先写个 `_.functions` 方法。

  ```js
  _.functions = function(obj) {
      var names = [];
      for (var key in obj) {
          if (_.isFunction(obj[key])) names.push(key);
      }
      return names.sort();
  };
  ```

+ isFunction 函数可以参考 [《JavaScript专题之类型判断(下)》](https://github.com/mqyqingfeng/Blog/issues/28)

### mixin

+ 现在我们可以写 mixin 方法了。

  ```js
  var ArrayProto = Array.prototype;
  var push = ArrayProto.push;
  
  _.mixin = function(obj) {
    	const funcs = _.functions(obj)
      for(left [key,func] of Object.ectries(funcs)){
        _.prototype[key] = function(...rest) {
              var args = [this._wrapped];
              return func.apply(_, [...args,...rest]);
          };
      }
      return _;
  };
  
  _.mixin(_);
  ```

+ 值得注意的是：因为 `_[name] = obj[name]` 的缘故，我们可以给 underscore 拓展自定义的方法:

  ```js
  _.mixin({
    addOne: function(num) {
      return num + 1;
    }
  });
  
  _(2).addOne(); // 3
  ```

+ 至此，我们算是实现了同时支持面向对象风格和函数风格。

### 导出

+ 终于到了讲最后一步 `root._ = _`，我们直接看源码：

  ```js
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }
  ```

+ 为了支持模块化，我们需要将 _ 在合适的环境中作为模块导出，但是 nodejs 模块的 API 曾经发生过改变，比如在早期版本中：

  ```js
  // add.js
  exports.addOne = function(num) {
    return num + 1
  }
  
  // index.js
  var add = require('./add');
  add.addOne(2);
  ```

+ 在新版本中：

  ```js
  // add.js
  module.exports = function(1){
      return num + 1
  }
  
  // index.js
  var addOne = require('./add.js')
  addOne(2)
  ```

+ 所以我们根据 exports 和 module 是否存在来选择不同的导出方式，那为什么在新版本中，我们还要使用 `exports = module.exports = _` 呢？

+ 这是因为在 nodejs 中，exports 是 module.exports 的一个引用，当你使用了 module.exports = function(){}，实际上覆盖了 module.exports，但是 exports 并未发生改变，为了避免后面再修改 exports 而导致不能正确输出，就写成这样，将两者保持统一。

+ 最后为什么要进行一个 exports.nodeType 判断呢？这是因为如果你在 HTML 页面中加入一个 id 为 exports 的元素，比如

  ```html
  <div id="exports"></div>
  ```

+ 就会生成一个 window.exports 全局变量，你可以直接在浏览器命令行中打印该变量。

+ 此时在浏览器中，`typeof exports != 'undefined'` 的判断就会生效，然后 `exports._ = _`，然而在浏览器中，我们需要将 _ 挂载到全局变量上呐，所以在这里，我们还需要进行一个是否是 DOM 节点的判断。