---
layout: post
#标题配置
title:  逻辑算法
#时间配置
date:   2019-8-8 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note base
---


# 复杂度

## 复杂度分析

- **复杂度**也叫**渐进复杂度**，包括**时间复杂度**和**空间复杂度**，一个表示执行的快慢，一个表示内存的消耗，用来分析算法执行效率与数据规模之间的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。

### 为什么需要复杂度分析

- 学习数据和算法就是为了解“快”和“省”的问题，也就是如何设计你的代码才能使运算效率更快，占用空间更小。那如何来计算代码执行效率呢？这里就会用到复杂度分析。
- 虽然我们可以用代码准确的计算出执行时间，但是这也会有很多局限性。
- 数据规模的不同会直接影响到测试结果。比如说同一个排序算法，排序顺序不一样，那么最后的计算效率的结果也会不一样；如果恰好已经是排序好的了数组，那么执行时间就会更短。又比如说如果数据规模比较小的话，测试结果可能也无法反应算法的性能。
- 测试的环境不同也会影响到测试结果。比如说同一套代码分别在 i3 和 i7 处理器上进行测试，那么 i7 上的测试时间肯定会比 i3 上的短。
- 所以需要一个不用准确的测试结果来衡量，就可以粗略地估计代码执行时间的方法。这就是**复杂度分析**。

### 大 O 复杂度表示法

- 以一个例子开始，请估算下面代码的执行时间

  ```js
  function total(n) { // 1
    var sum = 0; // 2
    for (var i = 0; i < n; i++) { // 3
      sum += i; // 4
    } //5 
  } //6
  ```

- 我们假设每行代码执行的时间都一样，记做 t，那么上面的函数中的第 2 行需要 1 个 t 的时间，第 3 行 和 第 4 行分别需要 n 个 t 的时间，那么这段代码总的执行时间为 (2n+1)*t。

- 那么按照上面的分析方法，请估算下面代码的执行时间

  ```js
  function total(n) { // 1
    var sum = 0; // 2
    for (var i = 0; i < n; i++) { // 3 
      for (var j = 0; j < n; j++) { // 4
        sum = sum + i + j; // 5
      }
    }
  }
  ```

- 第 2 行需要一个 t 的时间，第 3 行需要 n 个 t 的时间，第 4 行和第 5 行分别需要 n^2 个的时间，那么这段代码总的执行时间为 (2n^2+n+1)*t 的时间。

- 从数学角度来看，我们可以得出个规律：代码的总执行时间 T(n) 与每行代码的执行次数成正比

- T(n) = O(f(n))

- 在这个公式中，T(n) 表示代码的执行时间；n 表示数据规模的大小；f(n) 表示每行代码执行的**次数总和**；O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

- 所以上边两个函数的执行时间可以标记为 T(n) = O(2n+1) 和 T(n) = O(2n^2+n+1)。这就是**大 O 时间复杂度表示法**，它不代表代码真正的执行时间，而是表示**代码随数据规模增长的变化趋势**，简称**时间复杂度**。

- 而且当 n 很大时，我们可以**忽略常数项**，只保留一个最大量级即可。所以上边的代码执行时间可以简单标记为 T(n) = O(n) 和 T(n) = O(n^2)。

### 时间复杂度分析

- 那如何分析一段代码的时间复杂度呢，可以利用下面的几个方法

#### **加法法则：**

- **总复杂度等于量级最大的那段代码的复杂度。**

- ```js
  function total(n) { 
    // 第一个 for 循环
    var sum1 = 0; 
    for (var i = 0; i < n; i++) {
      for (var j = 0; j < n; j++) {
        sum1 = sum1 + i + j; 
      }
    }
    // 第二个 for 循环
    var sum2 = 0;
    for(var i=0;i<1000;i++) {
      sum2 = sum2 + i;
    }
    // 第三个 for 循环
    var sum3 = 0;
    for (var i = 0; i < n; i++) {
      sum3 = sum3 + i;
    }
  }
  
  ```

- 我们先分别分析每段 for 循环的时间复杂度，再取他们中最大的量级来作为整段代码的时间复杂度。

- 第一段 for 循环的时间复杂度为 O(n^2)。

- 第二段 for 循环执行了 1000 次，是个常数量级，尽管对代码的执行时间会有影响，但是当 n 无限大的时候，就可以忽略。因为它本身对增长趋势没有影响，所以这段代码的时间复杂度可以忽略。

- 第三段 for 循环的时间复杂度为 O(n)。

- 总上，**取最大量级，所以整段代码的时间复杂度为 O(n^2)。**@

#### 乘法法则

- 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

- ```js
  function f(i) {
    var sum = 0;
    for (var j = 0; j < i; j++) {
      sum += i;
    }
    return sum;
  }
  function total(n) {
    var res = 0;
    for (var i = 0; i < n; i++) {
      res = res + f(i); // 调用 f 函数
    }
  }
  ```

- 单独看 total 函数的时间复杂度就是为 T1(n)=O(n)，但是考虑到 f 函数的时间复杂度也为 T2(n)=O(n)。 所以整段代码的时间复杂度为 T(n) = T1(n) * T2(n) = O(n*n)=O(n^2)。

### 常见的时间复杂度分析

- ![img](https://pic3.zhimg.com/80/v2-0725ac96068e0634bfdfda2aa2bab17e_hd.jpg) 
- 如上图可以粗略的分为两类，**多项式量级**和**非多项式量级**。其中，**非多项式量级**只有两个：O(2^n) 和 O(n!) 对应的增长率如下图所示
- ![img](https://pic4.zhimg.com/80/v2-150e16309802ea969940cac4e30385e7_hd.jpg) 
- 当数据规模 n 增长时，**非多项式量级**的执行时间就会急剧增加，所以，**非多项式量级**的代码算法是非常低效的算法。

#### O(1)

- O(1) 只是常量级时间复杂度表示法，并不是代码只有一行，比如说下面这段代码

  ```js
  function total() {
    var sum = 0;
    for(var i=0;i<100;i++) {
      sum += i;
    }
  }
  ```

- 虽然有这么多行，即使 for 循环执行了 100 次，但是代码的执行时间不随 n 的增大而增长，所以这样的代码复杂度就为 O(1)。

#### O(logn)、O(nlogn)@

- 对数阶时间复杂度的常见代码如下

  ```js
  function total1(n) {
    var sum = 0;
    var i = 1;
    while (i <= n) {
      sum += i;
      i = i * 2;
    }
  }
  function total2(n) {
    var sum = 0;
    for (var i = 1; i <= n; i = i * 2) {
      sum += i;
    }
  }
  ```

- 上面两个函数都有一个相同点，变量 i 从 1 开始取值，每循环一次乘以 2，当大于 n 时，循环结束。实际上，i 的取值就是一个等比数列，就像下面这样

- 2^0 2^1 2^2 ... 2^k... 2^x =n;

- 所以只要知道 x 的值，就可以知道这两个函数的执行次数了。那由 2^x = n 可以得出 x = log2^n，所以这两个函数的时间复杂度为 O(log2^n)。

- 再看下面两个函数的时间复杂度

  ```js
  function total1(n) {
    var sum = 0;
    var i = 1;
    while (i <= n) {
      sum += i;
      i = i * 3;
    }
  }
  function total2(n) {
    var sum = 0;
    for (var i = 1; i <= n; i = i * 3) {
      sum += i;
    }
  }
  ```

- 由上可以得知，这两个函数的时间复杂度为 O(log3^n) 。

- 由于我们可以忽略常数，也可以忽略对数中的底数，所以在对数阶复杂度中，统一表示为 O(logn)；那 O(nlogn) 的含义就很明确了，时间复杂度 为O(logn) 的代码执行了 n 次。

#### O(m+n)、O(m*n)@

- ```js
  function total(m,n) {
    var sum1 = 0;
    for (var i = 0; i < n; i++) {
      sum1 += i;
    }
    var sum2 = 0;
    for (var i = 0; i < m; i++) {
      sum2 += i;
    }
    return sum1 + sum2;
  }
  ```

- 因为我们无法评估 m 和 n 谁的量级比较大，所以就**不能忽略掉其中一个**，这个函数的复杂度是有两个数据的量级来决定的，所以此函数的时间复杂度为 O(m+n)；那么 O(m*n) 的时间复杂度类似。

### 空间复杂度分析

- 空间复杂度的话和时间复杂度类似推算即可。 所谓空间复杂度就是**表示算法的存储空间和数据规模之间的关系**。

- 比如说分析下面代码的空间复杂度：

  ```js
  function initArr(n) {
    var arr = [];
    for (var i = 0; i < n; i++) {
      arr[i] = i;
    }
  }
  ```

- 根据时间复杂度的推算，忽略掉常数量级，每次数组赋值都会申请一个空间存储变量，所以此函数的空间复杂度为 O(n)。

- 常见的空间复杂度只有 O(1)、O(n)、O(n^2)。其他的话很少会用到。

### 复杂度优化

- ```js
  function total(n) {
    var sum = 0;
    for (var i = 1; i <= n; i++) {
      sum += i;
    }
    return sum;
  }
  ```

- 此函数的时间复杂度你现在应该很容易就能看出来了，为 O(n)。

- 我觉得这个时间复杂度有点高了，我想要 O(1) 的时间复杂度函数来实现这个算法，可以吗？

- 可以的，小数学神童高斯教会我们一招，如下

  ```js
  function total(n) {
    var sum = n*(n+1)/2
    return sum;
  }
  ```

- 此函数的时间复杂度仅仅为 O(1)，在数据规模比较庞大的时候，下面的函数是不是明显比上面的函数运算效率更高呢。

## 最好、最坏时间复杂度分析

- ```js
  function find(n, x, arr) {
    let ind = -1;
    for (let i = 0; i < n; i++) {
      if (arr[i] === x) ind = i;
    }
    return ind;
  }
  ```

- 上面函数的功能就是查找一个变量 x 是否在 数组 arr 中，如果在的话，返回所在的位置，否则就返回 -1。通过上一节的学习分析，这个函数的时间复杂度就很容易知道了，为 O(n)。

- 接下来，稍微优化下这个 `find` 函数，如果查找到目标的话，就没必要再往后查找了。

  ```js
  function find(n, x, arr) {
    let ind = -1;
    for (let i = 0; i < n; i++) {
      if (arr[i] === x){
        ind = i;
        break;
      } 
    }
    return ind;
  }
  ```

- 现在代码的时间复杂度还为 O(n)吗？不确定，利用上一章的分析法就无法解决了。

- 因为要查找的变量 x 可能会出现在数组的任意位置。如果变量 x 恰好是数组中第一个元素，那么函数就会 `break` ，后续就不会继续遍历了，那时间复杂度就是 O(1)。但如果恰好是数组中第末个元素，或者数组中不存在变量 x 的话，那就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这个函数的时间复杂度是不一样的。

- 为了表示代码在不同情况下的不同时间复杂度，需要了解以下三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度

### 理想情况

- **最好情况时间复杂度**：在最理想的情况下，执行这段代码的时间复杂度。比如说刚才那段函数，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这种情况下对应的时间复杂度就是**最好情况时间复杂度**。

### 糟糕情况

- **最坏情况时间复杂度**：在最糟糕的情况下，执行这段代码的时间复杂度。比如说刚才那段函数，要查找的变量 x 正好是数组的第末个元素或者不在数组中存在 ，查找函数就会把数组都遍历一遍，这种情况下对应的时间复杂度就是**最坏情况时间复杂度**。

### 平均情况

- 但是，**最好情况时间复杂度**和**最坏情况时间复杂度**对应的都是极端情况下的代码复杂度，发生的概率其实并不大。
- 为了更好地表示平均情况下的复杂度，引入另一个概念：平均情况时间复杂度，简称为平均时间复杂度。
- 那如何分析平均时间复杂度呢，还是拿刚才那段查找函数来说：
  - 要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。然后把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值。
  - ![1553154595774](F:\OneDrive\JS\assets\1553154595774.png) 
  - 根据上章所说，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，把这个公式简化之后，得到的**平均时间复杂度**就是 O(n)。
- 但是上面计算的过程中，没有考虑到概率的问题，因为出现在每个位置的概率是不一样的，所以得重新计算，如下分析：
  - 要查找的变量 x，要么在数组里，要么就不在数组里。简单标记这两种情况下的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。那我们把每种情况发生的概率都考虑进去，计算表达式就变成了：
  - ![1553154639207](F:\OneDrive\JS\assets\1553154639207.png) 
  - 最后的结果也叫做概率中的**加权平均值**，那最后此段函数的**平均时间复杂度**就为 O(n)。
- 这么看，**平均时间复杂度**是不是好麻烦，还需要概率计算。实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度**有量级的差距**，我们才会使用这三种复杂度表示法来区分。

### 均摊情况

- ```js
  {
    var arr = new Array(n); // n 代表任意数字
    var ind = 0;
    function add(num) {
      if (ind === arr.length) {
        var sum = 0;
        for (var i = 0; i < arr.length; i++) {
          sum += arr[i];
        }
        arr[0] = sum;
        ind = 1;
      }
      arr[ind] = num;
      ind++;
    }
  }
  ```

- `add` 函数就是实现一个往数组中添加数据的功能。先定义一个任意长度的空数组，然后给数组添加数据。当达到数组长度后，也就是`ind === array.length`时，用 `for` 循环遍历数组求和，将求和之后的 `sum` 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空的话，则直接将数据添加到数组中。

- 来分析下此函数的时间复杂度：

  - 最理想的情况下，数组中有剩余位置，我们只需要将数据添加到数组下标为 `ind` 的位置就可以了，所以**最好情况时间复杂度**为 O(1)。 最糟糕的情况下，数组中没有剩余位置，我们需要先做一次数组的遍历求和，然后再添加数据，所以**最坏情况时间复杂度**为 O(n)。

- 接下来分析需要计算的 **平均时间复杂度**：

  - 由于数组的长度是 n，根据数据添加的位置的不同，可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种特殊的情况，就是在数组没有空闲空间时添加一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。
  - $\frac{n+n}{n+1}$
  - 所以根据大 O 表示法，**平均时间复杂度**就为 O(1)。

- 其实 `add` 函数的平均复杂度不需要这么复杂，接下来我们看看 `find` 函数和`add`函数的区别：

  - `find` 函数在极端情况下，时间复杂度才为 O(1)。但 `add` 函数在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，时间复杂度才比较高，为 O(n)。
  - 对于 `add` 函数来说，O(1) 时间复杂度的添加和 O(n) 时间复杂度的添加，出现的频率是非常有规律的，而且有一定的前后顺序，一般都是一个 O(n) 添加之后，紧跟着 n-1 个 O(1) 的添加操作，循环往复。

- 所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。

- 针对这种特殊的情况，我们引入了一种更加简单的分析方法：**摊还分析法**。通过摊还分析得到的时间复杂度，叫 **均摊时间复杂度**。

- 那如何使用摊还分析法来分析算法的**均摊时间复杂度**呢？

  - 还是看 `add` 函数。每一次 O(n) 的添加操作，都会跟着 n-1 次 O(1) 的添加操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是**均摊分析**的大致方法。

- 一般情况总结为：

  - 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用**均摊时间复杂度分析**的场合，一般**均摊时间复杂度**就等于**最好情况时间复杂度**。

### 生活举例

- 今天你准备去老王家拜访下，可惜老王的爱人叫他去打个酱油，她告诉你说她限时 n 分钟给他去买。
- 那么你想着以他家到楼下小卖部来回最多一分钟，那么 “最好的情况”就是你只用等他一分钟。
- 那么也有可能遇到突发情况，比如说电梯没电了，或者路上摔了一跤，天知道他去干了什么，用了 n 分钟。没办法，老婆有令，n 分钟限时，那这就是“最坏的情况”。
- 那“平均时间复杂度” 就是他有可能是第 1,2,3,...,n 中的某个分钟回来，那平均就是 1+2+3+...n/n，把 所有可能出现的情况的时间复杂度 相加除以情况数 。
- “均摊时间复杂度”的话就是把花时间多的分给花时间少的，得到一个中间值。假如 n 是 10 分钟，那么 9 分钟分 4 分钟到 1 分钟那，8 分 3 给 2...，那均摊下来就是 5 分钟。

### 四种复杂度

- 同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。
- 代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。

## 常见算法复杂度

### 数据结构

+ ![1564044152437](F:\OneDrive\JS\assets\1564044152437.png)

### 图

+ ![1564044163935](F:\OneDrive\JS\assets\1564044163935.png)

### 排序算法

+ ![1564044175935](F:\OneDrive\JS\assets\1564044175935.png)

### 搜索算法

+ ![1564044187838](F:\OneDrive\JS\assets\1564044187838.png)

# 递归算法

汉诺塔问题

- https://www.zhihu.com/question/31412436/answer/683820765

## 回溯算法

- ```java
  class Solution {
      int h=0,m=0;
      ArrayList<String> list=new ArrayList<>();
      
      public List<String> readBinaryWatch(int num) 
      {
          dfs(0,num,-1);
          return list;
      }
      
      public void dfs(int i,int num,int pos)
      {
          if(i>=num)
          {
              list.add(h+":"+(m<10?"0"+m:m));
              return;
          }
          for(int j=pos+1;j<10;j++)
          {
              if(j<=3&&h+power2(j)<=11)
              {
                  h+=power2(j);
                  dfs(i+1,num,j);
                  h-=power2(j);
              }
              else if(j>3&&m+power2(j-4)<=59)
              {
                  m+=power2(j-4);
                  dfs(i+1,num,j);
                  m-=power2(j-4);
              }
              else if(j>3 && m+power2(j-4)>59)
                  break;
          }
      }
      
      public int power2(int k)
      {
          int res=1;
          for(int i=0;i<k;i++)
              res*=2;
          return res;
      }
  }
  ```

## 分治算法

- 最小栈
- 队列实现栈
- 归并排序

# 其他算法

## 贪心算法

### 概念

+ 贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的
  解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。 

###  最少硬币找零问题 

+ 最少硬币找零问题也能用贪心算法解决。大部分情况下的结果是最优的，不过对有些面额而
  言，结果不会是最优的。 

  ```js
  function MinCoinChange(coins){ 
    var coins = coins; //{1} 
  
    this.makeChange = function(amount) { 
      var change = [], 
          total = 0; 
      for (var i=coins.length; i>=0; i--){ //{2} 
        var coin = coins[i]; 
        while (total + coin <= amount) { //{3} 
          change.push(coin);           //{4} 
          total += coin;               //{5} 
        } 
      } 
      return change; 
    }; 
  } 
  
  ```

+ 对每个面额（行{2}——从大到小），把它的值和total相加后，total需要小于amount（行
  {3}）。我们会将当前面额coin添加到结果中（行{4}），也会将它和total相加（行{5}）。 

+ 如你所见，这个解法很简单。从最大面额的硬币开始，拿尽可能多的这种硬币找零。当无法
  再拿更多这种价值的硬币时，开始拿第二大价值的硬币，依次继续。 

## 滑动窗口

+ 答案要求在某一个范围之内
+ 滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即` [i, j)`（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。
+ 例如，我们将` [i, j)`向右滑动 1 个元素，则它将变为 `[i+1, j+1)`（左闭，右开）

### 维护窗口的数据结构

+ 数组：插入和删除是线性的，搜索也是线性的
+ 自平衡二叉树：插入、删除、搜索都是 O(log k)
+ **哈希表**：插入、删除、搜索都是常数级

### [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

#### 题目

+ 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值小于等 k。

  ```
  输入: nums = [1,2,3,1], k = 3
  输出: true
  ```

#### 分析

+ 维护了个 k 大小的滑动窗口，然后在这个窗口里面搜索是否存在跟当前元素相等的元素

### [220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)

#### 题目

+ 给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t，并且 i 和 j 之间的差的绝对值小于等于 ķ。

#### 线性搜索 超时

+ 将每个元素与它之前的 *k* 个元素比较，查看它们的数值之差是不是在 *t* 以内。

+ 解决这个问题需要找到一组满足以下条件的 *i* 和 *j*：

  ![1563855257489](F:\OneDrive\JS\assets\1563855257489.png)

+ 我们需要维护了一个 k 大小的滑动窗口。这种情况下，第一个条件始终是满足的，只需要通过线性搜索来检查第二个条件是否满足就可以了

  ```java
  public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
      for (int i = 0; i < nums.length; ++i) {
          for (int j = Math.max(i - k, 0); j < i; ++j) {
              if (Math.abs(nums[i] - nums[j]) <= t) return true;
          }
      }
      return false;
  }
  // Time limit exceeded.
  ```

#### 二叉搜索树 【JAVA通过，JS超时】

+ 如果窗口中维护的元素是有序的，只需要用二分搜索检查条件二是否是满足的就可以了。
  利用自平衡二叉搜索树，可以在对数时间内通过 插入 和 删除 来对滑动窗口内元素排序。

+ 方法一**真正的瓶颈**在于检查第二个条件是否满足需要扫描滑动窗口中所有的元素。因此我们需要考虑的是有没有比全扫描更好的方法。

+ 如果窗口内的元素是有序的，那么用两次二分搜索就可以找到 x+t 和 x-t 这两个边界值了。

+ 然而不幸的是，窗口中的元素是无序的。这里有一个初学者非常容易犯的错误，那就是将滑动窗口维护成一个有序的数组。虽然在有序数组中 搜索 只需要花费对数时间，但是为了让数组保持有序，我们不得不做插入和删除的操作，而这些操作是非常不高效的。想象一下，如果你有一个 k 大小的有序数组，当你插入一个新元素x 的时候。虽然可以在 O(logk) 时间内找到这个元素应该插入的位置，但最后还是需要 O(k) 的时间来将 x 插入这个有序数组。因为必须得把当前元素应该插入的位置之后的所有元素往后移一位。当你要删除一个元素的时候也是同样的道理。在删除了下标为 i 的元素之后，还需要把下标 i 之后的所有元素往前移一位。因此，这种做法并不会比方法一更好。

+ 为了能让算法的效率得到真正的提升，我们需要引入一个支持 插入，搜索，删除 操作的 **动态** 数据结构，那就是自平衡二叉搜索树。

+ 下面给出整个算法的伪代码：

  + 初始化一颗空的二叉搜索树 set
  + 对于每个元素x，遍历整个数组
    + 在 set 上查找大于等于 x 的最小的数，如果 `s−x≤t `则返回 true
    + 在 set 上查找小于等于 x 的最大的数，如果 `x−g≤t `则返回 true
    + 在 set 中插入x
    + 如果树的大小超过了k, 则移除最早加入树的那个数。
  + 返回 false

+ ```js
  var containsNearbyAlmostDuplicate = function (nums, k, t) {
    const len = nums.length
    const tree = new BinarySearchTree()
    for (let i = 0; i < len; i++) {
      const ceil = tree.ceiling(nums[i])
      if (ceil != null && ceil <= nums[i] + t) return true
  
      const floor = tree.floor(nums[i])
      if (floor != null && nums[i] <= floor + t) return true
  
      tree.insert(nums[i])
      if (tree.size() > k) tree.remove(nums[i - k])
    }
    return false
  }
  let nums = [1,5,9,1,5,9], k = 2, t = 3
  console.log(containsNearbyDuplicate(nums, k))
  ```
  

#### 桶

+ 回到这个问题，我们尝试去解决的最大的问题在于：

  1. 对于给定的元素 x*x*, 在窗口中是否有存在区间 [x-t, x+t] 内的元素？
  2. 我们能在常量时间内完成以上判断嘛？

+ 我们不妨把把每个元素当做一个人的生日来考虑一下吧。假设你是班上新来的一位学生，你的生日在 三月 的某一天，你想知道班上是否有人生日跟你生日在 t=30 天以内。在这里我们先假设每个月都是30 天，很明显，我们只需要检查所有生日在 二月，三月，四月 的同学就可以了。

+ 之所以能这么做的原因在于，我们知道每个人的生日都属于一个桶，我们把这个桶称作月份！每个桶所包含的区间范围都是 t，这能极大的简化我们的问题。很显然，任何不在同一个桶或相邻桶的两个元素之间的距离一定是大于 t 的。

+ 我们把上面提到的桶的思想应用到这个问题里面来，我们设计一些桶，让他们分别包含区间 ..., [0,t], [t+1, 2t+1] ,..., 我们把桶来当做窗口，于是每次我们只需要检查 x 所属的那个桶和相邻桶中的元素就可以了。终于，我们可以**在常量时间解决在窗口中搜索的问题**了。

+ 还有一件值得注意的事，这个问题和桶排序的不同之处在于每次我们的桶里只需要**包含最多一个元素**就可以了，因为如果任意一个桶中包含了两个元素，那么这也就是意味着这两个元素是 足够接近的 了，这时候我们就直接得到答案了。因此，我们只需使用一个标签为桶序号的散列表就可以了。

  ```js
  var containsNearbyAlmostDuplicate = function (nums, k, t) {
    if(t<0) return false
    const map = {}
    // 防止0造成的infinity
    const bucketSize = t + 1
    for (let i = 0; i < nums.length; i++) {
      const bucketID = getID(nums[i],bucketSize)
      if(map[bucketID]!==undefined && Math.abs(nums[i] - map[bucketID]) <= t){
        return true
      }
      if(map[bucketID-1]!==undefined && Math.abs(nums[i] - map[bucketID-1]) <= t){
        return true
      }
      if(map[bucketID+1]!==undefined && Math.abs(nums[i] - map[bucketID+1]) <= t){
        return true
      }
      map[bucketID] = nums[i]
      if(i>k-1){
        const removeID = getID(nums[i-k],bucketSize)
        map[removeID] = undefined
      }
    }
    function getID(x,w){
      return Math.floor(x/w)
    }
    return false
  }
  ```

### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

#### 题目

- 给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

  ```
  let s = "abcabcbb"
  输出: 3 
  解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
  ```

#### 转化为低阶动态规划

- 对字符串进行去重，去重之后找到最长公共子串即是
- 不可以，去重之后就变成子序列了，而不是子串

#### 暴力法

+ 暴力循环所有子串，然后判断是不是包含重复字符，并且更新相应的最长长度

#### 滑动窗口

+ 在暴力法中，我们会反复检查一个子字符串是否含有有重复的字符，但这是没有必要的。如果从索引 i 到 j - 1之间的子字符串 $s_{ij}$已经被检查为没有重复字符。我们只需要检查 s[j] 对应的字符是否已经存在于子字符串 $s_{ij}$中。

+ 要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为O*(*n^2) 的算法，但我们可以做得更好。

+ 通过使用 HashSet 作为滑动窗口，我们可以用 O*(1) 的时间来完成对字符是否在当前的子字符串中的检查。

+ 我们使用 HashSet 将字符存储在当前窗口` [i, j)`（最初 j = i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。

  ```js
  var lengthOfLongestSubstring = function(s) {
    const set = new Set()
    let max = 0
    for (let i = 0; i < s.length; i++) {
      for (let j = i; j < s.length; j++) {
        // 遇到了重复的字符串 break
        if(set.has(s[j])) break
        else set.add(s[j])
      }
      // 跳出了内循环，更新长度
      max = Math.max(max,set.size)
      set.clear()
    }
    return max
  }
  ```

**复杂度分析**

+ 时间复杂度：O(2n)=O(n)，在最糟糕的情况下，每个字符将被 i 和 j 访问两次。

+ 空间复杂度：O(min(m,n))，与之前的方法相同。滑动窗口法需要 O(k) 的空间，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串nn 的大小以及字符集 / 字母 m 的大小。

#### 优化的滑动窗口

+ 上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。

+ 也就是说，如果 `s[j]` 在 `[i, j)` 范围内有与 索引`j'`重复的字符，我们不需要逐渐增加 `i` 。 我们可以直接跳过 `[i，j']`范围内的所有元素，并将 `i` 变为 `j'+1`。

+ 因为以`[i, j)` 范围内每一个字符开头的最长的子串，都会在`j`处与`j'`重复，所以我们直接从`j'+1`开始即可

  ```js
  var lengthOfLongestSubstring = function(s) {
    const map = new Map()
    let max = 0
    for (let i = 0 ,j = 0; j < s.length; j++) {
      if(map.has(s[j])){
        // 有重复时 i 从 j'+1 处开始
        i = Math.max(map.get(s[j])+1,i)
      }
      // 如果重复了也要更新s[j]的值，所以在判断外执行该语句
      map.set(s[j],j)
      max = Math.max(max,j - i + 1)
    }
    return max
  }
  ```

  

## 判圈算法

### 数组去重思路

### Flyod龟兔算法

+ 对于赛道来说，如果赛道中有环，那么速度快的兔子一定会在某个地点追上乌龟，并且兔子所跑的距离减去乌龟所跑的距离，一定是环长度的整数倍。
+ 快慢指针

#### 原理

+ 假设令龟、兔为指针，并且指向起点位置，兔子每次移动两个节点，乌龟每次移动一个节点。如果两者在起始节点外相遇，则说明有环。如果兔子在走到链表尾部还没有与乌龟相遇，说明无环。

#### 环长度

+ 通过上述算法判断出存在环C时，显然龟兔位于同一节点B，此时，令兔子保持不动，而乌龟不断推进，记录移动距离，等再次相遇时，移动步数即环C长度。

#### 环起点

+ 乌龟所跑距离为 `S = m + n + aC`（C 为环长度), 
  兔子所跑距离为`2S = m + n + bC`（因为兔子速度为乌龟`2`倍） 

+ 故得`S = (b - a)C = m + n + aC ==> (b - 2a)C = m + n`, 由此可知，`m + n` 为环`C`长度整数倍

+ 让兔子回到起点H，乌龟停留在相遇点B，随后，同时让乌龟与兔子不断推进一步，兔子移动m到达点A，距离点B还有n，乌龟移动m也会到达点A，再走n就饶了`(b-2a)`圈，到达点B

+ 所以龟兔会在点A相遇，之后一直为伴走距离n再次到达点B

  ![](https://raw.githubusercontent.com/chiyu-git/chiyu-pic/master/20170423200520994.png)

#### 实现

+ ```js
  function flyodCircle(head){
    let rabbit = head,tortoise = head
    do{
      // 兔子先走
      rabbit = rabbit.next
      if(rabbit.next !== null){
         rabbit = rabbit.next
      }else{
        // 到头了，无环
        return false
      }
      tortoise = tortoise.next
    }while(rabbit!==tortoise);
    // 出循环，此时龟兔相遇在点B
    // 求环长度C
    let circleLen = 0
    do{
      tortoise = tortoise.next
      circleLen++
    }while(tortoise!==rabbit)
    // 求环起点A
    tortoise = head
    while(tortoise!==rabbit){
      tortoise = tortoise.next
      rabbit = rabbit.next
    }
    // 出循环，此时龟兔相遇在起点A
    const start = tortoise
    return {start,circleLen}
  }
  ```

#### 时间复杂度

+ 如果乌龟走到环起点P时，此时显然兔子已经在环内某节点，之后兔子最多走一圈就会与乌龟相遇。假设链表起始节点到环起点距离为m， 环长度为n, 故时间复杂度为O(m + n)

#### 空间复杂度

+ 算法仅需要创建指针`tortoise,rabbit` ，环长`circleLen`以及环起点`start` 故空间复杂度为O(1)

### Brent龟兔算法

#### 原理

+ 这是一个倍增算法，让乌龟保持不动，兔子走 `2^i `步，看这个过程中龟兔有没有相遇，没有的话，让乌龟的位置变成兔子的位置（如果乌龟位置一直不变，它可能不会进入环中），让兔子走`2^(i+1)`步，看看会不会相遇，如此循环。这个算法也是O(n)的，但是它会比Floyd表现的更好，且Floyd是这个算法最差时的表现。

#### 求环的长度

+ 因为乌龟一直处在兔子更改步长上限时的位置，所以更改步长后，兔子走了几步与乌龟相遇，环的长度就是几步（就是代码中的count变量）

#### 求环的起点

+ Floyd判圈算法利用了乌龟和兔子的距离是环长整数倍的性质来求出起点，所以可以让乌龟回到起点，兔子回到距离起点C（C指环的长度）处，然后接下来的步骤和Floyd一样。

#### 实现

+ ```js
  function breantCycle(head){
    let rabbit = tortoise = head
    let stride = 2,count = 0
    do{
      while(count<=stride){
        if(rabbit!==tortise){
          rabbit = rabbit.next
          if(rabbit === null) return false
          count++
        }else{
          break
        }
      }
      tortoise = rabbit
      interval *= 2
      count = 0
    }
    while(rabbit!==tortoise)
    // 出循环，龟兔相遇
    const circleLen = count
    // 求环起点A
    tortoise = rabbit = head
    while(count>0){
      rabbit = rabbit.next
      count--
    }
    while(tortoise!==rabbit){
      tortoise = tortoise.next
      rabbit = rabbit.next
    }
    return 
  }
  ```

### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

#### 题目

+ 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

#### 分析

+ 因为 nums 中的每个数字都在 1 和 n 之间，所以它必须指向存在的索引。此外，由于 0 不能作为 nums 中的值出现，nums[0] 不能作为循环的一部分。


# 算法名词

### 山脉数组

+ 所谓山脉数组，即数组 A 假如是一个山脉数组的话，需要满足如下条件：

+ 首先，A.length >= 3

+ 其次，在 0 < i < A.length - 1 条件下，存在 i 使得：
  + `A[0] < A[1] < ... A[i-1] < A[i]`
  + `A[i] > A[i+1] > ... > A[A.length - 1]`