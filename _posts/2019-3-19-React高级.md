---
layout: post
#标题配置
title:  React Advanced
#时间配置
date:   2019-3-19 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note front-end
---

* content
{:toc}




深入React技术栈

- 书本示例代码
  - https://github.com/arcthur/react-book-examples 
  -  https://coding.net/u/arcthur/p/react-book-examples/git

### keyword

- 思想
- 智能组件、木偶组件
- 动态子组件
- 挂在、渲染、卸载
- 数据更新过程
- shouldComponentUpdate 
- 高阶组件
- 合成事件
- 跨组件间通信：context
- mixin 和 高阶组件
- decorator
- 属性代理 反向继承
- Pure Render Pure Component
- Immutable
- React Node
- 有限状态机
- 递归渲染
- tree diff、component diff 以及 element diff

### terms

+ **领域特定语言**（英语：domain-specific language、DSL）指的是专注于某个[应用程序](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)领域的[计算机语言](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80)。又译作**领域专用语言**。
+ 不同于普通的跨领域通用计算机语言(GPL)，领域特定语言只用在某些特定的领域。 比如用来显示网页的[HTML](https://zh.wikipedia.org/wiki/HTML)，以及[Emacs](https://zh.wikipedia.org/wiki/Emacs)所使用的Emac LISP语言。

# 1. 简介

## VirtualDOM

## 函数式编程

- 函数式编程才是 React 的精髓
- 而函数式编程，对应的是声明式编程，它是人类模仿自己逻辑思考方式发明出来的。声明式编程的本质是 lambda 演算。试想当我们操作数组的每个元素并返回一个新数组时，如果是计算机的思考方式，则是需要一个新数组，然后遍历原数组，并计算赋值；如果是人的思考方式，则是构建一个规则，这个过程就变成构建一个 **f 函数**作用在数组上，然后返回新数组。这样，计算可以被重复利用。

## JSX语法

- 在 React 中创建的虚拟元素可以分为两类，DOM 元素（DOM element）与组件元素（component element），分别对应着原生 DOM 元素与自定义元素，而 JSX 与创建元素的过程有着莫大的关联。

### DOM元素

- HTML语法转换为JS对象

- ```html
  <button class="btn btn-blue"> 
    <em>Confirm</em> 
  </button> 
  ```

- ```js
  { 
   type: 'button', 
   props: { 
     className: 'btn btn-blue', 
     children: [{ 
    type: 'em', 
    props: { 
   children: 'Confirm' 
    } 
     }] 
    } 
  } 
  ```

### 组件元素

- ```js
  const Button = ({ color, text }) => { 
   return { 
   type: 'button', 
     props: { 
    className: `btn btn-${color}`, 
    children: { 
   type: 'em', 
   props: { 
     children: text, 
   }, 
    }, 
     }, 
    }; 
  } 
  ```

- 对按钮botton进行了封装，当我们要生成 DOM 元素中具体的按钮时，就可以方便地调用 `Button({color:'blue',text:'Confirm'}) `来创建。

- 仔细思考这个过程可以发现，Button 方法其实也可以作为元素而存在

  - 方法名对应了 DOM 元素类型
  - 参数对应了 DOM 元素属性

- 那么它就具备了元素的两大必要条件，这样构建的元素就是自定义类型的元素，或称为组件元素。我们用 JSON 结构来描述它： 

- ```json
  { 
   type: Button, 
   props: { 
     color: 'blue', 
     children: 'Confirm' 
    } 
  } 
  // 把自定义的组件转换为HTML元素的JS表现形式
  ```

- 这也是 React 的**核心思想**之一。因为有公共的表达方法，我们就可以让元素们彼此嵌套或混合。这些层层封装的组件元素，就是所谓的 React 组件，最终我们可以用递归渲染的方式构建出完全的 DOM 元素树。

- 一个封装的更深的例子

- ```js
  const DeleteAccount = () => ({ 
    type: 'div', 
    props: { 
      children: [{ 
        type: 'p', 
        props: { 
        children: 'Are you sure?', 
        }, 
      }, { 
        type: DangerButton, // 调用DangerButton组件
        props: { 
        children: 'Confirm', 
        }, 
      }, { 
        type: Button, 
        props: { 
        color: 'blue', 
        children: 'Cancel', 
        }, 
      }], 
    } 
  }); 
  
  // DangerButton组件如下
  const DangerButton = ({ text }) => ({ 
   type: Button, 
   props: { 
     color: 'red', 
     children: text 
    } 
  }); 
  ```

- DeleteAccount清晰地表达了一个功能模块、一段提示语、一个表示确认的警示按钮和一个
  表示取消的普通按钮。

- 不过在表达还不怎么复杂的结构时，它就力不从心了。这让我们想起使用 HTML 书写结构时的畅快感受，JSX 语法为此应运而生。假如我们使用 JSX 语法来重新表达上述组件元素，只需这么写： 

  ```js
  const DeleteAccount = () => ( 
    <div> 
     <p>Are you sure?</p> 
     <DangerButton>Confirm</DangerButton> 
     <Button color="blue">Cancel</Button> 
    </div> 
  ); 
  // 上述 DeleteAccount并不是真实转换，在实际场景中构建元素会考虑到诸如安全等因素，会由 React 内部方法创建虚拟元素。如果需要自己构建虚拟元素，原理也是一样的。 
  
  ```

- JSX  将  HTML  语法直接加入到  JavaScript  代码中，再通过翻译器转换到纯 JavaScript 后由浏览器执行。在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，尽管 JSX 是第三方标准，但这套标准适用于任何一套框架。 
- React 官方在早期为 JSX 语法解析开发了一套编译器 JSTransform，目前已经不再维护，现在已全部采用  Babel  的  JSX  编译器实现。因为两者在功能上完全重复，而  Babel  作为专门的 JavaScript 语法编译工具，提供了更为强大的功能，达到了“一处配置，统一运行”的目的。 

- 将 Delete Account 组件通过 Babel 转译成 React 可以执行的代码：

- ```react
  var DeleteAccount = function DeleteAccount() { 
   return React.createElement( 
     'div', 
     null, 
     React.createElement( 
    	'p', 
    	null, 
    	'Are you sure?' 
     ), 
     React.createElement( 
    	DangerButton, 
    	null, 
    	'Confirm' 
     ), 
     React.createElement( 
    	Button, 
    	{ color: 'blue' }, 
    	'Cancel' 
     ) 
    ); 
   );
  ```

- 可以看到，除了在创建元素时使用  React.createElement  创建之外，其结构与 JSON 的结构是一致的。 

- 反过来说，JSX 并不是强制选项，我们可以像上述代码那样直接书写而无须编译，但这实在是极其槽糕的编程体验。JSX 的出现为我们省去了这个烦琐过程，使用 JSX 写法的代码更易于阅读与开发。事实上，JSX 并不需要花精力学习。只要你熟悉  HTML 标签，大多数功能就都可以直接使用了。 

## React组件

### 组件的演变

+ 在 MV* 架构出现之前，组件主要分为两种
  + 狭义上的组件，又称为UI组件，比如Tabs组件、DropDown组件。组件主要围绕在交互动作上的抽象，针对交互动作，用js操作DOM结构或者style样式来控制
  + 广义上的组件，即带有业务含义和数据的 UI 组件组合。这类组件不仅有交互动作，更重要的是有**数据与界面**之间的交互。然而，这类组件往往有较大的争议。在规模较大的场景下，我们更倾向于采用分层的思想去处理。

**Tabs组件**

+ 对于 UI 组件来说，一定会有 3 个部分组件：结构、样式和交互行为，分别对应着 HTML、CSS 和 JavaScript。
+ 组件封装的基本思路就是面向对象思想。交互基本上以操作 DOM 为主，逻辑上是结构上哪里需要变，我们就操作哪里。此外，对于 JavaScript 的结构，我们得到了几项规范标准组件的信息。 
  + **基本的封装性**。尽管说 JavaScript 没有真正面向对象的方法，但我们还是可以通过实例化的方法来制造对象。
  + **简单的生命周期呈现**。最明显的两个方法 constructor 和 destroy，代表了组件的挂载和卸载过程。但除此之外，其他过程（如更新时的生命周期）并没有体现。
  + **明确的数据流动**。这里的数据指的是调用组件的参数。一旦确定参数的值，就会解析传进来的参数，根据参数的不同作出不同的响应，从而得到渲染结果。
+ 在这个阶段，前端在应用级别并没有过多复杂的交互，组件化发展缓慢。
+ 传统组件的主要问题在于结构、样式与行为没有很好地结合，不同参数下的逻辑可能会导致不同的渲染逻辑，这时就会存在大量 HTML 结构与 style 样式的拼装。
  + 比如，常见的 show、hide 与 toggle 方法，就是通过改变 class 控制 style 来显示或隐藏。
+ 这样的逻辑一旦复杂，就存在大量的 DOM 操作，开发及维护成本相当高。

**MV*架构**

+ 直到富客户端应用越来越多，传统组件化越来越无法满足开发者的需要，于是引进了分层的思想，此时就出现了  MVC 架构。
+ View 只关心怎么输出变量，所以就诞生了各种各样的模板语言，比如 Smarty、Mustache、Handlerbars 等。
+ 直到这几年萌生的 Angular，我们看到了**在 HTML 上定义指令**的方式。

**Web Components**

+ 它通过定义 Custom Elements（自定义元素）的方式来统一组件。每个**自定义元素**可以定义自己对外提供的属性、方法，还有事件，内部可以像写一个页面一样，**专注于实现功能**来完成对组件的封装。 
+ Web Components 的 4 个组成部分：
  + HTML Templates 定义了之前**模板**的概念
  + Custom Elements 定义了组件的**展现形式**
  + Shadow DOM 定义了组件的**作用域范围**、可以囊括**样**
    **式**
  + HTML Imports 提出了新的**引入方式**
  + ![1551863206792](F:\OneDrive\JS\纲略合集\assets\1551863206792.png) 
+ Web  Components  定义了一切我们想要的组件化概念，现在还有  polymer  这个库可实现这一套理念，但事实上它还需要时间的考验。

### React组件的构建

- Web Components 通过自定义元素的方式实现组件化，而 React 的本质就是关心元素的构成，**React 组件即为组件元素**。组件元素被描述成纯粹的 JSON 对象，意味着可以使用方法或是类来构建。
- React 组件基本上由 3 个部分组成——属性（props）、状态（state）以及生命周期方法。
- 这里我们从一张图来简单概括 React：![1551838799979](F:\OneDrive\JS\纲略合集\assets\1551838799979.png) 
- React  组件可以接收**参数**，也可能有自身**状态**。一旦接收到的参数或自身状态有所改变，React 组件就会执行相应的**生命周期方法**，最后**渲染**。整个过程完全符合传统组件所定义的组件职责。 

**React 与 Web Components**

+ 从 React 组件上看，它与 Web Components 传达的理念是一致的，但两者的实现方式不同： 
  + React 自定义元素是库自己构建的，与 Web Components 规范并不通用；
  + React 渲染过程包含了模板的概念，即 1.2 节所讲的 JSX；
  + React 组件的实现均在方法与类中，因此可以做到相互隔离，但不包括样式；
  + React 引用方式遵循 ES6 module 标准。

+ 可以说，React 还是在**纯 Java Script** 上下了工夫，将 HTML 结构彻底引入到 JavaScript 中。尽管这种做法褒贬不一，但也有效解决了组件所要解决的问题之一。 

**React 组件的构建方法**

+ React  组件基本上由**组件的构建方式**、**组件内的属性状态**与**生命周期方法**组成。
+ 在本节中，我们先来讨论创建 React 组件的构建方式，而属性状态与生命周期会在后面再介绍。 

+ 官方在 React 组件构建上提供了 3 种不同的方法：
  + React.createClass
  + ES6 classes 
  + 无状态函数（stateless function）
+ 我们使用 1.1 节中的 Button 来分别介绍这 3 种方法。 

1. **React.createClass**

+ 之前，这一直都是 React 官方唯一指定的组件写法。示例代码如下： 用 React.createClass 构建组件是 React 最传统、也是兼容性最好的方法。在 0.14 版本发布之前，这一直是官方唯一指定的方法

+ ```react
  const Button = React.createClass({ 
   getDefaultProps() { 
     return { 
    color: 'blue', 
    text: 'Confirm', 
     }; 
    }, 
   render() { 
     const { color, text } = this.props; 
     return ( 
    <button className={`btn btn-${color}`}> 
      <em>{text}</em> 
    </button> 
     ); 
    } 
  }); 
  ```

+ 从表象上看，React.createClass 方法就是构建一个组件对象。当另一个组件需要调用 Button 组件时，只用写成 <Button />，就可以被解析成` React.createElement(Button) `方法来**创建 Button 实例**，这意味着在一个应用中调用几次 Button，就会创建几次 Button 实例。 

2. **ES6 classes**

+ ES6 classes 的写法是通过 ES6 标准的类语法的方式来构建方法： 

+ ```react
  import React, { Component } from 'react'; 
  class Button extends Component { 
   constructor(props) { 
     super(props); 
    } 
   static defaultProps = { 
     color: 'blue', 
    text: 'Confirm', 
    }; 
   render() { 
     const { color, text } = this.props; 
     return ( 
    <button className={`btn btn-${color}`}> 
      <em>{text}</em> 
    </button> 
     ); 
    } 
  } 
  ```

+ 这里的直观感受是从调用内部方法变成了用类来实现。与 createClass 的结果相同的是，**调用类实现的组件会创建实例对象。** 

+ 再说起继承，我们很容易联想到在组件抽象过程中也可以使用**继承**的思路。如果我们学过面向对象的知识，就知道继承与组合的不同，它们可以用 IS-A 与 HAS-A 来区别。
+ 在实际应用 React 的过程中，我们极少让子类去继承功能组件。试想在 UI 层面小的修改就会影响到整体交互或样式，牵一发而动全身，用**继承来抽象往往是事倍功半**。
+ 在 React 组件开发中，常用的方式是将组件**拆分到合理的粒度**，用组合的方式合成业务组件，也就是 HAS-A 的关系。但在**高阶组件**构建中，我们可以用**反向继承**的方法来实现，具体内容请阅读 2.5 节。 

+ React  的所有组件都继承自顶层类  React.Component。它的定义非常简洁，只是初始化了React.Component 方法，声明了 props、context、refs 等，并在原型上定义了 setState 和 forceUpdate 方法。
+ 内部初始化的生命周期方法与 createClass 方式使用的是同一个方法创建的。具体解读可参见 3.2.2 节。

3. **无状态函数**

+ 使用无状态函数构建的组件称为无状态组件，这种构建方式是  0.14  版本之后新增的，且**官方颇为推崇**。示例代码如下： 

+ ```react
  function Button({ color = 'blue', text = 'Confirm' }) { 
   return ( 
     <button className={`btn btn-${color}`}> 
    <em>{text}</em> 
     </button> 
    ); 
  } 
  ```

+ 无状态组件**只传入 props 和 context 两个参数**；也就是说，它不存在 state，也没有生命周期方法

+ **组件本身即**上面两种  React  组件构建方法中的  **render  方法**。

+ 不过，像  propTypes  和 defaultProps 还是可以通过向方法设置**静态属性**来实现的。 

+ 在适合的情况下，我们都**应该且必须**使用无状态组件。无状态组件不像上述两种方法在调用时会创建新实例，它创建时**始终保持了一个实例**，避免了不必要的检查和内存分配，做到了**内部优化**。 

## React 数据流

+ 从这一节起，我们就**以 Tabs 组件**为例慢慢介绍 React 组件的主要组成部分，看看它到底有什么不同之处。 
+ 在 React 中，数据是**自顶向下单向流动**的，即从父组件到子组件。这条原则让组件之间的关系变得简单且可预测。 
+ state 与 props 是 React 组件中最重要的概念。
  + 如果顶层组件初始化 props，那么 React 会向下遍历整棵组件树，重新尝试渲染所有相关的子组件。
  + 而  state  只关心每个组件自己内部的状态，这些状态只能在组件内改变。
+ **把组件看成一个函数，那么它接受了 props 作为参数，内部由 state 作为函数的内部参数，返回一个 Virtual DOM 的实现。** 

### state 

+ 在使用 React 之前，常见的 MVC 框架也非常容易实现交互界面的状态管理，比如 Backbone。它们将 View 中与界面交互的状态解耦，一般将状态放在 Model 中管理。但在 React 没有结合 Flux 或  Redux  框架前，它自身也同样可以管理组件的内部状态。在  React 中，把这类状态统一称为 state。

+ 当组件内部使用库内置的  **setState  方法**时，最大的表现行为就是**该组件会尝试重新渲染**。这很好理解，因为我们改变了内部状态，组件需要更新了。比如，我们实现了一个计数器组件： 

+ ```react
  handleClick(e) { 
  	e.preventDefault();
  	this.setState({ 
    count: this.state.count + 1, 
  	}); 
  } 
  ```

+ 在 React 中常常在事件处理方法中更新 state，上述例子就是通过点击“更新”按钮不断地更新内部 count 的值，这样就可以把组件内状态封装在实现中。 

+ 值得注意的是，**setState 是一个异步方法**，一个生命周期内所有的 setState 方法会合并操作。关于 setState 的实现原理，请参见 3.4 节。

+ 有了这个特性，让 React 变得充满了想象力。我们完全可以只用 React 来完成对行为的控制、数据的更新和界面的渲染。然而，随着内容的深入，我们并**不推荐开发者滥用 state**，过多的内部状态会让数据流混乱，程序变得难以维护。 

+ 我们再来看  Tabs  组件的  state。从前一节的经验中得到两个可能的内部状态——active-Index 和 prevIndex，它们分别表示当前选中 tab 的索引和前一次选中 tab 的索引。而需要特别注意的一点是，当前选中的索引亦是组件本身需要的参数之一。 

+ 这里我们针对 activeIndex 作为 state，就有两种不同的视角。 

  + activeIndex 在**内部更新**。当我们切换 tab 标签时，可以看作是组件内部的交互行为，被选择后通过回调函数返回具体选择的索引。
  + activeIndex 在**外部更新**。当我们切换 tab 标签时，可以看作是组件外部在传入具体的索引，而组件就像“木偶”一样被操控着。

+ 这两种情形在 React 组件的设计中非常常见，我们形象地把第一种和第二种视角写成的组件分别称为**智能组件**（smart component）和**木偶组件**（dumb component）。 

### props 

+ props 是 React 中另一个重要的概念，它是 properties 的缩写。props 是 React 用来让组件之间互相联系的一种机制，通俗地说就像方法的参数一样。
+ props 的传递过程，对于 React 组件来说是非常直观的。
+ React 的单向数据流，主要的流动管道就是 props
+ props 本身是**不可变的**
  + 当我们试图改变 props 的原始值时，React 会报出类型错误的警告，组件的 props 一定来自于默认属性或通过父组件传递而来。
  + 如果说要渲染一个对 props 加工后的值，最简单的方法就是使用局部变量或直接在 JSX 中计算结果。 

+ React 为 props 同样提供了**默认配置**，通过 defaultProps 静态变量的方式来定义。当组件被调用的时候，默认值保证渲染后始终有值。在 render 方法中，可以直接使用 props 的值来渲染。

+ ```react
  static defaultProps = { 
   classPrefix: 'tabs', 
   onChange: () => {}, 
  }; 
  ```

+ 但 Tabs 组件的信息全由一个对象传进来的方式真的好么？

  + 对于 React 组件来说，我们考虑设计组件一定要满足一大原则——**直观**。把基本设置与数据一起定义成一个数组或对象是初学者最容易犯的一个错误
  + 如果说组件能够分解，那我们一定要分解，并使用子组件的方式来处理。 

+ 在 Tabs 组件内把**所有定义的子组件**都**显式**展示出来。这种方式的好处在于非常易于理解，可自定义能力强，但调用过程显得过于笨重。React-Bootstrap 和 Material UI 组件库中的Tabs 组件采用的是这种形式。调用方式近似如下形式：

+ ```react
  <Tabs classPrefix={'tabs'} defaultActiveIndex={0}>
    <TabNav> 
     <TabHead>Tab 1</TabHead> {//标签内的文本的作用是什么？仅仅是标志而已吗}
     <TabHead>Tab 2</TabHead> 
     <TabHead>Tab 3</TabHead> 
    </TabNav> 
    <TabContent> 
     <TabPane>第一个 Tab 里的内容</TabPane> 
     <TabPane>第二个 Tab 里的内容</TabPane> 
     <TabPane>第三个 Tab 里的内容</TabPane> 
    </TabContent> 
  </Tabs> 
  ```

+ 在 Tabs 组件内只显示定义内容区域的子组件集合，头部区域对应内部区域每一个 TabPane 组件的 props，让其**在 Tab Nav 组件内拼装**。这种方式的调用写法简洁，把复杂的逻辑留给了组件去实现。Ant Design 组件库中的 Tabs 组件采用的就是这种形式。调用方式近似如下形式： 

+ ```react
  <Tabs classPrefix={'tabs'} defaultActiveIndex={0}> 
   <TabPane key={0} tab={'Tab 1'}>第一个 Tab 里的内容</TabPane> 
   <TabPane key={1} tab={'Tab 2'}>第二个 Tab 里的内容</TabPane> 
   <TabPane key={2} tab={'Tab 3'}>第三个 Tab 里的内容</TabPane> 
  </Tabs> 
  
  ```

**子组件 prop**

+ 在 React 中有一个重要且内置的 prop——children，它代表组件的**子组件集合**。children 可以根据传入子组件的数量来决定是否是数组类型。上述调用 TabPane 组件的过程，翻译过来即是： 

+ ```react
  <Tabs classPrefix={'tabs'} defaultActiveIndex={0} className="tabs-bar" 
    children={[ 
      <TabPane key={0} tab={'Tab 1'}>第一个 Tab 里的内容</TabPane>, 
      <TabPane key={1} tab={'Tab 2'}>第二个 Tab 里的内容</TabPane>, 
      <TabPane key={2} tab={'Tab 3'}>第三个 Tab 里的内容</TabPane>, 
    ]} 
  > 
  </Tabs> 
  
  ```

+ **实现的基本思路**就以 TabContent 组件渲染 Tab Pane 子组件集合为例来讲，其中渲染 Tab Pane 组件的方法如下： 

+ ```react
  getTabPanes() { 
   const { classPrefix, activeIndex, panels, isActive } = this.props; 
   return React.Children.map(panels, (child) => { 
   if (!child) { return; } 
   const order = parseInt(child.props.order, 10); 
   const isActive = activeIndex === order; 
     return React.cloneElement(child, { 
    classPrefix, 
    isActive, 
    children: child.props.children, 
    key: `tabpane-${order}`, 
     }); 
    }); 
  } 
  ```

+ 上述代码讲述了子组件集合是怎么渲染的。通过 **React.Children.map 方法**遍历子组件，将 **order（渲染顺序）**、**isActive（是否激活 tab）**、**children（Tabs 组件中传下的 children）**和 key 利用 React 的 **cloneElement 方法**克隆到 Tab Pane 组件中，最后**返回这个 TabPane 组件集合**。这也是 Tabs 组件拼装子组件的基本原理。 

+ 其中，React.Children 是 React 官方提供的一系列操作 children 的方法。它提供诸如 map、forEach、count 等实用函数，可以为我们处理子组件提供便利。 

+ 最后，TabContent 组件的 render 方法只需要调用 getTabPanes 方法即可渲染：

+ ```react
  render() { 
   return (<div>{this.getTabPanes()}</div>); 
  } 
  ```

+ 假如我们把 render 方法中的 this.getTabPanes 方法中对子组件的遍历直接放进去，就会变成
  如下形式：

+ ```react
  render() { 
   return (<div>{React.Children.map(this.props.children, (child) => {...})}</div>); 
  } 
  ```

+ 这种调用方式称为 **Dynamic Children（动态子组件）**。它指的是组件内的子组件是通过动态计算得到的。就像上述对子组件的遍历一样，我们一样可以对任何数据、字符串、数组或对象作动态计算。 

+ 用声明式编程的方式来渲染数据，这种做法和关心所有细节的命令式编程相比，会让我们轻松许多。当然，除了数组的 map 函数，还可以用其他实用的高阶函数，如 reduce、filter 等函数。值得注意的是，与 map 函数相似但不返回调用结果的 forEach 函数不能这么使用。

**组件 props**

+ 我们观察 TabPane 组件中的 tab prop： 

+ ```react
  <TabPane key={0} tab={'Tab 1'}>第一个 Tab 里的内容</TabPane> 
  ```

+ 它现在传入的是一个字符串。那么，假如可以**传入节点**呢，是不是就可以自定义 tab 头展示的形式了。这就是  **component  props**。

+ 对于子组件而言，我们不仅可以直接使用 this.props.children 定义，也可以将子组件以 props 的形式传递。

+ 一般我们会用这种方法来让开发者定义组件的某一个 prop，让其具备多种类型，来做到简单配置和自定义配置组合在一起的效果。 

+ ```react
  <Tabs classPrefix={'tabs'} defaultActiveIndex={0} className="tabs-bar"> 
    <TabPane 
     order="0" 
     tab={<span><i className="fa fa-home"></i>&nbsp;Home</span>}> 
     第一个 Tab 里的内容 
    </TabPane> 
    <TabPane 
     order="1"    tab={<span><i className="fa fa-book"></i>&nbsp;Library</span>}> 
     第二个 Tab 里的内容 
    </TabPane> 
    <TabPane 
     order="2" 
     tab={<span><i className="fa fa-pencil"></i>&nbsp;Applications</span>}> 
     第三个 Tab 里的内容 
    </TabPane> 
  </Tabs> 
  ```

+ 这里我们使用 font-awesome 的图标。渲染后，每一个 tab 上的文字前都会有一个图标，如图 

  + ![1551867107119](F:\OneDrive\JS\纲略合集\assets\1551867107119.png) 

+ 当然，我们也可以加入更多的自定义元素，可以是多行的，甚至可以插入动态数据。这听上去有些复杂，但实现过程其实非常简单。下面是写在 TabNav 组件中简化的渲染子组件集合的方法： 

+ ```react
  getTabs() { 
   const { classPrefix, activeIndex, panels } = this.props; 
   return React.Children.map(panels, (child) => { 
   if (!child) { return; } 
   const order = parseInt(child.props.order, 10); 
     let classes = classnames({ 
    [`${classPrefix}-tab`]: true, 
    [`${classPrefix}-active`]: activeIndex === order, 
    [`${classPrefix}-disabled`]: child.props.disabled, 
     }); 
     return ( 
    <li>{child.props.tab}</li> 
     ); 
    }); 
  } 
  ```

+ 其实现看上去与 getTabPanes 方法非常像，关键在于通过遍历 Tab Pane 组件的 tab prop 来实现我们想要的功能。不论  tab  是以字符串的形式还是以虚拟元素的形式存在，都可以直接在 <li> 标签中渲染出来。 

**用 function prop 与父组件通信**

+ 现在我们发现对于 state 来说，它的通信集中在组件内部；对于 props 来说，它的通信是父组
  件向子组件的传播。相关代码如下：

+ ```react
  handleTabClick(activeIndex) {
  	...
    this.props.onChange({ activeIndex, prevIndex });
  }
  
  renderTabNav() {
    return (
      <TabNav
  			...
        onTabClick={this.handleTabClick}
  			...
        />
    );
  }
  ```

+ 我们通过点击事件 handleTabClick 触发了 onChange prop 回调函数给父组件必要的值。对于兄弟组件或不相关组件之间的通信，具体请看 2.4 节。 

**propTypes**

+ 众所周知，JavaScript 不是强类型语言，我们对在没有保证的环境下写 JavaScript 已经习以为常了。强类型还是弱类型，正是一个开发时的约束问题。React 对此作了妥协，便有了 propTypes。 

+ propTypes 用于规范 props 的类型与必需的状态。如果组件定义了propTypes，那么在开发环境下，就会对组件的 props 值的类型作检查，如果传入的 props 不能与之匹配，React 将实时在控制台里报 warning。**在生产环境下，这是不会进行检查的。** 

+ Tabs 组件包括父组件 Tabs 与子组件 Tab Pane，下面我们分开来讨论两者的 prop Types。

+ 现在，我们先来看 Tabs 组件的 propTypes： 

+ ```js
  static propTypes = {
    className: PropTypes.string,
    classPrefix: PropTypes.string,
    children: PropTypes.oneOfType([
      PropTypes.arrayOf(PropTypes.node),
      PropTypes.node,
    ]),
    defaultActiveIndex: PropTypes.number,
    activeIndex: PropTypes.number,
    onChange: PropTypes.func,
  };
  ```

+ 再来看看 TabPane 组件的 propTypes： 

+ ```react
  static propTypes = {
    tab: PropTypes.oneOfType([
      PropTypes.string,
      PropTypes.node,
    ]).isRequired,
    order: PropTypes.string.isRequired,
    disable: PropTypes.bool,
    isActive: PropTypes.bool,
  };
  ```

+ propTypes 有很多类型支持，不仅有基本类型，还包括枚举和自定义类型。 

### 总结

+ 组件化的一种新的思路，可以做到动态的创建子组件，并且通过props传递属性
+ 之前在一个组件内，重复生成相同的结构都应该被提取成组件，再通过这种方式实现组件化

## React生命周期

+ React  组件的生命周期根据广义定义描述，可以分为**挂载、渲染和卸载**这几个阶段。当渲染后的组件需要更新时，我们会重新去渲染组件，直至卸载。 
+ 因此，我们可以把 React 生命周期分成两类： 
  + 当组件在**挂载或卸载**时；
  + 当组件接收新的数据时，即组件**更新**时。

### 挂载或卸载过程

**组件的挂载**

+ 组件挂载是最基本的过程，这个过程主要做**组件状态的初始化**。我们推荐以下面的例子为模板写初始化组件： 

+ ```react
  import React, { Component, PropTypes } from 'react'; 
  class App extends Component { 
   static propTypes = { 
    // ... 
    }; 
   static defaultProps = { 
    // ... 
    }; 
   constructor(props) { 
     super(props); 
     this.state = { 
    // ... 
     }; 
    } 
   componentWillMount() { 
   // ... 
    } 
   componentDidMount() { 
   // ... 
    } 
   render() { 
     return <div>This is a demo.</div>; 
    } 
  } 
  ```

+ 我们看到 prop Types 和 default Props 分别代表 props 类型检查和默认类型。这两个属性被声明成静态属性，意味着从类外面也可以访问它们，比如可以这么访问：App.prop Types 和 App.default Props。 

+ 之后会看到两个明显的生命周期方法，其中 componentWillMount 方法会在 **render 方法之前执行**，而 componentDidMount 方法会在 **render 方法之后执行**，分别代表了渲染前后的时刻。 

+ 这个初始化过程没什么特别的，包括读取初始  state  和  props  以及两个组件生命周期方法 componentWillMount 和 componentDidMount，**这些都只会在组件初始化时运行一次。** 

+ 如果我们在 componentWillMount 中执行 setState 方法，会发生什么呢？组件会更新 state，**但组件只渲染一次**。因此，这是无意义的执行，初始化时的 state 都可以放在 this.state。 

+ 如果我们在 componentDidMount 中执行 setState 方法，又会发生什么呢？组件当然会再次更新，不过在初始化过程就渲染了两次组件，这并不是一件好事。但实际情况是，有一些场景不得不需要 setState，比如**计算组件的位置或宽高时，就不得不让组件先渲染，更新必要的信息后，再次渲染。** 

**组件的卸载**

+ 组件卸载非常简单，只有 componentWillUnmount 这一个卸载前状态：

+ ```react
  import React, { Component, PropTypes } from 'react'; 
  class App extends Component { 
    componentWillUnmount() { 
   // ... 
    } 
   render() { 
     return <div>This is a demo.</div>; 
    } 
  } 
  ```

+ 在 componentWillUnmount 方法中，我们常常会执行一些**清理方法**，如事件回收或是清除定时器。 

### 数据更新过程

+ 更新过程指的是**父组件向下传递 props** 或**组件自身执行  setState  方法**时发生的一系列更新动作。这里我们屏蔽了初始化的生命周期方法，以便观察更新过程的生命周期： 

+ ```react
  import React, { Component, PropTypes } from 'react'; 
  class App extends Component { 
   componentWillReceiveProps(nextProps) { 
   // this.setState({}) 
    } 
   shouldComponentUpdate(nextProps, nextState) { 
   // return true; 
    } 
   componentWillUpdate(nextProps, nextState) { 
   // ... 
    } 
   componentDidUpdate(prevProps, prevState) { 
   // ... 
    } 
   render() { 
     return <div>This is a demo.</div>; 
    } 
  } 
  ```

+ 如果组件自身的 state 更新了，那么会依次执行 

  + should Component Update、
  + component Will Update 、
  + render 、
  + componentDidUpdate。

+ shouldComponentUpdate 是一个特别的方法，它**接收需要更新的 props 和 state**，让开发者增加
  必要的条件判断，让其在需要时更新，不需要时不更新。因此，当**方法返回 false 的时候**，组件
  不再向下执行生命周期方法。 

+ shouldComponentUpdate 的本质是用来进行**正确的组件渲染**。怎么理解呢？我们需要先从初始
  化组件的过程开始说起，假设有如图 1-8 所示的组件关系，它呈三级的树状结构，其中空心圆表
  示已经渲染的节点。 

+ ![1551871616353](F:\OneDrive\JS\纲略合集\assets\1551871616353.png) 

+ 当父节点 props 改变的时候，在理想情况下，只需渲染在**一条链路**上有相关 props 改变的节
  点即可，如图 1-9 所示。 

+ ![1551871640682](F:\OneDrive\JS\纲略合集\assets\1551871640682.png) 

+ 而默认情况下，React 会**渲染所有的节点**，因为 shouldComponentUpdate **默认返回 true**。正确
  的组件渲染从另一个意义上说，也是性能优化的手段之一。 

+ 值得注意的是，**无状态组件是没有生命周期方法的**，这也意味着它没有  shouldComponent- 
  Update。渲染到该类组件时，**每次都会重新渲染**。当然，不少开发者在使用无状态组件时会纠结
  这一点。为了更放心地使用，我们可以选择引用 Recompose 库的 pure 方法： 

  + const OptimizedComponent = pure(ExpensiveComponent); 

+ 事实上，pure 方法做的事就是将无状态组件转换成 class 语法加上 Pure Render 后的组件。关于性能优化相关的内容，我们会在 2.6 节中详解。 

+ componentWillUpdate  和  component Did Update  这两个生命周期方法很容易理解，对应的初始化
  方法也很容易知道，它们代表在**更新过程中渲染前后的时刻**。此时，我们可以想到  component- 
  Will Update  方法提供**需要更新的  props  和  state**，而  componentDidUpdate  提供**更新前的  props  和** 
  **state。**

+ 这里需要注意的是，你不能在 componentWillUpdate 中执行 setState。如果你对此很感兴趣，想一探究竟，可以直接跳至 3.3 节，那里有更加深入的解释。 

  + why? waiting for your answer

+ 如果组件是由父组件更新  props  而更新的，那么在  shouldComponentUpdate  之前会先执行 
  c**omponentWillReceiveProps 方法**。此方法可以作为 React 在 props 传入后，渲染之前 setState 的
  机会。在此方法中调用 setState 是**不会二次渲染**的。

+ 回想之前介绍 Tabs 组件实现时留下的一个问题：如果 Tabs 组件的 activeIndex prop 只由外组件来更新，那是怎么做到的呢？秘密就在 component Will Receive Props 方法上，相关代码如下：

+ ```react
  componentWillReceiveProps(nextProps) { 
   if ('activeIndex' in nextProps) { 
     this.setState({ 
    activeIndex: nextProps.activeIndex, 
     }); 
    } 
  } 
  ```

+ 这样的设置就是让传入的 props 判断是否存在 activeIndex。如果用了 activeIndex 初始化组件，那么每次组件更新前都会去更新组件内部的 activeIndex state，达到更新组件的目的。 

+ 然后，在  tab  点击事件上，对是否存在 defaultActiveIndex prop  进行判断即可达到在传入 defaultActiveIndex 时使用内部更新，当传入  activeIndex 时使用外部传入的 props 更新。相关代码如下： 

+ ```react
  handleTabClick(activeIndex) { 
   const prevIndex = this.state.activeIndex; 
   if (this.state.activeIndex !== activeIndex && 
    'defaultActiveIndex' in this.props) { 
     this.setState({ 
    activeIndex, 
    prevIndex, 
     }); 
     this.props.onChange({ activeIndex, prevIndex }); 
    } 
  } 
  ```

+ 

### 整体流程 

+ ![1551881036212](F:\OneDrive\JS\纲略合集\assets\1551881036212.png) 
+ 

## React 与 DOM

+ 前面已经介绍完组件的组成部分了，但还缺少最后一环，那就是将组件渲染到真实 DOM 上。
+ 从 React 0.14 版本开始，React 将 React 中涉及 DOM 操作的部分剥离开，目的是为了抽象 React，同时适用于 Web 端和移动端。React DOM 的关注点在 DOM 上，因此只适用于 Web 端。
+ 在 React 组件的开发实现中，我们并不会用到 React DOM，只有在顶层组件以及由于 React 模
  型所限而不得不操作 DOM 的时候，才会使用它。 

### ReactDOM

+ React DOM 中的 API 非常少，只有 findDOMNode、unmountComponentAtNode 和 render。下面我们就从 API 的角度来讲讲它们的用法。 

**findDOMNode**

+ DOM  真正被添加到  HTML  中的生命周期方法是 componentDidMount 和 componentDidUpdate 方法。
+ 在这两个方法中，我们可以**获取真正的 DOM 元素**
+ React 提供的获取 DOM 元素的方法有**两种**，其中一种就是 ReactDOM 提供的 findDOMNode：
+ `DOMElement findDOMNode(ReactComponent component) ` 

+ 当组件被渲染到 DOM 中后，findDOMNode 返回该 React 组件实例**相应的 DOM 节点**。它可以用于获取表单的 value 以及用于 DOM 的测量。例如，假设要在当前组件加载完时获取当前 DOM，则可以使用 findDOMNode：

+ ```react
  import React, { Component } from 'react'; 
  import ReactDOM from 'react-dom'; 
  class App extends Component { 
    componentDidMount() { 
   // this 为当前组件的实例 
   const dom = ReactDOM.findDOMNode(this); 
    } 
   render() {} 
  } 
  ```

+ 如果在 render 中返回 null，那么 findDOMNode 也返回 null。findDOMNode 只对已经挂载的组件有效。 

+ 涉及复杂操作时，还有非常多的原生 DOM API 可以用。但是需要严格限制场景，在使用之前多问自己为什么要操作 DOM。 

**render**

+ 为什么说只有在顶层组件我们才不得不使用  ReactDOM  呢？这是因为要把  React  渲染的 Virtual DOM 渲染到浏览器的 DOM 当中，就要使用 render 方法了： 

+ ```react
  ReactComponent render( 
   ReactElement element, 
    DOMElement container, 
   [function callback] 
  ) 
  ```

+ 该方法把元素挂载到 container 中，并且返回 element 的实例（即 refs 引用）。当然，如果是无状态组件，render 会返回 null。当组件装载完毕时，callback 就会被调用。 

+ 当组件在初次渲染之后再次更新时，React 不会把整个组件重新渲染一次，而会用它高效的 DOM diff 算法做局部的更新。这也是 React 最大的亮点之一！ 

+ 此外，与 render 相反，React 还提供了一个很少使用的 unmountComponentAtNode 方法来进行**卸载操作。** 

### ReactDOM 的不稳定方法

+ React DOM  中有两个不稳定方法，其中一个方法与  render  方法颇为相似。讲起它，还得从我们常用的 Dialog 组件在 React 中的实现讲起。 
+ 我们先来回忆一下 Dialog 组件的特点，它是不在文档流中的弹出框，一般会绝对定位在屏幕的正中央，背后有一层半透明的遮罩。因此，它往往直接渲染在 document.body 下，然而我们并不知道如何在 React 组件外进行操作。这就要从实现 Dialog 的思路以及涉及 DOM 部分的实现讲起。 
+ 这里我们引入 Portal 组件，这是一个经典的实现，最初的实现来源于 React Bootstrap 组件库中的 Overlay Mixin，后来使用越来越广泛。我们截取关键部分的源码： 

+ 这就说到了 React DOM 中不稳定的 API 方法 unstable_renderSubtreeIntoContainer。它的作用很简单，就是更新组件到传入的 DOM 节点上，我们在这里使用它完成了在组件内实现跨组件的 DOM 操作。 
+ 这个方法与  render  方法很相似，但  render  方法缺少一个插入某个节点的参数。从最终 React DOM  方 法 实 现 的 源 代 码   react/src/renderers/dom/client/ReactMount.js  中 可 以 了 解 到 ， 
  unstable_renderSubtreeIntoContainer 与 render 方法对应调用的方法如下。 
  + render： 
    + React Mount._render Subtree Into Container(null, nextElement, container, callback)
  + \_unstable_render Subtree Into Container： 
    + React Mount._render Subtree Into Container(parent Component,nextElement, container, callback)。
+ 源码证明了我们的猜想，这也说明了两者的**区别在于是否传入父节点**。 
+ 此外，另一个 React DOM 中的不稳定方法 unstable_batchedUpdates 是关于 setState 的更新策略，我们会在 3.4.5 中详细介绍。 

### refs 

+ 在组件内，JSX 是不会返回一个组件的实例的！它只是一个 React Element ，只是告诉 React 被挂载的组件应
  该长什么样： 

+ ```react
  const myApp = <App />;  // Symbol(react.element)
  ```

+ refs 就是为此而生的，它是 React 组件中非常特殊的 prop，可以附加到任何一个组件上。从字面意思来看，refs 即 reference，组件被调用时会新建一个该组件的实例，而 refs 就会指向这个实例。 

+ 把 refs 放到原生的 DOM 组件 input 中，我们可以通过 refs 得到 DOM 节点；

+ 而如果把 refs 放到 React 组件，比如 <TextInput />，我们获得的就是 TextInput 的实例，因
  此就可以调用 TextInput 的实例方法。 

+ ![1551882920620](F:\OneDrive\JS\纲略合集\assets\1551882920620.png) 

+ refs 同样支持字符串。对于 DOM 操作，不仅可以使用 findDOMNode 获得该组件 DOM，还可以使用 refs 获得组件内部的 DOM。
+ 为了防止内存泄漏，当卸载一个组件的时候，组件里所有的 refs 就会变为 null。
+ 值得注意的是，findDOMNode 和 refs 都无法用于无状态组件中，原因在前面已经说过。无状态组件挂载时只是方法调用，没有新建实例。 
+ 对于 React 组件来说，refs 会指向一个组件类的实例，所以可以调用该类定义的任何方法。
+ 如果需要访问该组件的真实 DOM，可以用 ReactDOM.findDOMNode 来找到 DOM 节点，但我们并
  不推荐这样做。因为这在大部分情况下都打破了封装性，而且通常都能用更清晰的办法在 React 
  中构建代码。 

### React 之外的 DOM 操作 

+ DOM 操作可以归纳为对 DOM 的增、删、改、查。
+ 这里的“查”指的是对 DOM 属性、样式的查看，比如查看 DOM 的位置、宽、高等信息。
+ 而要对 DOM 进行增、删、改，就要先到 DOM 中查询元素。 

+ React 的声明式渲染机制把复杂的 DOM 操作抽象为简单的 state 和 props 的操作，因此避免了很多直接的 DOM 操作。不过，仍然有一些 DOM 操作是 React 无法避免或者正在努力避免的。 

+ 举一个明显的例子，如果要调用 HTML5 Audio/Video 的 play 方法和 input 的 focus 方法，React 就无能为力了，这时只能使用相应的 DOM 方法来实现。 

+ React 提供了事件绑定的功能，但是仍然有一些特殊情况需要自行绑定事件，例如 Popup 等组件，当点击组件其他区域时可以收缩此类组件。这就要求我们对组件以外的区域（一般指 document 和 body）进行事件绑定。
+ React 中使用 DOM 最多的还是计算 DOM 的尺寸（即位置信息）。我们可以提供像 width 或 height 这样的工具函数
+ 但上述计算方法并不能完全覆盖所有情况，这需要付出不少的成本去实现。值得高兴的是，React 正在自己构建一个 DOM 排列模型，来努力避免这些 React 之外的 DOM 操作。我们相信在不久的将来，React 的使用者就可以完全抛弃掉 j Query 等 DOM 操作库。 

## 组件化实例：Tabs 组件 

# 2. 漫谈 React

## 事件系统

- Virtual DOM 在内存中是以对象的形式存在的，如果想要在这些对象上添加事件，就会非常简单。
- React 基于 Virtual DOM 实现了一个 **SyntheticEvent （合成事件）层**，我们所定义的事件处理器会接收到一个 SyntheticEvent 对象的实例，它完全符合 W3C 标准，不会存在任何 IE 标准的兼容性问题。并且与原生的浏览器事件一样拥有同样的接口，同样支持事件的冒泡机制，我们可以使用 stopPropagation() 和 preventDefault() 来中断它。 
- 所有事件都自动绑定到最外层上。如果需要访问原生事件对象，可以使用 nativeEvent 属性。 

### 合成事件的绑定方式



- \<button onClick={this.handleClick}>Test</button> 
- 仔细观察，我们会发现这种写法与 **DOM0 级事件**中直接设置 HTML 标签属性为事件处理器的做法还是有很大不同的。
  - 在  JSX  中，我们必须使用**驼峰的形式**来书写事件的属性名（比如onClick），而  HTML  事件则需要使用全部小写的属性名（比如  onclick）。
  - 此外，HTML  的属性值只能是 JavaScript 代码字符串，而在 JSX 中，props 的值则可以是任意类型，这里是一个函数指针。如果使用 **DOM0 级事件的写法**，会是这样的：
  - \<button onclick="handleClick()">Test</button> 
- React 并不会像 DOM0 级事件那样将事件处理器直接绑定到 HTML 元素之上。React 仅仅是借鉴了这种写法而已。

### 合成事件的实现机制 

- 在React底层，主要对合成事件做了两件事：事件委派和自动绑定

**事件委派**

- 在使用 React 事件前，一定要熟悉它的**事件代理机制**。
- 它并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到**结构的最外层**，使用一个统一的事件监听器，这个事件监听器上维持了一个**映射**来保存所有组件内部的**事件监听和处理函数**。
- 当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。 

**自动绑定**

- 在 React 组件中，每个方法的上下文都会指向该组件的实例，即自动绑定 this 为当前组件。

- 而且 React 还会对这种引用进行缓存，以达到 CPU 和内存的最优化。

- 在**使用 ES6 classes 或者纯函数**时，这种自动绑定就不复存在了，我们需要手动实现 this 的绑定。

- **bind 方法**：

  - 这个方法可以帮助我们绑定事件处理器内的 this ，并可以向事件处理器中传递参数，比如：

  - ```react
    import React, { Component } from 'react';
    class App extends Component { 
     handleClick(e, arg) { 
     console.log(e, arg); 
      } 
     render() { 
       // 通过bind方法实现，可以传递参数 
       return <button onClick={this.handleClick.bind(this, 'test')}>Test</button>; 
      } 
    } 
    
    ```

  - 如果方法只绑定，不传参，那 stage 0 草案中提供了一个便捷的方案①——**双冒号语法**，其作
    用与 this.handleClick.bind(this) 一致，并且 Babel 已经实现了该提案。比如：

  - ```react
    import React, { Component } from 'react'; 
    class App extends Component { 
     handleClick(e) { 
       console.log(e); 
      } 
     render() { 
       return <button onClick={::this.handleClick}>Test</button>; 
      } 
    } 
    
    ```

  - 使用这种形式，每次调用函数都会返回一个新的函数

- **构造器内声明**

  - 在组件的构造器内完成了 this 的绑定，这种绑定方式的好处在于仅需要进行一次绑定，而不需要每次调用事件监听器时去执行绑定操作：

  - ```react
    import React, { Component } from 'react';
    class App extends Component {
     constructor(props) { 
       super(props); 
       this.handleClick = this.handleClick.bind(this); 
      } 
     handleClick(e) { 
       console.log(e); 
      } 
     render() { 
       return <button onClick={this.handleClick}>Test</button>; 
      } 
    }
    ```

- **箭头函数**

  - 箭头函数不仅是函数的“语法糖”，它还自动绑定了定义此函数作用域的 this，因此我们不需要再对它使用 bind 方法。比如，以下方式就能运行：

  - ```react
    import React, { Component } from 'react';
    class App extends Component {
     const handleClick = (e) => { 
       console.log(e); 
      }; 
     render() { 
       return <button onClick={this.handleClick}>Test</button>; 
      } 
    } 
    
    // 或
    import React, { Component } from 'react'; 
    class App extends Component { 
     handleClick(e) { 
       console.log(e); 
      } 
     render() { 
        return <button onClick={() => this.handleClick()}>Test</button> 
      } 
    } 
    ```

### 在 React 中使用原生事件 

- React  提供了很好用的合成事件系统，但这并不意味着在  React  架构下无法使用原生事件。

- React 提供了完备的生命周期方法，其中 componentDidMount 会在组件已经完成安装并且在浏览器
  中**存在真实的 DOM 后调用**，此时我们就可以完成原生事件的绑定。比如：

- ```react
  import React, { Component } from 'react'; 
  class NativeEventDemo extends Component { 
    componentDidMount() { 
   this.refs.button.addEventListener('click', e => { 
    this.handleClick(e); 
     }); 
    } 
   handleClick(e) { 
     console.log(e); 
    } 
    componentWillUnmount() { 
     this.refs.button.removeEventListener('click'); 
    } 
   render() { 
     return <button ref="button">Test</button>; 
    } 
  } 
  
  ```

- 值得注意的是，在 React 中使用 DOM 原生事件时，一定要**在组件卸载时手动移除**，否则很可能出现内存泄漏的问题。而使用合成事件系统时则不需要，因为 React 内部已经帮你妥善地处理了。

### 合成事件与原生事件混用

- 很多应用场景只能借助原生事件的帮助才能完成。比如，在 Web 页面中添加一个使用移动设备扫描二维码的功能，在点击按钮时显示二维码，点击非二维码区域时将其隐藏起来。示例代码如下：

- ```react
  import React, { Component } from 'react'; 
  class QrCode extends Component { 
    constructor(props) { 
      super(props); 
      this.handleClick = this.handleClick.bind(this); 
      this.handleClickQr = this.handleClickQr.bind(this); 
      this.state = { 
        active: false, 
      }; 
    } 
    componentDidMount() { 
      document.body.addEventListener('click', e => { 
        this.setState({ 
          active: false, 
        }); 
      }); 
    } 
    componentWillUnmount() { 
      document.body.removeEventListener('click'); 
    } 
    handleClick() { 
      this.setState({ 
        active: !this.state.active, 
      }); 
    } 
    handleClickQr(e) { 
      e.stopPropagation(); // 这一步无意义
    } 
    render() { 
      return ( 
        <div className="qr-wrapper"> 
          <button className="qr" onClick={this.handleClick}>二维码</button> 
          <div 
            className="code" 
            style={{ display: this.state.active ? 'block' : 'none' }} 
            onClick={this.handleClickQr} 
            > 
            <img src="qr.jpg" alt="qr" /> 
          </div> 
        </div> 
      ); 
    } 
  } 
  
  ```

- 上述代码的逻辑很简单，点击按钮可以切换二维码的显示与隐藏，而在按钮之外的区域同样可以达到隐藏的效果。然而，我们**无法在组件中将事件绑定到 body 上**，因为 body 在组件范围之外，只能使用**原生**绑定事件来实现。 

- 逻辑似乎很简单，但 React 所表现的似乎与你所想的并不一致，实际效果是在你点击二维码区域时二维码依然会隐藏起来。

- 原因也很简单，就是 React 合成事件系统的委托机制，在合成事件内部仅仅对**最外层的容器**进行了绑定，并且依赖事件的冒泡机制完成了委派。也就是说，事件并没有直接绑定到 div.qr 元素上，所以在这里使用 e.stopPropagation() 并没有用。当然，解决方法也很简单

  - 不要将合成事件与原生事件混用：

  - ```react
    componentDidMount() {
      document.body.addEventListener('click', e => { 
        this.setState({ 
          active: false, 
        }); 
      }); 
      document.querySelector('.code').addEventListener('click', e => { 
        e.stopPropagation();
      }) 
    } 
    componentWillUnmount() { 
      document.body.removeEventListener('click'); 
      document.querySelector('.code').removeEventListener('click'); 
    } 
    ```

  - 通过 e.target 判断来避免：

  - ```react
    componentDidMount() {
     document.body.addEventListener('click', e => { 
       if (e.target && e.target.matches('div.code')) { 
      return; 
       } 
       this.setState({ 
      active: false, 
       }); 
      }); 
    } 
    ```

- 所以，请尽量避免在 React 中混用合成事件和原生 DOM 事件。另外，用 reactEvent.nativeEvent.
  stopPropagation() 来阻止冒泡是不行的。阻止 React 事件冒泡的行为只能用于 React 合成事件系统
  中，且**没办法阻止原生事件的冒泡**。但是，在原生事件中的阻止冒泡行为，却可以阻止 React 合成
  事件的传播。 

- 实际上，React  的合成事件系统只是原生  DOM  事件系统的一个子集。它仅仅实现了 **DOM Level 3 的事件**接口，并且统一了浏览器间的兼容问题。有些事件 React 并没有实现，或者受某些限制没办法去实现，比如 window 的 resize 事件。 

### 对比合成事件与原生事件

- 下面我们从 4 个方面来对比 React 合成事件与 JavaScript 原生事件。 

#### 事件传播与阻止事件传播

- 浏览器原生 DOM 事件的传播可以分为 3 个阶段：事件捕获阶段、目标对象本身的事件处理程序调用以及事件冒泡。事件捕获会优先调用结构树最外层的元素上绑定的事件监听器，然后依次向内调用，一直调用到目标元素上的事件监听器为止。可以在将 e.addEventListener() 的第三个参数设置为 true 时，为元素 e 注册捕获事件处理程序，并且在事件传播的第一个阶段调用。
- 此外，事件捕获并不是一个通用的技术，在低于 IE9 版本的浏览器中无法使用。而事件冒泡则与事件捕获的表现相反，它会从目标元素向外传播事件，由内而外直到最外层。

- 可以看出，事件捕获在程序开发中的意义并不大，更致命的是它的兼容性问题。所以，React 的合成事件则**并没有实现事件捕获**，仅仅支持了事件冒泡机制。这种 API 设计方式统一而简洁，符合“二八原则”。 

- 阻止原生事件传播需要使用  e.preventDefault()，不过对于不支持该方法的浏览器（IE9 以下），只能使用 e.cancel Bubble = true 来阻止。而在 React 合成事件中，**只需要使用 e.preventDefault() 即可**。 

#### 事件类型

- React 合成事件的事件类型是 JavaScript 原生事件类型的一个**子集**。

#### 事件绑定方式

- 受到 DOM 标准的影响，绑定浏览器**原生事件**的方式也有很多种，具体如下所示
  - 直接在 DOM 元素中绑定：
    `<button onclick="alert(1);">Test</button>`
  - 在 JavaScript 中，通过为元素的事件属性赋值的方式实现绑定：
    `el.onclick = e => { console.log(e); }`
  - 通过事件监听函数来实现绑定：
    `el.addEventListener('click', () => {}, false);`
    `el.attachEvent('onclick', () => {});`
- 相比而言，React **合成事件**的绑定方式则简单得多： 
  `<button onClick={this.handleClick}>Test</button> `

**事件对象**

- 原生 DOM 事件对象在 W3C 标准和 IE 标准下存在着差异。在低版本的 IE 浏览器中，只能使用 window.event来获取事件对象。而在 React 合成事件系统中，不存在这种兼容性问题，在事件处理函数中可以得到一个合成事件对象。 

## 表单

- 在 Web 应用开发中，表单的作用尤为重要。正是因为表单的存在，才使得用户能够与 Web 应用进行富交互。打开搜索引擎输入关键字进行检索，这个过程就是一次基于表单的交互。而在 React  中，**一切数据都是状态**，当然也包括表单数据。在这一节中，我们将讲述  React  是如何处理表单的。

### 应用表单组件

- HTML 表单中的所有组件在 React 的 JSX 都有相应的实现，只是它们在用法上有些**区别**，有些是 **JSX 语法**上的，有些则是由于 **React 对状态处理**上导致的一些区别。

#### 文本框

- 此处的文本框包含单行输入input type='text'，以及多行输入框textarea

- ```react
  import React, { Component } from 'react'; 
  class App extends Component { 
    constructor(props) { 
      super(props); 
      this.handleInputChange = this.handleInputChange.bind(this); 
      this.handleTextareaChange = this.handleTextareaChange.bind(this); 
      this.state = { 
        inputValue: '', 
        textareaValue: '', 
      }; 
    } 
    handleInputChange(e) { 
      this.setState({ 
        inputValue: e.target.value, 
      }); 
    } 
    handleTextareaChange(e) { 
      this.setState({ 
        textareaValue: e.target.value, 
      }); 
    }  
    render() { 
      const { inputValue, textareaValue } = this.state; 
      return ( 
        <div> 
          <p>单行输入框：<input type="text" value={inputValue} 
                     onChange={this.handleInputChange} /></p> 
          <p>多行输入框：<textarea value={textareaValue} 
                     onChange={this.handleTextareaChange} /></p> 
        </div> 
      ); 
    } 
  } 
  
  ```

#### 单选按钮与复选框

- 在 HTML 中，用类型为 radio 的 input 标签表示单选按钮。类似地，用类型为 checkbox 的input  标签表示复选框。这两种表单的  value  值一般是不会改变的，而是通过一个布尔类型的 checked prop 来表示是否为选中状态。当然，在 JSX 中这些也是相同的，不过用法上还是有些区别。 

- 单选按钮示例：

- ```react
  import React, { Component } from 'react'; 
  class App extends Component { 
    constructor(props) { 
      super(props); 
      this.handeChange = this.handleChange.bind(this); 
      this.state = { 
        radioValue: '', 
      }; 
    } 
    handleChange(e) { 
      this.setState({ 
        radioValue: e.target.value, 
      }); 
    } 
    render() { 
      const { radioValue } = this.state; 
      return ( 
        <div> 
          <p>gender:</p> 
          <label>
            male: 
            <input 
              type="radio" 
              value="male" 
              checked={radioValue === 'male'} 
              onChange={this.handleChange} 
              /> 
          </label> 
          <label> 
            female: 
            <input 
              type="radio" 
              value="female" 
              checked={radioValue === 'female'} 
              onChange={this.handleChange} 
              /> 
          </label> 
        </div> 
      ); 
    } 
  } 
  
  ```

- 复选框的示例：

- ```react
  import React, { Component } from 'react'; 
  class App extends Component { 
    constructor(props) { 
      super(props); 
      this.handleChange = this.handleChange.bind(this); 
      this.state = { 
        coffee: [], 
      }; 
    } 
    handleChange(e) { 
      const { checked, value } = e.target; 
      let { coffee } = this.state; 
      if (checked && coffee.indexOf(value) === -1) { 
        coffee.push(value); 
      } else { 
        coffee = coffee.filter(i => i !== value); 
      } 
      this.setState({ 
        coffee, 
      }); 
    } 
    render() { 
      const { coffee } = this.state;
      return ( 
        <div> 
          <p>请选择你最喜欢的咖啡：</p> 
          <label> 
            <input 
              type="checkbox" 
              value="Cappuccino" 
              checked={coffee.indexOf('Cappuccino') !== -1} 
              onChange={this.handleChange} 
              /> 
            Cappuccino 
          </label> 
          <br/> 
          <label> 
            <input 
              type="checkbox" 
              value="CafeMocha" 
              checked={coffee.indexOf('CafeMocha') !== -1} 
              onChange={this.handleChange} 
              /> 
            CafeMocha 
          </label> 
          <br/> 
          <label> 
            <input 
              type="checkbox" 
              value="CaffeLatte" 
              checked={coffee.indexOf('CaffeLatte') !== -1} 
              onChange={this.handleChange} 
              /> 
            Caffè Latte 
          </label> 
          <br/> 
          <label> 
            <input 
              type="checkbox" 
              value="Machiatto" 
              checked={coffee.indexOf('Machiatto') !== -1} 
              onChange={this.handleChange} 
              /> 
            Machiatto 
          </label> 
        </div> 
      ); 
    } 
  } 
  ```

- 如果之前没有了解过，一定会对 React 的处理方式产生疑问。在 HTML 中，很简单的单选按钮和复选框好像变得很复杂了。确实，因为 React 对表单的状态进行了控制，相应地多了一些处理  on Change  的代码。另外，状态里面已经可以拿到复选框所表示的选中值的列表，这一步在 HTML 表单处理中同样需要我们通过 JavaScript 手动处理。

#### Select 组件

+ 在 HTML 的 select 元素中，存在单选和多选两种。在 JSX 语法中，同样可以通过设置 select 标签的 multiple={true} 来实现一个多选下拉列表。Select 组件与单选按钮和复选框组件有些类似。下面我们来看下 React 中 select 元素的用法： 

+ ```react
  import React, { Component } from 'react'; 
  class App extends Component { 
    constructor(props) { 
      super(props); 
      this.handleChange = this.handleChange.bind(this); 
      this.state = { 
        area: '', 
      }; 
    } 
    handleChange(e) { 
      this.setState({ 
        area: e.target.value, 
      }); 
    } 
    render() { 
      const { area } = this.state; 
      return ( 
        <select value={area} onChange={this.handleChange}> 
          <option value="beijing">北京</option> 
          <option value="shanghai">上海</option> 
          <option value="hangzhou">杭州</option> 
        </select> 
      ); 
    } 
  } 
  ```

+ 给 select 元素设置 multiple={true} 的示例

+ ```react
  import React, { Component } from 'react'; 
  class App extends Component { 
    constructor(props) { 
      super(props); 
      this.handleChange = this.handleChange.bind(this); 
      this.state = { 
        area: ['beijing', 'shanghai'], 
      }; 
    } 
    handleChange(e) { 60   第 2 章  漫谈 React 
    const { options } = e.target; 
                     // 注意，这里返回的 options 是一个对象，并非数组 
                     const area = Object.keys(options) 
                     .filter(i => options[i].selected === true) 
                     .map(i => options[i].value); 
                     this.setState({ 
                       area, 
                     }); 
                    } 
    render() { 
      const { area } = this.state; 
      return ( 
        <select multiple={true} value={area} onChange={this.handleChange}> 
          <option value="beijing">北京</option> 
          <option value="shanghai">上海</option> 
          <option value="hangzhou">杭州</option> 
        </select> 
      ); 
    } 
  } 
  
  ```

+ 这里，我们再来对比一下 React 处理 select 的方式与 HTML 原生方式的区别。在 HTML 的option  组件中需要一个  selected  属性来表示默认选中的列表项，而  React  的处理方式则是通过为 select 组件添加 value prop 来表示选中的 option ，在设置了 multiple={true} 的情况下，该value 值是一个数组，表示选中的一组值。这一点与 textarea 的处理方式一致，这在一定程度上统一了接口。 

### 受控组件

+ 在上面的示例中，每当表单的状态发生变化时，都会被写入到组件的  state 中，这种组件在 React 中被称为受控组件（controlled component）。在受控组件中，组件渲染出的状态与它的 value 或 checked prop 相对应。React 通过这种方式消除了组件的局部状态，使得应用的整个状态更加可控。React 官方同样推荐使用受控表单组件。

+ 总结下 React 受控组件更新 state 的流程： 

  (1) 可以通过在初始 state 中设置表单的默认值。 
  (2) 每当表单的值发生变化时，调用 onChange 事件处理器。 
  (3) 事件处理器通过合成事件对象 e 拿到改变后的状态，并更新应用的 state。 
  (4) setState 触发视图的重新渲染，完成表单组件值的更新。 

+ 在 React 中，数据是单向流动的。从示例中，我们能看出来表单的数据源于组件的 state，并通过 props 传入，这也称为**单向数据绑定**。然后，我们又通过 onChange 事件处理器将新的表单数据写回到组件的 state，完成了**双向数据绑定**。 

+ 与原生表单组件相比，受控组件的模式确实复杂了很多。每次表单值发生变化时，都会执行上面几步，这样统一了组件内部状态，使得表单的状态更可靠。这也意味着我们可以在执行最后一步 setState 前，对表单值进行清洗和校验。示例如下： 

  + ```react
    handleChange(e) { 
      this.setState({ 
       value: e.target.value.substring(0, 140).toUpperCase(), 
      }); 
    } 
    ```

+ 上面的代码做到了截取用户输入的前 140 个字符，并转为大写。实际上，在 React 内部**拦截**了浏览器的**原生事件**，这得益于 Virtual DOM 以及合成事件系统。

### 非受控组件 

+ 简单地说，如果一个表单组件没有 value props（单选按钮和复选框对应的是 checked prop）时，就可以称为非受控组件。相应地，你可以使用 defaultValue 和 defaultChecked prop 来表示`组件的默认状态。下面通过一个简单的示例来描述非受控组件： 

+ ```react
  import React, { Component } from 'react'; 
  class App extends Component { 
    constructor(props) { 
      super(props); 
      this.handleSubmit = this.handleSubmit.bind(this); 
    } 
    handleSubmit(e) { 
      e.preventDefault();
      // 这里使用 React 提供的 ref prop 来操作 DOM
      // 当然，也可以使用原生的接口，如 document.querySelector 
      const { value } = this.refs.name; 
      console.log(value); 
    } 
    render() { 
      return ( 
        <form onSubmit={this.handleSubmit}> 
          <input ref="name" type="text" defaultValue="Hangzhou" /> 
          <button type="submit">Submit</button> 
        </form> 
      ); 
    } 
  } 
  ```

+ 在 React 中，非受控组件是一种反模式，它的值不受组件自身的 state 或 props 控制。通常，需要通过为其添加 ref prop 来访问渲染后的底层 DOM 元素。 

### 对比受控组件和非受控组件

+ 受控组件与非受控组件到底各自有什么特点和适用场景呢？ 

+ 我们刚才看到通过 defaultValue 或者 defaultChecked 来设置表单的默认值，它仅会**被渲染**
  **一次**，在后续的渲染时并不起作用。下面对比以下两个示例。 

+ 将输入的字母转化为大写展示： 

  + ```react
    <input 
      value={this.state.value} 
     onChange={e => { 
       this.setState({ value: e.target.value.toUpperCase() }) 
      }} 
    /> 
    ```

+ 直接展示输入的字母： 

  + ```react
    <input 
      defaultValue={this.state.value} 
     onChange={e => { 
       this.setState({ value: e.target.value.toUpperCase() }) 
      }} 
    /> 
    ```

+ 在受控组件中，可以将用户输入的英文字母转化为大写后输出展示，而在非受控组件中则不会。

+ 而如果不对受控组件绑定  change 事件，我们在文本框中**输入任何值都不会起作用**。

+ 多数情况下，对于非受控组件，我们并不需要提供  change 事件。

+ 通过上面的示例可以看出，受控组件和非受控组件的**最大区别**是：非受控组件的状态并不会受应用**状态**的控制，应用中也多了局部组件状态，而受控组件的值来自于组件的 state。 

#### 性能上的问题

+ 在受控组件中，每次表单的值发生变化时，都会调用一次  onChange  事件处理器，这确实会有一些性能上的损耗。
+ 虽然使用非受控组件不会出现这些问题，但仍然不提倡在 React 中使用非受控组件。这个问题可以通过 Flux/Redux 应用架构等方式来达到统一组件状态的目的。 

#### 是否需要事件绑定

+ 使用受控组件最令人头疼的就是，我们需要为每个组件绑定一个  change  事件，并且定义一个事件处理器来同步表单值和组件的状态，这是一个**必要条件**。当然，在某些简单的情况下，也可以使用一个事件处理器来处理多个表单域： 

  + ```react
    import React, { Component } from 'react'; 
    class FormApp extends Component { 
      constructor(props) { 
        super(props); 
        this.state = { 
          name: '', 
          age: 18, 
        }; 
      } 
      handleChange(name, e) { 
        const { value } = e.target; 
        // 这里只能处理直接赋值这种简单的情况，复杂的处理建议使用 switch(name) 语句 
        this.setState({ 
          [name]: value, 
        }); 
      } 
      render () { 
        const { name, age} = this.state; 
        return ( 
          <div> 
            <input value={name} onChange={this.handleChange.bind(this, 'name')} /> 
            <input value={age} onChange={this.handleChange.bind(this, 'age')} /> 
          </div> 
        ); 
      } 
    } 
    
    ```

### 表单组件的几个重要属性 

#### 状态属性

+ React 的 form 组件提供了几个重要的属性，用于展示组件的状态。 
+ **value**：类型为 text 的 input 组件、textarea 组件以及 select 组件都借助 **value prop 来展示**
  **应用的状态。**
+ **checked**：类型为 radio 或 checkbox 的组件借助值为 boolean 类型的 **selected prop 来展示**
  **应用的状态。**
+ **selected**：该属性可作用于 select 组件下面的 option 上，React 并不建议使用这种方式表
  示状态，而推荐**在 select 组件上使用 value 的方式**。

#### 事件属性

+ 刚刚提到的状态属性与事件属性存在一定的关联——在状态属性发生变化时，会触发 onChange 事件属性。实际上，受控组件中的 change 事件与 HTML DOM 中提供的 input 事件更为类似①。同样，React 支持 DOM Level 3 中定义的所有表单事件。 

+ > GlobalEventHandlers.oninput，详见 https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/oninput。 

## 样式处理

+ 在 React 中，处理样式是至关重要的一环，也是当下非常热门的话题。在这一节中，我们除了介绍基本样式设置之外，还会讲到现在业界很火的 CSS Modules 的概念及用法。 

### 基本样式设置

+ React 组件最终会生成 HTML，所以你可以使用给普通 HTML 设置 CSS 一样的方法来设置样式。

+ 如果我们想给组件添加类名，为了避免命名冲突，React 中需要设置 className prop。此外，也可以通过 style prop 来给组件设置行内样式，这里要注意 style prop 需要的是一个对象。 

+ ```react
  const style = { 
   color: 'white', 
    backgroundImage: `url(${imgUrl})`, 
    // 注意这里大写的 W，会转换成 -webkit-transition 
   WebkitTransition: 'all', 
   // ms 是唯一小写的浏览器前缀 
    msTransition: 'all', 
  }; 
  
  const component = <Component style={style} />; 
  ```

**样式中的像素值**

+ 当设置 width 和 height 这类与大小有关的样式时，大部分会以像素为单位，此时若重复输入 px，会很麻烦。为了提高效率，React 会自动对这样的属性添加 px。
+ 注意，有些属性除了支持 px 为单位的像素值，还支持数字直接作为值，此时 React 并不添加 px，如 lineHeight①。 

**使用 classnames 库**

+ 在 React 0.13 版本之前，React 官方提供 React.addons.class Set 插件来给组件动态设置 class Name，这在后续版本中被移除（为了精简 API ）。我们可以使用 classnames 库来操作类。 

+ 如果不使用 classnames 库，就需要这样处理动态类名：

  + ```react
    import React, { Component } from 'react'; 
    class Button extends Component { 
      // ... 
      render() { 
        let btnClass = 'btn'; 
        if (this.state.isPressed) { btnClass += ' btn-pressed'; } 
        else if (this.state.isHovered) { btnClass += ' btn-over'; } 
        return <button className={btnClass}>{this.props.label}</button>; 
      } 
    }; 
    
    ```

+ 使用了 classnames 库代码后，就可以变得很简单：

  + ```react
    import React, { Component } from 'react'; 
    import classNames from 'classnames'; 
    class Button extends Component { 
      // ... 
      render() { 
        const btnClass = classNames({ 
          'btn': true, 
          'btn-pressed': this.state.isPressed, 
          'btn-over': !this.state.isPressed && this.state.isHovered, 
        }); 
        return <button className={btnClass}>{this.props.label}</button>; 
      } 
    }); 
    
    ```

### CSS Modules 

+ CSS 模块化的解决方案有很多，但主要有两类。
  + Inline Style。这种方案彻底抛弃 CSS，使用 JavaScript 或 JSON 来写样式，能给 CSS 提供JavaScript 同样强大的模块化能力。但缺点同样明显，Inline Style 几乎不能利用 CSS 本身的特性，比如级联、媒体查询（media query）等，:hover 和 :active 等伪类处理起来比较复杂。另外，这种方案需要依赖框架实现，其中与  React  相关的有  Radium、jsxstyle  和react-style。
  + CSS Modules。依旧使用 CSS，但使用 JavaScript 来管理样式依赖。CSS Modules 能最大化地结合现有 CSS 生态和 JavaScript 模块化能力，其 API 非常简洁，学习成本几乎为零。发布时依旧编译出单独的  JavaScript  和  CSS  文件。现在，webpack  css-loader  内置  CSS Modules 功能。

**CSS 模块化遇到了哪些问题？**

+ CSS 模块化重要的是解决好以下两个问题：**CSS 样式的导入与导出**。
+ 灵活**按需导入**以便复用代码，导出时要能够**隐藏内部作用域**，以免造成全局污染。Sass、Less、Post CSS 等试图解决 CSS 编程能力弱的问题，但这并没有解决模块化这个问题。
+ Facebook 工程师 Vjeux 抛出了 React 开发中遇到的一系列 CSS 相关问题，结合实际开发的问题有以下几点。 
  + **全局污染**：CSS  使用全局选择器机制来设置样式，优点是方便重写样式。缺点是所有的样式都是全局生效，样式可能被错误覆盖，因此产生了非常丑陋的  !important，甚至inline  !important  和复杂的选择器权重计数表①，提高犯错概率和使用成本。Web Components 标准中的 Shadow DOM 能彻底解决这个问题，但它把样式彻底局部化，造成外部无法重写样式，损失了灵活性。
  + **命名混乱**：由于全局污染的问题，多人协同开发时为了避免样式冲突，选择器越来越复杂，容易形成不同的命名风格，很难统一。样式变多后，命名将更加混乱。
  + **依赖管理不彻底**：组件应该相互独立，引入一个组件时，应该只引入它所需要的 CSS 样式。现在的做法是除了要引入 JavaScript，还要再引入它的 CSS，而且 Saas/Less 很难实现对每个组件都编译出单独的 CSS，引入所有模块的 CSS 又造成浪费。JavaScript 的模块化已经非常成熟，如果能让 JavaScript 来管理 CSS 依赖是很好的解决办法，而 webpack 的 **css-loader 提供了这种能力**。
  + **无法共享变量**：复杂组件要使用 JavaScript 和 CSS 来共同处理样式，就会造成有些变量在 JavaScript 和 CSS 中冗余，而预编译语言不能提供跨 JavaScript 和 CSS 共享变量的这种能力。
  + **代码压缩不彻底**：由于移动端网络的不确定性，现代工程项目对 CSS 压缩的要求已经到了变态的程度。很多压缩工具为了节省一个字节,会把 16px 转成 1pc，但是这对非常长的类名却无能为力。

+ 上述问题只凭 CSS 自身是无法解决的，如果通过 JavaScript 来管理 CSS，就很好解决。因此，Vjuex 给出的解决方案是完全的 CSS in JS①，但这相当于完全抛弃 CSS，在 Java Script 中以 hash 映射来写 CSS，但这种做法未免有些激进，直到出现了 CSS Modules。 

**CSS Modules 模块化方案**

+ CSS  Modules  内部通过 ICSS 来解决样式导入和导出这两个问题，分别对应   **:import 和 :export 两个新增的伪类：** 

  + ```css
    :import("path/to/dep.css") { 
     localAlias: keyFromDep; 
     /* ... */ 
    } 
    :export { 
     exportedKey: exportedValue; 
     /* ... */ 
    } 
    ```

+ 但直接使用这两个关键字编程太烦琐，项目中很少会直接使用它们，我们需要的是用 JavaScript  来管理  CSS  的能力。结合  webpack  的  css-loader，就可以**在  CSS  中定义样式，在 JavaScript 文件中导入**。 

**启用 CSS Modules**

+ 启用 CSS Modules 的代码如下： 

  + ```js
    // webpack.config.js
    css?modules&localIdentName=[name]__[local]-[hash:base64:5] 
    ```

+ 加上 modules 即为启用，其中 localIdentName 是设置生成样式的命名规则。

+ 下面我们直接看看怎么引用 CSS，webpack 又是怎么转化 class 名的： 

  + ```css
    /* components/Button.css */
    .normal { /* normal 相关的所有样式 */ } 
    .disabled { /* disabled 相关的所有样式 */ } 
    ```

+ 将以上 CSS 保存好，然后用 import 的方法在 JavaScript 文件中引用： 

  + ```js
    /* components/Button.js */
    import styles from './Button.css'; 
    console.log(styles); 
    // => 
    // Object { 
    //  normal: 'button--normal-abc5436', 
    //  disabled: 'button--disabled-def884', 
    // } 
    buttonElem.outerHTML = `<button class=${styles.normal}>Submit</button>` 
    ```

+ 我们看到，最终生成的 HTML 是这样的： 

  + ```react
    <button class="button--normal-abc5436"> Processing... </button> 
    ```

+ 注意到 button--normal-abc5436 是 CSS Modules 按照 localIdentName 自动生成的 class 名称，其中 abc5436 是按照给定算法生成的序列码。

+ 经过这样混淆处理后，class 的名称基本就是唯一的，大大降低了项目中样式覆盖的几率。

+ 同时在生产环境下修改规则，生成更短的 class 名，可以提高 CSS 的压缩率。

+ CSS Modules 对 CSS 中的 class 名都做了处理，使用对象来保存原 class 和混淆后 class 的对应关系。通过这些简单的处理，CSS Modules 实现了以下几点：

  + 所有样式都是局部化的，解决了命名冲突和全局污染问题；
  + class 名的生成规则配置灵活，可以以此来压缩 class 名；
  + 只需引用组件的 JavaScript，就能搞定组件所有的 JavaScript 和 CSS；
  + 依然是 CSS，学习成本几乎为零。

**样式默认局部**

+ 使用了 CSS Modules 后，就相当于给每个 class 名外加了 :local，以此来实现样式的局部化。如果我们想切换到全局模式，可以使用 :global 包裹。示例代码如下： 

  + ```css
    .normal { 
     color: green; 
    } 
    /* 以上与下面等价 */ 
    :local(.normal) { 
     color: green; 
    } 
    /* 定义全局样式 */ 
    :global(.btn) { 
     color: red; 
    } 
    /* 定义多个全局样式 */ 
    :global {  .link { 
       color: green; 
      } 
      .box { 
       color: yellow; 
      } 
    } 
    ```

**使用composes来组合样式**

+ 对于样式复用，CSS Modules 只提供了唯一的方式来处理——composes 组合。示例代码如下： 

  + ```css
    /* components/Button.css */ 
    .base { /* 所有通用的样式 */ } 
    .normal { 
     composes: base; 
     /* normal 其他样式 */ 
    } 
    .disabled { 
     composes: base; 
     /* disabled 其他样式 */ 
    } 
    import styles from './Button.css'; 
    buttonElem.outerHTML = `<button class=${styles.normal}>Submit</button>` 
    ```

+ 生成的 HTML 变为： 

  + ```react
    <button class="button--base-abc53 button--normal-abc53"> Processing... </button> 
    ```

+ 由于在 .normal 中组合了 .base，所以编译后的 normal 会变成两个 class。 

+ 此外，使用 composes 还可以组合外部文件中的样式： 

  + ```css
    /* settings.css */ 
    .primary-color { 
     color: #f40; 
    } 
    /* components/Button.css */ 
    .base { /* 所有通用的样式 */ } 
    .primary { 
     composes: base; 
     composes: $primary-color from './settings.css'; 
     /* primary 其他样式 */ 
    } 
    ```

+ 对于大多数项目，有了  composes  后，已经不再需要预编译处理器了。但如果想用的话，由于 composes 不是标准的 CSS 语法，编译时会报错，此时就只能使用预处理器自己的语法来做样式复用了。 

  + 现在也是这样吗？

**class 命名技巧**

+ CSS Modules 的命名规范是从 BEM 扩展而来的。BEM 把样式名分为 3 个级别，具体如下所示。
  + Block：对应模块名，如 Dialog。
  + Element：对应模块中的节点名 Confirm Button。
  + Modifier：对应节点相关的状态，如 disabled 和 highlight。

+ BEM 最终得到的 class 名为 dialog\__confirm-button--highlight。使用双符号 __ 和 -- 是为了与区块内单词间的分隔符区分开来。虽然看起来有些奇特，但 BEM 被非常多的大型项目采用。 

+ CSS Modules 中 CSS 文件名恰好对应 Block 名，只需要再考虑 Element 和 Modifier 即可。BEM 对应到 CSS Modules 的做法是：

  + ```css
    /* .dialog.css */
    .ConfirmButton--disabled {} 
    ```

+ 我们也可以不遵循完整的命名规范，使用小驼峰的写法把 Block 和 Modifier 放到一起： 

  + ```css
    /* .dialog.css */
    .disabledConfirmButton {} 
    ```

**实现 CSS 与 JavaScript 变量共享**

+ 上面提到的 :export 关键字可以把 CSS 中的变量输出到 JavaScript 中，例如：

  + ```js
    /* config.scss */
    $primary-color: #f40; 
    :export { 
      primaryColor: $primary-color; 
    } 
    /* app.js */
    import style from 'config.scss'; 
    console.log(style.primaryColor);  // 会输出 #F40 
    ```

### CSS Modules 使用技巧

+ CSS Modules 是对现有的 CSS 做减法。为了追求简单可控，作者建议遵循如下原则： 

  + 不使用选择器，只使用 class 名来定义样式；
  + 不层叠多个 class，只使用一个 class 把所有样式定义好；
  + 所有样式通过 composes 组合来实现复用；
  + 不嵌套。

+ 其中前两条原则相当于削弱了样式中最灵活的部分，初学者很难接受。第一条实践起来难度不大，但第二条中模块状态过多时，class 数量将成倍上升。 

+ 上面之所以说“建议”，是因为 CSS Modules 并不强制我们一定要这么做。这听起来有些矛盾。由于多数  CSS  项目存在深厚的历史遗留问题，过多的限制就意味着增加迁移成本和与外部合作的成本。初期使用肯定需要一些折中。

+ 幸运的是，CSS Modules 这点做得很好。下面我们来列举一些常见问题。 

  (1) 如果我对一个元素使用多个 class 呢？ 
  样式照样生效。 
  (2) 如果我在一个 style 文件中使用同名 class 呢？ 
  这些同名 class 编译后虽然可能是随机码，但仍是同名的。 
  (3) 如果我在 style 文件中使用了 id 选择器、伪类和标签选择器等呢？ 
  所有这些选择器将不被转换，原封不动地出现在编译后的 CSS 中。也就是说，CSS Modules 
  只会转换 class 名相关的样式。 

**CSS Modules 结合历史遗留项目实践**

+ 好的技术方案除了功能强大、炫酷，还要能做到现有项目能平滑迁移，CSS Modules 在这一点上表现得非常灵活。 

+ 外部如何覆盖局部样式

  + 当生成混淆的 class 名后，可以解决命名冲突，但因为无法预知最终的 class 名，不能通过一般选择器覆盖。我们现在在项目中的实践是可以给组件关键节点加上 data-role 属性，然后通过**属性选择器**来覆盖样式： 

  + ```js
    // dialog.js
    return ( 
      <div className={styles.root} data-role="dialog-root"> 
     <a className={styles.disabledConfirm} data-role="dialog-confirm-btn">Confirm</a> 
       ... 
      </div> 
    ); 
    // dialog.css
    [data-role="dialog-root"] { 
     // override style 
    } 
    ```

  + 因为 CSS Modules 只会转变类选择器，所以这里的属性选择器不需要添加 :global。 

+ 如何与全局样式共存

  + 前端项目不可避免地会引入 normalize.css 或其他一类全局 CSS 文件，使用 webpack 可以让全局样式和 CSS Modules 的局部样式和谐共存。下面是具体项目中使用的 webpack 部分配置代码：

  + ```js
    module: { 
     loaders: [{ 
     test: /\.jsx?$/, 
       loader: 'babel', 
     }, { 
     test: /\.scss$/, 
     exclude: path.resolve(__dirname, 'src/styles'), 
       loader: 'style!css?modules&localIdentName=[name]__[local]!sass?sourceMap=true', 
     }, { 
     test: /\.scss$/, 
     include: path.resolve(__dirname, 'src/styles'), 
       loader: 'style!css!sass?sourceMap=true', 
      }] 
    } 
    /* src/app.js */
    import './styles/app.scss'; 
    import Component from './view/Component' 
    /* src/views/Component.js */
    import './Component.scss'; 
    ```

  + 目录结构如下：

  + ![1551929599645](F:\OneDrive\JS\纲略合集\assets\1551929599645.png) 

  + 这样所有全局的样式都放到  src/styles/app.scss  中引入就可以了，其他所有目录（包括src/views）中的样式都是局部的。 

+ CSS Modules 很好地解决了 CSS 目前面临的模块化难题。支持与预编译语言搭配使用，能充分利用现有技术，同时也能和全局样式灵活搭配。CSS Modules 的实现也属轻量级，未来有标准解决方案后，可以低成本迁移。

**CSS Modules 结合 React 实践**

+ 在 className 处直接使用 CSS 中的 class 名即可：

+ ```react
  /* dialog.css */
  .root {} 
  .confirm {} 
  .disabledConfirm {} 
  
  /* dialog.js */
  import React, { Component } from 'react'; 
  import classNames from 'classnames'; 
  import styles from './dialog.css'; 
  class Dialog extends Component { 
    render() { 
      const cx = classNames({ 
        confirm: !this.state.disabled, 
        disabledConfirm: this.state.disabled, 
      }); 
      return ( 
        <div className={styles.root}> 
          <a className={styles[cx]}>Confirm</a> 
          ... 
        </div> 
      ); 
    } 
  } 
  ```

+ 注意，一般把组件最外层节点对应的 class 名称为 root。 

+ React  本身处理样式与其他   View  库并没有太多区别，主要是直接操作样式或是操作 classname 间接操作样式的不同罢了。而与 CSS Modules 的深度结合可能是 React 的一大特点。想象一下 CSS 模块化的远景，我们离成熟的 Web 组件化梦想的道路越来越近了。 

+ 如果不想频繁地输入 styles.\**，可以使用 react-css-modules 库。它通过高阶组件的形式来
  避免重复输入 styles.**。我们来重写上述例子： 

+ ```react
  import React, { Component } from 'react'; 
  import classNames from 'classnames'; 
  import CSSModules from 'react-css-modules'; 
  import styles from './dialog.css'; 
  class Dialog extends Component { 
    render() { 
      const cx = classNames({ 
        confirm: !this.state.disabled, 
        disabledConfirm: this.state.disabled, 
      }); 
      return ( 
        <div styleName="root"> 
          <a styleName={cx}>Confirm</a> 
          ... 
        </div> 
      ); 
    } 
  } 
  export default CSSModules(Dialog, styles); 
  ```

+ 此外，对比原始的 CSS Modules，有以下几个优点：

  + 我们不用再关注是否使用驼峰来命名 class 名；
  + 我们不用每一次使用 CSS Modules 的时候都关联 style 对象；
  + 使用 CSS Modules，容易使用 :global 去解决特殊情况，使用 react-css-modules 可写成 <div
    className="global-css" styleName="local-module"></div>，这种形式轻松对应全局和局
    部；
  + 当 styleName 关联了一个 undefined CSS Modules 时，我们会得到一个警告；
  + 我们可以强迫使用单一的 CSS Modules。

## 组件间通信

+ React  是以组合组件的形式组织的，组件因为彼此是相互独立的，从传递信息的内容上看，几乎所有类型的信息都可以实现传递，例如字符串、数组、对象、方法或自定义组件等。所以，在嵌套关系上，就会有 3 种不同的可能性：**父组件向子组件通信**、**子组件向父组件通信**和**没有嵌套关系**的组件之间通信。 

+ 接下来，我们会重点讨论这 3 种不同的通信方式。其中在父组件向子组件通信后，我们还扩展了一种特殊形式——**跨级组件通信**。 

### 父组件向子组件通信 

### 子组件向父组件通信 

+ 在用 React 之前的组件开发模式时，常常需要接收组件运行时的状态，这时我们常用的方法有以下两种
  + 利用回调函数：这是 JavaScript 灵活方便之处，这样就可以拿到运行时状态。
  + 利用自定义事件机制：这种方法更通用，使用也更广泛。设计组件时，考虑加入事件机制往往可以达到简化组件 API 的目的。

### 跨级组件通信 

+ 当需要让子组件跨级访问信息时，我们可以像之前说的方法那样向更高级别的组件层层传递 props，但此时的代码显得不那么优雅，甚至有些冗余。在 React 中，我们还可以使用 **context** 来实现跨级父子组件间的通信： 

+ ```react
  class ListItem extends Component { 
    static contextTypes = { 
      color: PropTypes.string, 
    }; 
  render() { 
    const { value } = this.props; 
    return ( 
      <li style={{background: this.context.color}}> 
        <span>{value}</span> 
      </li> 
    ); 
  } 
  } 
  class List extends Component { 
    static childContextTypes = { 
      color: PropTypes.string, 
    }; 
  getChildContext() { 
    return { 
      color: 'red', 
    }; 
  } 
  render() { 
    const { list } = this.props; 
    return ( 
      <div> 
        <ListTitle title={title} /> 
        <ul> 
          {list.map((entry, index) => ( 
            <ListItem key={`list-${index}`} value={entry.text} /> 
          ))} 
        </ul> 
      </div> 
    ); 
  } 
  } 
  
  ```

+ 可以看到，我们并没有给 List Item 传递 props，而是在父组件中定义了 ChildContext，这样从这一层开始的子组件都可以拿到定义的 context，例如这里的 color。 

+ 事实上，context 一直存在于 React 的源码中，但直到 React 0.14 版本才被正式记录在官方文档里。
+ 不过 React 官方并不建议大量使用 context，因为尽管它可以减少逐层传递，但当组件结构复杂的时候，我们并不知道 context 是从哪里传过来的。Context 就像一个全局变量一样，而全局变量正是导致应用走向混乱的罪魁祸首之一，给组件带来了外部依赖的副作用。
+ 在大部分情况下，我们并不推荐使用 context 。使用 context 比较好的场景是真正意义上的**全局信息且不会
  更改，例如界面主题、用户信息等。** 

+ Redux 作者 Dan Abramov 对于这个不稳定的属性总结了一个非常有意思的 **cheatsheet**： 

+ ```react
  function shouldIUseReactContextFeature() { 
    if (amILirarayAuthor() && doINeedToPassSomethingDownDeeply()) { 
      // 一个自定义的 <option> 组件可能想与它的 <select> 对话 
      // 这是可以的，但要记住，这是一个实验性的 API，如果在一些情况下不能更新成功，
      // 那么可能需要回滚更改它 
      return amIFineWith(API_CHANGES && BUGGY_UPDATES); 
    } 
    if (myUseCase === 'theming' || myUseCase === 'localization') { 
      // 在应用中，context 一般用于不太会改变的全局变量 
      // 如果你坚持使用它，可以提供一个高阶组件 
      // 当我们要更改这个 API 的时候，只需要改一个地方就可以了
      return iPromiseToWriteHOCInsteadOfUsingItDirecly(); 
    } 
    if (libraryAskMeToUseContext()) { 
      // 向它们提供一个高阶组件 
      throw new Error('File an issue with this library.'); 
    } 
    // 祝你好运 
    return yolo(); 
  } 
  ```

+ 因此，总体的原则是如果我们真的需要它，那么建议写成高阶组件来实现。有关高阶组件的内容，在 2.5 节中就会讲到。 

### 没有嵌套关系的组件通信

+ 没有嵌套关系的，那只能通过可以影响全局的一些机制去考虑。刚才讲到的自定义事件机制不失为一种上佳的方法。 

+ 我们在处理事件的过程中需要注意，在 componentDidMount 事件中，如果组件挂载完成，再**订阅事件**；当组件卸载的时候，在 componentWillUnmount 事件中取消事件的订阅。 

+ 我们就以常用的发布/订阅模式来举例，这里借用 Node.js Events 模块的浏览器版实现。 

+ 对于 React 使用的场景来说，EventEmitter 只需要单例就可以了，因此我们需要单独初始化 EventEmitter 实例： 

  + ```react
    import { EventEmitter } from 'events'; 
    export default new EventEmitter(); 
    ```

+ 然后把 EventEmitter 实例输出到各组件中使用：

  + ```react
    import ReactDOM from 'react-dom'; 
    import React, { Component, PropTypes } from 'react'; 
    import emitter from './events'; 
    class ListItem extends Component { 
      static defaultProps = { 
        checked: false, 
      } 
      constructor(props) { 
        super(props); 
      } 
      render() { 
        return ( 
          <li> 
            <input type="checkbox" checked={this.props.checked} onChange={this.props.onChange} /> 
            <span>{this.props.value}</span> 
          </li> 
        ); 
      } 
    } 
    
    class List extends Component { 
      constructor(props) { 
        super(props); 
        this.state = { 
          list: this.props.list.map(entry => ({ 
            text: entry.text, 
            checked: entry.checked || false, 
          })), 
        }; 
      } 
      onItemChange(entry) { 
        const { list } = this.state; 
        this.setState({ 
          list: list.map(prevEntry => ({ 
            text: prevEntry.text, 
            checked: prevEntry.text === entry.text ? 
            !prevEntry.checked : prevEntry.checked, 
          })) 
        }); 
        emitter.emit('ItemChange', entry); 
      } 
      render() { 
        return ( 
          <div> 
            <ul> 
              {this.state.list.map((entry, index) => ( 
                <ListItem 
                  key={`list-${index}`} 
                  value={entry.text} 
                  checked={entry.checked} 
                  onChange={this.onItemChange.bind(this, entry)} 
                  /> 
              ))} 
            </ul> 
          </div> 
        ); 
      } 
    } 
    
    class App extends Component { 
      componentDidMount() { 
        this.itemChange = emitter.on('ItemChange', (data) => { 
          console.log(data); 
        }); 
      } 
      componentWillUnmount() { 
        emitter.removeListener(this.itemChange); 
      } 
      render() { 
        return ( 
          <List list={[{text: 1}, {text: 2}]} /> 
        ); 
      } 
    } 
    
    ```

+ 一般情况下，组件之间的通信尽可能保持简洁。如果说程序中出现多级传递或跨级传递时，那么首先要重新审视一下是否有更合理的方式。Pub/Sub 模式实现的过程非常容易理解，即利用全局对象来保存事件，用广播的方式去处理事件。这种常规的设计方法在软件开发中处处可见，但这种模式带来的问题就是逻辑关系混乱。 

+ 在上述几种通信模式中，跨级通信往往是反模式的典型案例。对于应用开发来说，应该尽力避免仅仅通过例如  Pub/Sub  实现的设计思路，加入强依赖与约定来进一步梳理流程是更好的方法，这将在第 4 章再深入讨论。 

## 组件间抽象

+ 在 React 组件的构建过程中，常常有这样的场景，有一类功能需要被不同的组件公用，此时就涉及抽象的话题。在不同的设计理念下，有许多的抽象方法，而针对 React，我们重点讨论两种：**mixin 和高阶组件**。 

### mixin

**使用 mixin 的缘由**

+ mixin 的特性一直广泛存在于各种面向对象语言中。尤其在脚本语言中，大都有原生的支持，比如 Perl、Ruby、Python，甚至连 Sass 也支持。先来看一个在 Ruby 中使用 mixin 的简单例子：

+ ```ruby
  module D 
    def initialize(name) 
      @name = name 
    end 
    def to_s 
      @name 
    end 
  end 
  module Debug 
    include D 
    def who_am_i? 
      "#{self.class.name} (\##{self.object_id}): #{self.to_s}" 
    end 
  end 
  class Phonograph 
    include Debug 
    # ... 
  end 
  class EightTrack 
    include Debug 
    # ... 
  end 
  ph = Phonograph.new("West End Blues") 
  et = EightTrack.new("Real Pillow") 
  puts ph.who_am_i?  # Phonograph (#-72640448): West End Blues 
  puts et.who_am_i?  # EightTrack (#-72640468): Real Pillow 
  
  ```

+  在 Ruby 中，include 关键词即是 mixin，是将一个模块混入到一个另一个模块中，或是一个类中。为什么编程语言要引入这样一种特性呢？事实上，包括 C++ 等一些年龄较大的 OOP 语言，它们都有一个强大但危险的多重继承特性。现代语言为了权衡利弊，大都舍弃了多重继承，只采用单继承，但单继承在实现抽象时有诸多不便之处。为了弥补缺失，Java 引入了接口（interface），其他一些语言则引入了像 mixin 的技巧，方法虽然不同，但都是为创造一种类似多重继承的效果，事实上说它是**组合**更为贴切。 

+ 在 ECMAScript 历史中，并没有严格的类实现，早期 YUI、MooTools 这些类库中都有自己封装类的实现，并引入了 mixin 混用模块的方法。直到今天，ES6 引入 class 语法，各种类库也在向着标准化靠拢。 

**封装 mixin 方法**

+ 看到这里，我们已经知道了广义的 mixin 方法的作用，现在试着自己封装一个 mixin 方法来感受一下： 

  ```js
  const mixin = function(obj, mixins) { 
    const newObj = obj; 
    newObj.prototype = Object.create(obj.prototype); 
    for (let prop in mixins) { 
      if (mixins.hasOwnProperty(prop)) { 
        newObj.prototype[prop] = mixins[prop]; 
      } 
    } 
    return newObj; 
  } 
  const BigMixin = { 
    fly: () => { 
      console.log('I can fly'); 
    } 
  }; 
  const Big = function() { 
    console.log('new big'); 
  }; 
  const FlyBig = mixin(Big, BigMixin); 
  const flyBig = new FlyBig(); // => 'new big' 
  flyBig.fly(); // => 'I can fly' 
  ```

+ 对于广义的 mixin 方法，就是用赋值的方式将 mixin 对象里的方法都挂载到原对象上，来实现对对象的混入。 

+ 看到上述实现，是否会联想到 underscore 库中的 extend 或 lodash 库中的 assign 方法，或者说 ES6中的 **Object.assign() 方法**？它的作用是什么呢？MDN 上的解释是把任意多个源对象所拥有的自身可枚举属性复制给目标对象，然后返回目标对象。 

+ 因为 JavaScript 这门语言比较特别，在没有提到 ES6 classes 之前，并没有真正的类，仅是用方法去模拟对象，其中 new 方法用于创建实例。正因为对类的支持或限制这样弱，它才会那么灵活，上述 mixin 的过程就像复制对象一样。 
+ 那问题是组件中的 mixin 也是这样的吗？ 

**在 React 中使用 mixin**

+ React 在使用 **createClass 构建组件**时提供了 mixin 属性，比如官方封装的 PureRenderMixin： 

  ```react
  import React from 'react'; 
  import PureRenderMixin from 'react-addons-pure-render-mixin'; 
  React.createClass({ 
    mixins: [PureRenderMixin], 
    render() { 
      return <div>foo</div>; 
    } 
  }); 
  ```

+ 在 createClass 对象参数中传入数组 mixins，里面封装了我们所需要的模块。mixins 数组也可以增加多个 mixin，其每一个 mixin 方法之间的有重合，对于普通方法和生命周期方法是有所区分的。 

+ 在不同的 mixin 里实现两个名字一样的普通方法，按理说，后面的方法应该会覆盖前面的方法。那么，在 React 中是否一样会覆盖呢？事实上，它并不会覆盖，而是在控制台里报了一个在 ReactClassInterface 里的错误，指出你尝试在组件中多次定义一个方法，这会造成冲突。因此，**在 React 中是不允许出现重名普通方法的 mixin。**

+ 如果是 React 生命周期定义的方法，则会将各个模块的生命周期方法叠加在一起顺序执行。 
+ 我们看到，使用 createClass 实现的 mixin 为组件做了两件事。 
  + **工具方法**。这是 mixin 的基本功能，如果你想共享一些**工具类方法**，就可以定义它们，**直接在各个组件中使用。**
  + **生命周期继承**，props 与 state 合并。这是 mixin **特别重要的功能**，它能够合并生命周期方法。如果有很多 mixin 来定义 componentDidMount 这个周期，那么 React 会非常智能地将它们都**合并起来执行**。同样，mixin 也可以作用在 getInitialState 的结果上，作 state 的合并，而 props 也是这样合并的。

**ES6 Classes 与 decorator**

+ 然而，使用我们推荐的 ES6 classes 形式构建组件时，它并不支持 mixin。React 文档中也未能给出解决方法，但如此重要的特性没有解决方案，也是一件令人十分困扰的事情。为了可以使用这个强大的功能，我们还得想想是否有其他方法，可以用来达到重用模块的目的。先回归到 ES6 classes，我们来想想如何封装 mixin。 
+ 要在 class 的基础上封装 mixin，就要说到 class 的本质。ES6 并没有改变 JavaScript 面向对象方法基于原型的本质，不过在此之上提供了一些语法糖，class 就是其中之一。 

+ 对于实现 mixin 方法来说，这就没什么不一样了。但既然讲到了语法糖，就来讲讲另一个语法糖 decorator，正巧可以用来实现 class 上的 mixin。 
+ decorator 是在 ES7 中定义的新特性，与 Java 中的 pre-defined annotation（预定义注解） 相似。但与 Java 的 annotation 不同的是，decorator 是运用在**运行时**的方法。在 Redux 或其他一些应用层框架中，越来越多地使用 decorator 以实现对组件的“修饰”。现在，我们使用 decorator 来实现 mixin。 

+ core-decorators 库为开发者提供了一些实用的 decorator，其中实现了我们正想要的 @mixin。下面解读一下其核心实现： 

  ```js
  import { getOwnPropertyDescriptors } from './private/utils'; 
  const { defineProperty } = Object; 
  function handleClass(target, mixins) { 
    if (!mixins.length) { 
      throw new SyntaxError(`@mixin() class ${target.name} requires at least one mixin as an argument`); 
    } 
    for (let i = 0, l = mixins.length; i < l; i++) { 
      // 获取 mixins 的 attributes 对象 
      const descs = getOwnPropertyDescriptors(mixins[i]); 
      // 批量定义 mixins 的 attributes 对象 
      for (const key in descs) { 
        if (!(key in target.prototype)) { 
          defineProperty(target.prototype, key, descs[key]); 
        } 
      } 
    } 
  } 
  export default function mixin(...mixins) { 
    if (typeof mixins[0] === 'function') { 
      return handleClass(mixins[0], []); 
    } else { 
      return target => { 
        return handleClass(target, mixins); 
      }; 
    } 
  } 
  ```

+ 可以看到，源代码十分简单，它**将每一个 mixin 对象的方法都叠加到 target 对象的原型上**以达到 mixin 的目的。这样，就可以用 @mixin 来做多个重用模块的叠加了。比如： 

  ```js
  import React, { Component } from 'React'; 
  import { mixin } from 'core-decorators'; 
  const PureRender = { 
    shouldComponentUpdate() {} 
  }; 
  const Theme = { 
    setTheme() {} 
  }; 
  @mixin(PureRender, Theme) 
  class MyComponent extends Component { 
    render() {} 
  } 
  
  ```

+ 细心的你应该已经发现了这个 mixin 与 createClass 中的 mixin 的区别。上述实现中，mixin 的逻辑和最早实现的简单逻辑很相似，之前直接给对象的  prototype  属性赋值，但这里用了 getOwnPropertyDescriptor 和 defineProperty 这两个方法，有什么区别呢？ 

+ 事实上，这样实现的好处在于 defineProperty 这个方法，也就是**定义与赋值**的区别，定义是对已有的定义，赋值则是覆盖已有的定义。所以说**前者并不会覆盖已有方法**，但后者会。
+ defineProperty 并不会覆盖已有方法
+ 本质上与官方的 mixin 方法（createClass）都很不一样，除了定义方法级别不能覆盖之外，还得**加上**对生命周期方法的继承，以及对 state 的合并。

+ 再回到  decorator 身上，上述只是作用在**类上的方法**，还有作用在方法上的，它可以控制方法的自有属性，也可以作 decorator 的工厂方法。在其他语言里，decorator 用途广泛，具体扩展不在本书讨论的范围。 
+ 对于 React，我们自然可以用上述方法来实现 mixin。但不幸的是，社区从 0.14 版本开始渐渐开始剥离 mixin。那么，到底是什么原因导致 mixin 成为反模式了呢？ 

**mixin 的问题**

+ 我们认可 mixin 给组件开发带来抽象的好处，但随着大量使用 mixin，它的问题也渐渐暴露出来了。Dan Abramov 是最早提出这个问题的人，他总结了 mixin 最大的一些问题①。 
+ 破坏了原有组件的封装
  + 我们知道 mixin 方法会混入方法，给原有组件带来新的特性，比如 mixin 中有一个 renderList方法，给我们带来了渲染 List 的能力，但它也可能带来了新的 state 和 props，这意味着组件有一些“不可见”的状态需要我们去维护，但我们在使用的时候并不清楚。此外，renderList 中的方法会有调用组件中的方法，但很可能被其他 mixin 截获，带来很多不可知。 
  + 另外，mixin 也有可能去依赖其他的 mixin，这样会建立一个 mixin 的依赖链，当我们改动其中一个 mixin 的状态时，很可能会直接影响其他的 mixin。解决方法是可以约定好输入和输出。但不幸的是，mixin 是平面结构，所有方法都在同一个环境中，我们没法做到很好的约定。 

+ 命名冲突
  + 刚才也提到了，mixin 是平面结构，那么不同 mixin 中的命名在不可知的情况，重用的情况是不可控的。尤其是像 handleChange 这样常见的名字，我们不能在两个 mixin 中同时使用，也不
    能在自己的组件中使用这个名字的方法。 
  + 尽管我们可以通过更改名字来解决，但遇到第三方引用，或已经引用了几个 mixin 的情况下，总是要花一定的成本去解决冲突。 

+ 增加复杂性
  + 在过去写 mixin 的时候，是不是常遇到这样的情形：我们设计一个组件，引入名为 PopupMixin 的 mixin，这样就给组件引进了 PopupMixin 生命周期方法，还有 hidePopup()、startPopup() 等方法。当我们再引入HoverMixin时，将有更多的方法被引进，比如 handleMouseEnter()、handle- MouseLeave()、isHovering()方法。当然，我们可以进一步抽象出  TooltipMixin，将两个整合在一起，但我们发现它们都有 componentDidUpdate 方法。 
  + 几个月后，再去看组件的实现时，会发现代码已经没法维护，它的逻辑已经复杂到难以理解。写 React 组件时，我们首先考虑的往往是单一的功能、简洁的设计和逻辑。当加入功能的时候，可以继续控制组件的输入和输出。如果说因为复杂性，我们不断加入新的状态，那么组件肯定会因此变得非常难以维护。 
+ 针对这些困扰，React 社区提出了新的方式来**取代 mixin，那就是高阶组件**。 

### 高阶组件 

+ higher-order 这个单词相信各位开发者都很熟悉，higher-order function（高阶函数）在函数式编程中是一个基本的概念，它描述的是这样一种函数：这种函数**接受函数作为输入**，或是**输出一个函数**。比如，常用的工具方法 map、reduce 和 sort 等都是**高阶函数**。 

+ 高阶组件（higher-order component），类似于高阶函数，它**接受 React 组件作为输入，输出一个新的 React 组件**。我们用 Haskell 的函数签名来表达，那就是：

  + ```haskell
    hocFactory:: W: React.Component => E: React.Component 
    ```

+ 用通俗的语言解释就是，当  React  组件被包裹时（wrapped），高阶组件会返回一个增强（enhanced）的 React 组件。可以想象，高阶组件让我们的代码更具有复用性、逻辑性与抽象特性。

+ 它可以**对 render 方法作劫持，也可以控制 props 与 state。** 

+ 实现高阶组件的方法有如下两种。
  + 属性代理（props proxy）。高阶组件通过被包裹的 React 组件来操作 props。
  + 反向继承（inheritance inversion）。高阶组件继承于被包裹的 React 组件。

#### **1. 属性代理**

+ 属性代理是常见高阶组件的实现方法，我们通过一个例子来说明：

  ```react
  import React, { Component } from 'React'; 
  const MyContainer = (WrappedComponent) => 
  class extends Component { 
    render() { 
      return <WrappedComponent {...this.props} />; 
    } 
  } 
  
  ```

+ 从这里看到最重要的部分是 render 方法中返回了传入 WrappedComponent 的 React 组件。这样，我们就可以**通过高阶组件来传递 props，这种方法即为属性代理**。

  + 有点类似与包装NavLink的那个，也有点类似于Redux container 

+ 自然，我们想要使用 MyContainer 这个高阶组件就变得非常容易： 

  ```react
  import React, { Component } from 'React'; 
  class MyComponent extends Component { 
    // ... 
  } 
  export default MyContainer(MyComponent); 
  ```

+ 这样组件就可以一层层地作为参数被调用，原始组件就具备了高阶组件对它的修饰。就这么简单，保持单个组件封装性的同时还保留了易用性。当然，我们也可以用 decorator 来转换： 

  ```react
  import React, { Component } from 'React'; 
  @MyContainer 
  class MyComponent extends Component { 
    render() {} 
  } 
  export default MyComponent; 
  ```

+ 简单地替换成作用在类上的 decorator，即接收需要装饰的类为参数，返回一个新的内部类。这与高阶组件的定义完全一致。因此，可以认为作用在类上的  decorator 语法糖简化了高阶组件的调用。 

+ 当使用属性代理构建高阶组件时，调用顺序不同于 mixin。上述执行生命周期的过程类似于**堆栈调用**： 

  ```js
  didmount→HOC didmount→(HOCs didmount)→(HOCs will unmount)→HOC will unmount→unmount 
  ```

+ 从功能上，高阶组件一样可以做到像 mixin 对组件的控制，包括**控制 props、通过 refs 使用引用、抽象 state 和使用其他元素包裹 WrappedComponent。** 

**控制 props**

+ 我们可以读取、增加、编辑或是移除从 WrappedComponent 传进来的 props，但需要小心删除与编辑重要的 props。我们应该尽可能对高阶组件的 props 作新的命名以防止混淆。 

+ 例如，我们需要增加一个新的 prop： 

  ```react
  import React, { Component } from 'React'; 
  const MyContainer = (WrappedComponent) => 
    class extends Component { 
      render() { 
        const newProps = { 
          text: newText, 
        }; 
        return <WrappedComponent {...this.props} {...newProps} />; 
      } 
    } 
  
  ```

+ 当调用**高阶组件**时，可以用 text 这个新的 props 了。对于**原组件来**说，只要套用这个高阶组件，我们的新组件中就会多一个 text 的 prop。 

**通过 refs 使用引用**

+ 在高阶组件中，我们可以接受 refs 使用 WrappedComponent 的引用。例如：

  ```react
  import React, { Component } from 'React'; 
  const MyContainer = (WrappedComponent) => 
    class extends Component { 
      proc(wrappedComponentInstance) { 
        wrappedComponentInstance.method(); 
      } 
      render() { 
        const props = Object.assign({}, this.props, { 
          ref: this.proc.bind(this), 
        }); 
        return <WrappedComponent {...props} />; 
      } 
    } 
  
  ```

+ 当  WrappedComponent  被渲染时，refs  回调函数就会被执行，这样就会拿到一份Wrapped- Component 实例的引用。这就可以方便地用于读取或增加实例的 props，并调用实例的方法。 

**抽象state**

+ 我们可以通过 WrappedComponent 提供的 props 和回调函数抽象 state，这个功能将在 4.1 节中解释。高阶组件可以**将原组件抽象为展示型组件，分离内部状态**。 

+ 下面通过抽象一个 input 组件来举例： 

  ```react
  import React, { Component } from 'React'; 
  const MyContainer = (WrappedComponent) => 
    class extends Component { 
      constructor(props) { 
        super(props); 
        this.state = { 
          name: '', 
        }; 
        this.onNameChange = this.onNameChange.bind(this); 
      } 
      onNameChange(event) { 
        this.setState({ 
          name: event.target.value, 
        }) 
      } 
      render() { 
        const newProps = { 
          name: { 
            value: this.state.name, 
            onChange: this.onNameChange, 
          }, 
        } 
        return <WrappedComponent {...this.props} {...newProps} />; 
      } 
    } 
  
  ```

+ 在这个例子中，我们把 input 组件中对 name prop 的 onChange 方法**提取到高阶组件**中，这样就有效地抽象了同样的 state 操作。可以这么来使用它： 

  ```react
  import React, { Component } from 'React'; 
  @MyContainer 
  class MyComponent extends Component {  
    render() { 
      return <input name="name" {...this.props.name} />; 
    } 
  } 
  ```

+ 通过这样的封装，我们就得到了一个被控制的 input 组件。 

**使用其他元素包裹 WrappedComponent**

+ 此外，我们还可以使用其他元素来包裹 WrappedComponent，这既可以是为了加**样式**，也可以是为了**布局**。比如，我们增加一层来定义样式： 

  ```react
  import React, { Component } from 'React'; 
  const MyContainer = (WrappedComponent) => 
    class extends Component { 
      render() { 
        return ( 
          <div style={{display: 'block'}}> 
            <WrappedComponent {...this.props} /> 
          </div> 
        ) 
      } 
    } 
  
  ```

**高阶组件与 mixin 的不同之处**

+ ![1551957674894](F:\OneDrive\JS\纲略合集\assets\1551957674894.png) 
+ 图 2-1 其实已经很清晰地表达了 mixin 与高阶组件的不同之处。简单来说，高阶组件符合函数式编程思想。对于原组件来说，并不会感知到高阶组件的存在，只需要把功能套在它之上就可以了，从而避免了使用 mixin 时产生的副作用。 

#### 2. 反向继承

+ 另一种构建高阶组件的方法称为反向继承，从字面意思上看，它一定与继承特性相关。我们同样来看一个简单的实现： 

  ```react
  const MyContainer = (WrappedComponent) => 
    class extends WrappedComponent { 
      render() { 
        return super.render(); 
      } 
    } 
  
  ```

+ 正如所见，高阶组件**返回的组件继承于 WrappedComponent**。因为被动地继承了 Wrapped Com- ponent，**所有的调用都会反向**，这也是这种方法的由来。 

+ 这种方法与属性代理不太一样。它通过继承 WrappedComponent 来实现，方法可以通过 super 来顺序调用。因为依赖于继承的机制，HOC 的调用顺序和队列是一样的：

  ```react
  didmount→HOC didmount→(HOCs didmount)→will unmount→HOC will unmount→(HOCs will unmount) 
  ```

+ 在反向继承方法中，高阶组件可以使用  Wrapped Component  引用，这意味着它可以使用Wrapped Component 的 state、props 、生命周期和 render 方法。**但它不能保证完整的子组件树被解析**

**渲染劫持**

* 渲染劫持指的就是高阶组件可以控制 WrappedComponent 的渲染过程，并渲染各种各样的结果。我们可以在这个过程中在任何 React 元素输出的结果中读取、增加、修改、删除 props，或读取或修改 React 元素树，或条件显示元素树，又或是用样式控制包裹元素树。
* 正如之前说到的，反向继承不能保证完整的子组件树被解析，这意味着将限制渲染劫持功能。渲染劫持的经验法则是我们可以操控 WrappedComponent 的元素树，并输出正确的结果。但如果元素树中包括了函数类型的 React 组件，就不能操作组件的子组件。 

+ 我们先来看条件渲染的示例： 

  ```react
  const MyContainer = (WrappedComponent) => 
    class extends WrappedComponent { 
      render() { 
        if (this.props.loggedIn) { 
          return super.render(); 
        } else { 
          return null; 
        } 
      } 
    } 
  
  ```

+ 第二个示例是我们可以对 render 的输出结果进行修改：

  ```react
  const MyContainer = (WrappedComponent) =>; 
    class extends WrappedComponent { 
      render() { 
        const elementsTree = super.render(); 
        let newProps = {}; 
        if (elementsTree && elementsTree.type === 'input') { 
          newProps = {value: 'may the force be with you'}; 
        } 
        const props = Object.assign({}, elementsTree.props, newProps); 
        const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children); 
        return newElementsTree; 
      } 
    } 
  
  ```

+ 在这个例子中，WrappedComponent 的渲染结果中，顶层的 input 组件的 value 被改写为 maythe force be with you。因此，我们可以做各种各样的事，甚至可以反转元素树，或是改变元素树中的 props。这也是 Radium 库构造的方法。 

**控制 state**

+ 高阶组件可以读取、修改或删除 WrappedComponent 实例中的 state，如果需要的话，也可以增加 state。但这样做，可能会让 WrappedComponent 组件内部状态变得一团糟。大部分的高阶组件都应该限制读取或增加 state，尤其是后者，可以通过重新命名 state，以防止混淆。 

+ 我们来看一个例子：

  ```react
  const MyContainer = (WrappedComponent) => 
    class extends WrappedComponent { 
      render() { 
        return ( 
          <div> 
            <h2>HOC Debugger Component</h2> 
            <p>Props</p> <pre>{JSON.stringify(this.props, null, 2)}</pre> 
            <p>State</p><pre>{JSON.stringify(this.state, null, 2)}</pre> 
            {super.render()} 
          </div> 
        ); 
      } 
    } 
  
  ```

+ 在这个例子中，显示了 Wrapped Component 的 props 和 state，以方便我们在程序中去调试它们。 

#### 3. 组件命名

+ 当包裹一个高阶组件时，我们失去了原始 WrappedComponent 的 displayName，而组件名字是方便我们开发与调试的重要属性。 

+ 那可以怎么做呢？这里可以参考 react-redux 库中的实现：

  ```js
    HOC.displayName = `HOC(${getDisplayName(WrappedComponent)})`; 
    // 或者 
    class HOC extends ... { 
     static displayName = `HOC(${getDisplayName(WrappedComponent)}); 
      ... 
    } 
    // getDisplayName 方法可以这样来实现： 
    function getDisplayName(WrappedComponent) { 
     return WrappedComponent.displayName || 
      WrappedComponent.name || 
      'Component'; 
    } 
  ```

+ 或可以使用 recompose 库，它已经帮我们实现了相应的方法。 

#### 4. 组件参数

+ 有时，我们调用高阶组件时需要传入一些参数，这可以用非常简单的方式来实现： 

  ```react
  import React, { Component } from 'React'; 
  function HOCFactoryFactory(...params) { 
    // 可以做一些改变 params 的事 
    return function HOCFactory(WrappedComponent) { 
      return class HOC extends Component { 
        render() { 
          return <WrappedComponent {...this.props} />; 
        } 
      } 
    } 
  } 
  ```

+ 当你使用的时候，可以这么写： 

  ```react
    HOCFactoryFactory(params)(WrappedComponent) 
    // 或者 
    @HOCFatoryFactory(params) 
    class WrappedComponent extends React.Component{} 
  ```

+ 这也是利用了函数式编程的特性。可见，在 React 抽象的过程中，处处可见它的影子。 

### 组合式组件开发实践 

+ 之前我们多次提到，使用 React 开发组件时利用 props 传递参数。也就是说，用参数来配置组件是我们最常用的封装方式。在一般场景中，仅修改组件用于配置的 props，就可以满足需求。但随着场景发生变化，组件的形态也发生变化时，我们就必须不断增加 props 去应对变化，此时便会导致 props 的泛滥，而在扩展过程中又必须保证组件向下兼容，只增不减，使组件的可维护性降低。 

+ 因此，我们就可以利用上述高阶组件的思想，提出组件组合式开发模式，有效地解决了配置式所存在的一些问题。 

#### 组件再分离

+ 当然，我们期望组件是没有冗余的，组件与组件间视图重叠的部分应当被抽离出来，形成颗粒度更细小的原子组件，使组件组合充满更多的可能。先来看一下比较典型的 3 个公共组件
+ ![1551959925557](F:\OneDrive\JS\纲略合集\assets\1551959925557.png) 
+ 这 3 个组件无论从 UI 还是逻辑上均存在一定的共性。在**配置方式**中，我们会将这 3 个组件通过一个组件的配置变换来实现，但这么做无疑会提高单个组件内部逻辑的复杂性。 

+ 我们来做一次分离，它们可由 Select Input、SearchInput 与 List 三个颗粒度更细的组件来组合。对于颗粒度最小的组件而言，我们希望它是**纯粹的、木偶式的组件。** 

+ 例如，对于 SelectInput 组件，其状态完全依赖传入的 props，包括 selectedItem（显示用户所选项）、isActive（当前下拉状态）、onClickHeader（反馈下拉状态）以及  placeholder（下拉框提示）。我们来看一下它的简要实现： 

  ```react
  class SelectInput extends Component { 
    static displayName = 'SelectInput'; 
    render() { 
      const { selectedItem, isActive, onClickHeader, placeholder } = this.props; 
      const { text } = selectedItem; 
      return ( 
        <div> 
          <div onClick={onClickHeader}> 
            <Input 
              type="text" 
              disabled 
              value={text} 
              placeholder={placeholder} 
              /> 
            <Icon className={isActive} name="angle-down" /> 
          </div> 
        </div> 
      ); 
    } 
  } 
  
  ```

+ 组件再次分离后，我们就可以根据在现实中的组件形态对其进行任意组合，形成统一层，摆脱在原有组件上扩展的模式，有效提高组件的灵活性。 

#### 逻辑再抽象

+ 组件层面的抽象不仅仅只停留在界面上，组件中的**相同交互逻辑和业务逻辑**也应该进行抽象。在组件中，同样贯穿着这种函数式思想，只是实现方式略有不同。现在基于高阶组件来完成组件逻辑上的抽象：

  ```react
  // 完成 SearchInput 与 List 的交互 
  const searchDecorator = WrappedComponent => { 
    class SearchDecorator extends Component { 
      constructor(props) { 
        super(props); 
        this.handleSearch = this.handleSearch.bind(this); 
      } 
      handleSearch(keyword) { 
        this.setState({ 
          data: this.props.data, 
          keyword, 
        }); 
        this.props.onSearch(keyword); 
      } 
      render() { 
        const { data, keyword } = this.state; 
        return ( 
          <WrappedComponent 
            {...this.props} 
            data={data} 
            keyword={keyword} 
            onSearch={this.handleSearch} 
            /> 
        ); 
      } 
    } 
    return SearchDecorator; 
  } 
  
  ```

  ```react
  
  // 完成 List 数据请求 
  const asyncSelectDecorator = WrappedComponent => { 
    class AsyncSelectDecorator extends Component { 
      componentDidMount() { 
        const { url, params } = this.props; 
        fetch(url, { params }).then(data => { 
          this.setState({ 
            data, 
          }); 
        }); 
      } 
      render() { 
        return ( 
          <WrappedComponent 
            {...this.props} 
            data={this.state.data} 
            /> 
        ); 
      } 
    } 
    return AsyncSelectDecorator; 
  } 
  ```

+ 最终，我们既可以用 decorator 的方式叠加套用，也可以利用 compose 方法将高阶组件层层包裹，将界面与逻辑完美地结合在一起： 

  ```react
  const FinalSelector = compose(asyncSelectDecorator, searchDecorator, selectedItemDecorator)(Selector); 
  class SearchSelect extends Component { 
    render() { 
      return ( 
        <FinalSelector {...this.props}> 
          <SelectInput /> 
          <SearchInput /> 
          <List /> 
        </FinalSelector> 
      ); 
    } 
  } 
  
  ```

+ 在配置式组件内部，组件与组件间以及组件与业务间是紧密关联的，而我们需要完成的仅仅是配置工作。如图 2-3 所示，组合式的方式意图打破这种关联，寻求单元化，通过颗粒度更细的基础组件与抽象组件共有交互与业务逻辑的高阶组件，使组件更灵活，更易扩展，也使我们能够完成对于基础组件的自由支配。 

+ ![1551960424092](F:\OneDrive\JS\纲略合集\assets\1551960424092.png) 

+ 从侵入组件到与组件解耦，React 一直推崇的声明式编程都优于命令式编程，正如 mixin 到高阶组件的发展。对于“重用”，从语言层面上来讲，都是为了可以更好地实现抽象，而实现的灵活性与写法之间也存在着一个微妙的平衡。 

## 组件性能优化 

+ 从过往的经验与实践中，我们都知道影响网页性能最大的因素是**浏览器的重绘（reflow）和重排版（repaint）。**
+ React 背后的 Virtual DOM 就是尽可能地减少浏览器的重绘与重排版。 对于性能优化这个主题，我们往往会基于“不信任”的前提，即我们需要提高 React Virtual DOM  的效率。
+ 从  React  的渲染过程来看，如何防止不避要的渲染可能是最需要去解决的问题。
+ 然而，针对这个问题，React 官方提供了一个便捷的方法来解决，那就是 **PureRender**。 

### 纯函数

+ 要理解 PureRender 中的 Pure，还要从函数式编程的基本概念“纯函数”讲起。

+ 纯函数由三大原则构成： 

  + 给定相同的输入，它总是返回相同的输出；

  + 过程没有副作用（side effect）①；

    + > side effect (computer science)，详见 https://en.wikipedia.org/wiki/Side_effect_(computer_science)。

  + 没有额外的状态依赖。

+ 我们都喜欢这样的方法。记得在计算机科学中有这样一条设计原则  KISS（Keep  It  Simple, Stupid），而纯函数正是在简洁性与傻瓜化方面做到了极致。 

+ 纯函数也是函数式编程的基础，它完全独立于外部状态，这样就避免了因为共享外部状态而导致的  bug。这种独立，让我们可以利用  CPU 在分布式集群上作并行计算，这对于多种科学计算和资源密集型计算任务是非常核心的一点，让计算机高效地处理这类任务变得可能。
+ 此外，纯函数非常方便进行方法级别的测试以及重构，可以让程序具有良好的扩展性及适应性。 

**纯函数的第一个特点**

+ 假如我们定义一个“定义加法”的方法  f，然后改变它的输入为  f(2, 5)，那么不管方法的上下文，不论什么时间调用或多少次的调用，它总是返回 7。用数学语言表达即为 f (x, y) = z，当给定变量 x 和 y，作用在 f 上，结果始终为 z。 

+ 但并不是所有方法都适应这个条件，有些方法的结果并不完全依赖于你所传入的参数。比如：Math.random();new Date()

+ 看到 time 一定恍然大悟了吧。获取时间的方法也是同样的，不论我们限定更新时间的区间在秒、分、时，甚至是年，它总是会在这个范围之外改变值而导致不能做到输入和输出一致。 

+ 还有我们常用的 slice 和 splice 方法，它们有相似的功能，都可以用来作数据截取。那么，它们的执行结果是一致的么？

+ ```js
  const stars = ['Earth', 'Mars', 'Mercury', 'Venus']; 
  stars.slice(0, 2); // => ['Earth', 'Mars'] 
  stars.slice(0, 2); // => ['Earth', 'Mars'] 
  stars.slice(0, 2); // => ['Earth', 'Mars'] 
  stars.splice(0, 2) // => ['Earth', 'Mars'] 
  stars.splice(0, 2) // => ['Mercury', 'Venus'] 
  stars.splice(0, 2) // => [] 
  
  ```

+ 我们清晰地看到 slice 方法在参数一定的情况下输出是完全一样的，而 splice 方法的执行结果会改变原数组。对于程序来说，splice 的隐藏行为是危险的，因为这是常会令人疏忽的隐式改变。在 Ruby 语言的设计中，会用 ! 号来区分是否改变原始值，这是一个很好的提醒。 

+ 当然，还有很多情况是在**不同的输入下会有相同的输出**，但从概念上说，这个方法也还是纯函数。例如

  ```js
  function compare(val, comparedVal) { return val <= comparedVal; } 
  compare(1, 3); // => true 
  compare(1, 5); // => true 
  compare(1, 7); // => true 
  compare(7, 1); // => false 
  compare(9, 1); // => false 
  compare(11, 1); // => false 
  ```

**纯函数的第二个特点**

+ 第二个条件“过程没有副作用”，其实很好理解，就是说在纯函数中我们不能改变外部状态。而在 JavaScript 中改变外部状态的情况比比皆是，就比如方法的参数是对象或数组，那么它本身就有可能被方法执行的过程改变。例如：

  ```js
  const addToCart = (cart, item, quantity) => { 
    cart.items.push({ 
     item, 
     quantity, 
    }); 
   return cart; 
  }; 
  ```

+ 当我们调用方法的时候：

  ```js
  const originalCart = { 
    items: [], 
  }; 
  const cart = addToCart( 
    originalCart, 
    { 
      name: "Digital SLR Camera", 
      price: '1495', 
    }, 
    1 
  ); 
  
  ```

+ 这个例子很简单。这是一个加入到“购物车”的方法，但在执行 addToCart 方法的时候，改变了 originalCart 对象。尽管我们返回了新对象，但因为在 Java Script 中对象是引用，因此原来的对象也改变了。这就产生了副作用。 因此，我们提出了 **Immutable** 的概念，让参数中的引用重新复制。这里我们借用了 lodash 的 cloneDeep 方法来作深拷贝： 

  ```js
  import '_' from 'lodash'; 
  const addToCart = (cart, item, quantity) => { 
    const newCart = _.cloneDeep(cart); 
    newCart.items.push({ 
      item, 
      quantity, 
    }); 
    return newCart; 
  }; 
  ```

+ 这样，我们就不会担心方法影响了外部参数。这也告诉了我们 Immutable 是多么重要。在本节后续部分，我们会重点讲述这一概念及其运用。 

**第三个条件**

+ 第三个条件“没有额外的状态依赖”，就是指方法内的状态都只在**方法的生命周期内存活**，这意味着我们不能在方法内使用共享变量，因为这会给方法带来不可知因素。
+ React  在设计时带有函数式编程的基因，因为   React  组件本身就是纯函数。 React  的 createElement 方法保证了组件是纯净的，即传入指定 props 得到一定的 Virtual DOM，整个过程都是可预测的。 

+ 我们可以通过拆分组件为子组件，进而对组件做更细粒度的控制。这也是函数式编程的魅力之一，保持纯净状态，可以让方法或组件更加专注（focused），体积更小（small），更独立（independent），更具有复用性（reusability）和可测试性（testability）。 

### Pure Render 

+ Pure Render 是 React 组件开发中一个重要的概念。上一节我们详解了纯函数，PureRender 中的 Pure 指的就是组件满足纯函数的条件，即组件的渲染是被**相同的 props 和 state 渲染**进而得到相同的结果。这个概念与上述给定相同的输入，它总是返回相同的输出一致。 

**Pure Render 本质**

+ 怎么实现 Pure Render 的过程呢？官方在早期就为开发者提供了名为 react-addons-pure-render- mixin  的插件。其原理为重新实现了  should Component Update  生命周期方法，让当前传入的  props 和 state 与之前的作浅比较，如果返回 false，那么组件就不会执行 render 方法。 

+ 这里讲到了用 shouldComponentUpdate 来作性能优化的方法。在理想情况下，不考虑 props 和 state 的类型，那么要作到充分比较，只能通过深比较，但是它实在是太昂贵了：

  ```react
  shouldComponentUpdate(nextProps, nextState) { 
    // 太昂贵了 
   return isDeepEqual(this.props, nextProps) && 
   isDeepEqual(this.state, nextState); 
  } 
  ```

+ 然而，PureRender 对 object 只作了**引用比较**，并没有作值比较。对于实现来说，这是一个取舍问题。

  PureRender 源代码中只对新旧 props 作了**浅比较**。以下是 shallowEqual 的示例代码： 

+ ```react
  function shallowEqual(obj, newObj) { 
    if (obj === newObj) { 
      return true; 
    } 
    const objKeys = Object.keys(obj); 
    const newObjKeys = Object.keys(newObj); 
    if (objKeys.length !== newObjKeys.length) { 
      return false; 
    } 
    // 关键代码，只需关注 props 中每一个是否相等，无需深入判断
    return objKeys.every(key => { 
      return newObj[key] === obj[key]; 
    }); 
  } 
  ```

**运用 PureRender**

+ 利用 createClass 构建组件时，可以使用官方的插件，其名为 react-addons-pure-render-mixin。此外，用 ES6 classes 语法一样可以使用这个插件，比如：

+ ```react
  import React, { Component } from 'react'; 
  import PureRenderMixin from 'react-addons-pure-render-mixin'; 
  class App extends Component { 
    constructor(props) { 
      super(props); 
      this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); 
    } 
    render() { 
      return <div className={this.props.className}>foo</div>; 
    } 
  } 
  ```

+  当然，我们也可以用前面介绍的 decorator 来实现，其中 pure-render-decorator 库已经帮我们实现了所需要的功能。在组件化开发过程中，要尽可能地满足 Pure，这样才能保证对相应的变更作出最少的渲染。

**优化 PureRender**

+ 在使用 React 写组件的过程中，PureRender 可能是最重要也是最常见的性能优化方法。试想在数据可变的情况下，深比较的成本是相当昂贵的。但事实上，浅比较可以覆盖的场景并不是那么多。如果说 props 或 state 中有以下几种类型的情况，那么无论如何，它都会触发 Pure Render 为true。 
+ 直接为 props 设置对象或数组
  + 我们知道，**每次调用 React 组件其实都会重新创建组件。就算传入的数组或对象的值没有改**
    **变，它们引用的地址也会发生改变**。比如，下面为 Account 组件设置一个 style prop： 
  + <Account style={{ color: 'black' }} /> 
  + 这样设置 prop，则每次渲染时 style 都是**新对象**。对于这样的赋值操作，我们只需要提前赋值成常量，不直接使用字面量即可。再比如，我们为 style prop 设置一个默认值也是一样的道理： 
  + <Account style={this.props.style || {}} /> 
  + 此时，我们只需要将默认值保存成同一份引用，就可以避免这个问题： 
  + const defaultStyle = {}; 
    <Account style={this.props.style || defaultStyle} /> 
  + 同样，像在 props 中为对象或数据计算新值会使 PureRender 无效： 
  + <Item items={this.props.items.filter(item => item.val > 30)} /> 

+ 我们可以马上想到**始终让对象或数组保持在内存中**就可以增加命中率。但保持对象引用不符合函数式编程的原则，这为函数带来了副作用，下一节介绍的 Immutable.js 可以优雅地解决这类问题。 

**设置 props 方法并通过事件绑定在元素上**

+ 这与 2.1.2 节讲述的是同一件事，只是从优化的角度重新提起。比如：

  ```react
  import React, { Component } from 'react'; 
  class MyInput extends Component { 
    constructor(props){ 
      super(props); 
      this.handleChange = this.handleChange.bind(this); 
    } 
    handleChange(e) { 
      this.props.update(e.target.value); 
    } 
    render() { 
      return <input onChange={this.handleChange} />; 
    } 
  } 
  ```

+ 我们不用每次都绑定事件，因此把绑定移到构造器内。如果绑定方法需要传递参数，那么可以考虑通过抽象子组件或改变现有数据结构解决。 

**设置子组件**

+ 对于设置了子组件的 React 组件，在调用 shouldComponentUpdate 时，均返回 true。为什么呢？下面以 NameItem 组件为例来介绍：

+ ```react
  import React, { Component } from 'react';  
  class NameItem extends Component {  
    render() {  
      return (  
        <Item>  
          <span>Arcthur</span>   
          <Item/>  
      )  
    }  
  } 
  
  ```

+ 上面的子组件 JSX 部分翻译过来，其实是：

+ ```REACT
  <Item 
    children={React.createElement('span', {}, 'Arcthur')} 
  /> 
  
  ```

+ 显然，Item 组件不论什么情况下都会重新渲染。那么，怎么避免 Item 组件的重复渲染呢？很简单，我们**给 NameItem 设置 PureRender**，也就是说提到父级来判断： 

  ```react
  import React, { Component } from 'react'; 
  import PureRenderMixin from 'react-addons-pure-render-mixin'; 
  class NameItem extends Component { 
    constructor(props) { 
      super(props); 
      this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); 
    } 
    render() { 
      return ( 
        <Item> 
          <span>Arcthur</span> 
        </Item> 
      ); 
    } 
  } 
  ```

+ 如果 NameItem 再加兄弟组件，Item 组件不得不被影响到，解决方法同样是将 Item 抽象的 NameItem 提出。 

### Immutable 

+ 在传递数据时，可以直接使用 Immutable Data 来进一步提升组件的渲染性能。 
+ JavaScript 中的对象一般是可变的（mutable），因为使用了引用赋值，新的对象简单地引用了原始对象，改变新的对象将影响到原始对象。
+ 虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，可变性带来的优点变得得不偿失。
+ 为了解决这个问题，一般的做法是使用浅拷贝（shallowCopy）或深拷贝（deepCopy）来避免被修改，但这样做又造成了 CPU 和内存的浪费。 

+ 这时 Immutable 的出现很好地解决这些问题。 

**Immutable Data**

+ Immutable Data 就是一旦创建，就**不能再更改的数据**。对 Immutable 对象进行修改、添加或删除操作，都会返回一个新的  Immutable  对象。
+ Immutable  实现的原理是**持久化的数据结构 （persistent data structure）**，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免深拷贝把所有节点都复制一遍带来的性能损耗Immutable 使用了**结构共享（structural sharing）**，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。 
+ Facebook 工程师 Lee Byron 花费三年时间打造 Immutable.js 库，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的持久化数据结构，还有很多易用的数据类型，比如 Collection、List、Map、Set、Record、Seq。有非常全面的 map、filter、groupBy、reduce、find 等函数式操作方法。同时，API 也尽量与 JavaScript 的 Object 或 Array 类似。 

+ 其中有 3 种最重要的数据结构说明一下。
  + Map：键值对集合，对应于 Object，ES6 也有专门的 Map 对象。
  + List：有序可重复的列表，对应于 Array。
  + ArraySet：无序且不可重复的列表。

**Immutable 的优点**

+ **降低了“可变”带来的复杂度**。可变数据耦合了 time 和 value 的概念，造成了数据很难被回溯。比如：

  ```js
  function touchAndLog(touchFn) {
   let data = { key: 'value' };  
    touchFn(data); 
    console.log(data.key); 
  } 
  ```

  + 在不查看 touchFn 的代码的情况下，因为不确定方法对 data 做了什么，我们是不可能知道结果是什么。但如果 data 是不可变的呢，你会很肯定地知道打印的结果是 value。 

+ **节省内存**。Immutable 使用结构共享尽量复用内存。没有被引用的对象会被垃圾回收：

  ```react
  import { Map } from 'immutable';
  let a = Map({ 
    select: 'users', 
    filter: Map({ name: 'Cam' }), 
  }); 
  let b = a.set('select', 'people'); 
  a === b; // => false 
  a.get('filter') === b.get('filter'); // => true
  
  ```

  + 上面 a 和 b 共享了没有变化的 filter 节点。 

+ **撤销/重做，复制/粘贴，甚至时间旅行这些功能做起来都是小菜一碟**。因为每次数据都是不一样的，那么只要把这些数据放到一个数组里存储起来，想回退到哪里，就拿出对应的数据，这很容易开发出撤销及重做这两种功能。
+ **并发安全**。传统的并发非常难做，因为要处理各种数据不一致的问题，所以“聪明人”发明了各种锁来解决。但使用了 Immutable 之后，数据天生是不可变的，并发锁就不再需要了。然而现在并没有用，因为 JavaScript 还是单线程运行的。
+ **拥抱函数式编程**。Immutable 本身就是函数式编程中的概念。只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。
+ 像  ClojureScript、Elm  等函数式编程语言中的数据类型天生都是不可变的，这也是基于 ClojureScript 的 React 框架 Om 性能比 React 好的原因。 

**使用 Immutable 的缺点**

+ 容易与原生对象混淆是使用 Immutable 的过程中遇到的最大的问题。 
+ 虽然 Immutable 尽量把 API 设计的原生对象类似，但还是很难区分到底是 Immutable 对象还是原生对象。 

+ Immutable 中的 Map 和 List 虽然对应的是 JavaScript 的 Object 和 Array，但操作完全不同，比如取值时要用 map.get('key') 而不是 map.key，要用 array.get(0) 而不是 array[0]。另外，Immutable 每次修改都会返回新对象，很容易忘记赋值。 

+ 当使用第三方库的时候，一般需要使用原生对象，同样容易忘记转换对象。下面给出一些办法来避免类似问题的发生： 
  + 使用 FlowType 或 TypeScript 静态类型检查工具；
  + 约定变量命名规则，如所有 Immutable 类型对象以 $$ 开头；
  + 使用 Immutable.fromJS 而不是 Immutable.Map 或 Immutable.List 来创建对象，这样可以避免 Immutable 对象和原生对象间的混用。

**Immutable.is**

+ 两个  Immutable 对象可以使用 === 来比较，这样是直接比较内存地址，其性能最好。但是即使两个对象的值是一样的，也会返回 false： 

+ ```js
  let map1 = Immutable.Map({a:1, b:1, c:1}); 
  let map2 = Immutable.Map({a:1, b:1, c:1}); 
  map1 === map2; // => false 
  
  Immutable.is(map1, map2);  // => true 
  ```

+ 为了直接比较对象的值，Immutable 提供了 Immutable.is 来作“**值比较**”： 

+ Immutable.is 比较的是两个对象的 hashCode 或 valueOf（对于  JavaScript  对象）。由于 Immutable 内部使用了 trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。这样的算法避免了深度遍历比较，因此性能非常好。 

+ 另外，还有 mori、cortex 等库。因为它们与 Immutable.is 类似，所以这里就不再一一介绍了。 

**Immutable 与 cursor**

+ 这里的 cursor 和数据库中的游标是完全不同的概念。由于 Immutable 数据一般嵌套非常深，所以为了便于访问深层数据，cursor 提供了可以直接访问这个深层数据的引用：

+ ```js
  import Immutable from 'immutable'; 
  import Cursor from 'immutable/contrib/cursor'; 
  let data = Immutable.fromJS({ a: { b: { c: 1 } } }); 
  // 让 cursor 指向 { c: 1 } 
  let cursor = Cursor.from(data, ['a', 'b'], newData => { 
    // 当 cursor 或其子 cursor 执行更新时调用 
    console.log(newData); 
  }); 
  cursor.get('c'); // 1 
  cursor = cursor.update('c', x => x + 1); 
  cursor.get('c'); // 2 
  ```

**Immutable 与 PureRender**

+ 前面已经介绍过，React  做性能优化时最常用的就是 shouldComponentUpdate 方法，但它默认返回 true，即始终会执行 render 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 的更新，这里往往会带来很多没必要的渲染。 

+ 当然，我们也可以在 should Component Update 中使用深拷贝和深比较来避免无必要的 render，但深拷贝和深比较一般都是非常昂贵的选择。 

+ Immutable.js 则提供了简洁、高效的判断数据是否变化的方法，只需 === 和 is 比较就能知道是否需要执行 render，而这个操作几乎零成本，所以可以极大提高性能。修改后的shouldComponentUpdate 是这样的：

+ ```react
  import React, { Component } from 'react'; 
  import { is } from 'immutable'; 
  class App extends Component { 
    shouldComponentUpdate(nextProps, nextState) { 
      const thisProps = this.props || {}; 
      const thisState = this.state || {}; 
      if (Object.keys(thisProps).length !== Object.keys(nextProps).length || 
          Object.keys(thisState).length !== Object.keys(nextState).length) { 
        return true; 
      } 
      for (const key in nextProps) { 
        if (nextProps.hasOwnProperty(key) && 
            !is(thisProps[key], nextProps[key])) { 
          return true; 
        } 
      } 
      for (const key in nextState) { 
        if (nextState.hasOwnProperty(key) && 
            !is(thisState[key], nextState[key])) { 
          return true; 
        } 
      } 
      return false; 
    } 
  } 
  ```

+ 使用 Immutable 后，当灰色节点的 state 变化后，不会再渲染树中的所有节点，而是只渲染图
  右侧灰色的部分，如图 2-4 所示。 

  +  ![1551967434888](F:\OneDrive\JS\纲略合集\assets\1551967434888.png) 

**Immutable 与 setState**

+ React 建议把 this.state 当作不可变的，因此修改前需要做一个深拷贝： 

+ ```react
  import React, { Component } from 'react'; 
  import '_' from 'lodash'; 
  class App extends Component { 
    constructor(props) { 
      super(props); 
      this.state = { 
        data: { times: 0 }, 
      } 
    } 
    handleAdd() { 
      let data = _.cloneDeep(this.state.data); 
      data.times = data.times + 1; 
      this.setState({ data: data }); 
      // 如果上面不做 cloneDeep，下面打印的结果会是加 1 后的值
      console.log(this.state.data.times); 
    } 
  } 
  
  ```

+ 但在使用 Immutable 后，操作变得很简单： 

+ ```react
  import React, { Component } from 'react'; 
  class App extends Component { 
    constructor(props) { 
      super(props); 
      this.state = { 
        data: Map({ times: 0 }), 
      } 
    } 
    handleAdd() { 
      this.setState(({ data }) => ({ 
        data: data.update('times', v => v + 1), 
      })); 
      // 这时的 times 并不会改变 
      console.log(this.state.data.get('times')); 
    } 
  } 
  
  ```

+ Immutable 可以给应用带来极大的性能提升，但是否使用还要看项目情况。由于侵入性较强，新项目引入比较容易，老项目迁移需要谨慎地评估迁移成本。对于一些提供给外部使用的公共组件，最好不要把 Immutable 对象直接暴露在对外的接口中。 

### key 

+ 写动态子组件的时候，如果没有给动态子项添加 key prop，则会报一个警告： 这个警告指的是，如果每一个子组件是一个数组或迭代器的话，那么必须有一个唯一的 key prop。这个 key prop 究竟是做什么的呢？ 

+ 我们想象一下，假如需要渲染一个有 5000 项的成绩排名榜单，而且每隔几秒就会更新一次排名，其中大部分排名只是位置变了，还有少部分的是完全更新了，少部分则是清出榜单了。

+ 此时 key 就发挥作用了，它是用来标识当前项的唯一性的 props。

+ 当 key 相同时，React 会怎么渲染呢？答案是只渲染第一个相同 key 的项，且会报一个警告： 

  + Warning: flattenChildren(…): Encountered two children with the same key, `.$a`. Child keys must be unique; when two children share a key, only the first child will be used. 

+ 因此，对 key 有一个原则，那就是独一无二，且能不用遍历或随机值就不用，除非列表内容也并不是唯一的表示，且没有可以相匹配的属性。 

+ 关于 key，我们还需要知道的一种情况是，有两个子组件需要渲染的时候，我们没法给它们设 key。这时需要用到 React 插件 createFragment 来解决： 

+ ```react
  import React from 'react'; 
  import createFragment from 'react-addons-create-fragment'; 
  function Rank({ first, second }) { 
    const children = createFragment({ 
      first: first, 
      second: second, 
    }); 
    return ( 
      <ul> 
        {children} 
      </ul> 
    ); 
  } 
  
  ```

+ 上述代码中，first 和 second 两个 prop 的 key 就是我们设置对象的 key。 

### react-addons-perf 

+ 做了这么多工作，怎么才能量化以上所做的性能优化的效果呢？这里介绍一个**性能检测工具**来帮助我们找到应用的性能瓶颈之所在。 
+ react-addons-perf 是官方提供的插件。通过 Perf.start() 和 Perf.stop() 两个 API 设置开始和结束的状态来作分析。它会把各组件渲染的各个阶段的时间统计出来，然后打印出一张表格。
+  react-addons-perf 可以打印组件渲染的各个阶段，如图 2-5 所示。 
  + Perf.printInclusive(measurements)：所有阶段的时间。
  + Perf.printExclusive(measurements)：不包含挂载组件的时间，即初始化  props、state，调用 componentWillMount 和 componentDidMount 方法的时间等。
  + Perf.printWasted(measurements)：监测渲染的内容保持不变的组件（可以查看哪些组件没有被 shouldComponentUpdate 命中）。

+ 无论是 PureRender 还是 key 值，整个 React 组件的优化逻辑都是针对 Virtual DOM 的更新优化。如果需要用到更复杂的方法，推荐先阅读第 3 章，深度探究 Virtual DOM 的运行原理。 

## 动画 

+ 动画可以帮助用户理解页面，增加应用的趣味性和可玩性，提高用户体验。有时候，一个好的加载动画甚至要比优化数据库、减少等待时间要有效得多。 
+ React 通过 setState 让界面**迅速发生变化**，但动画的哲学告诉我们，变化要慢，得用一个逐渐变化的过程来过渡，从而帮助用户理解页面。 
+ 界面的变化可以分为 DOM 节点（或组件）的增与减以及 DOM 节点（或组件）属性的变化。
+ 其中 React 提供的 **TransitionGroup** 能够帮助我们便捷地识别出增加或删除的组件，从而让我们能够专注于更加简单的属性变化的动画。 
+ 关于  JavaScript  动画与  CSS  动画的说法不一，为了方便起见，这里统一将**缓动函数**通过 JavaScript 实现的动画称作 JavaScript 动画，缓动函数由 CSS 提供（浏览器实现）的动画称作 CSS 动画。 

### CSS 动画与 JavaScript 动画 

+ 总的来说，使用 CSS 动画，能够得到更好的性能和更快的开发效率。尽管运用 CSS 更加方便，但必然有其作为 DSL 的局限性。当碰到 CSS 的局限性，导致用 CSS 无法实现或者实现起来十分烦琐时，就是使用 JavaScript 动画的时候了。 

#### CSS 动画的局限性

+  CSS 只支持 cubic-bezier 的缓动，如果你的动画对缓动函数有要求，就必须使用 JavaScript 动画。
+ CSS  动画只能针对一些特有的  CSS  属性。仍然有一些属性是  CSS  动画不支持的，例如SVG 中 path 的 d 属性。
+ CSS 把 translate、rotate、skew 等都归结为一个属性——transform。因此，这些属性只能共用同一个缓动函数。例如，我们想要动画的轨迹是一条贝塞尔曲线，可以通过给 left和 top 这两个属性加两个不同的 cubic-bezier 缓动来实现，但是 left 和 top 实现的动画性能不如 translateX 和 translateY。

#### CSS animation

+ CSS transition 设计得非常简洁，因此适用于比较简单的动画。而 CSS animation 弥补了 CSS transition 在控制上的不足。利用 CSS animation，我们可以： 
  + 使用多步动画（多关键帧动画）；
  + 弥补 CSS transition 在控制上的不足，设置动画的反转、暂停、次数（可以设置为永久）等。

#### 用 Java Script 包装过的 CSS 动画

+ 有些文章也把用 JavaScript 包装过的 CSS 动画归结为 JavaScript 动画，这样 CSS 动画的范畴就太小了。原生的 CSS 动画可以很方便地实现一些微互动，如： 

  + ```css
    el { 
      opacity: 1; 
      &:hover { 
        opacity: 0.8; 
        transition: opacity .4s ease; 
      } 
    } 
    ```

+ 但是对于大多数情况而言，使用原生 CSS 动画，流程比较烦琐

  + 首先，我们要给 DOM 节点在不同状态下加**不同的复杂的 className** 。
  + 然后在 CSS 中给不同的 className 写不同的样式以及动画逻辑。
  + 这里就有必要用 JavaScript 做一些包装，来做一些共同的逻辑，简化动画的开发。 

+ 这里我们介绍使用 react-smooth 库来写动画。它不仅支持 CSS 动画，也支持各种缓动类型的 JavaScript 动画，并且提供定制化缓动函数的插件入口： 

  + ```react
    <Animate from={1} to={0.8} attributeName="opacity"> 
      // ... 
    </Animate> 
    ```

#### Java Script 动画

+ 这里将 JavaScript 动画定义为缓动函数用 JavaScript 实现的动画，因此 JavaScript 动画包含缓
  动函数部分和渲染部分。 
+ 2.7.3  节将详细说明缓动函数以及如何用  JavaScript  实现缓动函数。而在渲染部分，可以在View 层利用强大的 React 来帮助我们渲染。这样只要在缓动函数中执行 setState 来更新动画进度，从而触发页面重绘。 

#### SVG 线条动画

+ 说起 SVG 线条动画，最出名的恐怕是 vivus.js，它巧妙地利用了 SVG path 的 stroke-dasharray属性和 getTotalLength 方法。 

+ stroke-dasharray 是设置 SVG path 虚线的属性。因此，要做一个简单的线条动画，只需： 

  ```css
    el { 
     stroke-dasharray: 0, 1px; 
     &.active { 
       stroke-dashoffset: totalLength, 0; 
     	 transition: stroke-dasharray .4s ease; 
      } 
    } 
  ```

+ 然而 vivus 有两个缺陷：

  + 它用 JavaScript 动画实现 stroke-dasharray 的缓动，而实际上 CSS 动画是支持 stroke- 
    dasharray 属性的；
  + vivus 不支持虚线动画。

+ 那么，如何利用 stroke-dasharray 来实现虚线动画呢？ 
+ stroke-dasharray，顾名思义，其值其实是一个数组。因此，我们可以利用这一特性逐渐改变这个数组的长度，如： 
  + 1px, 0px; 
    2px, 0px; 
    2px, 1px; 
    2px, 2px, 1px; 
    2px, 2px, 2px; 
    2px, 2px, 2px, 1px; 
    2px, 2px, 2px, 2px; 

### 玩转 React Transition 

+ 2015 年，React 给整个前端界带来了一种新的开发方式，我们抛弃了无所不能的 DOM 操作。对于 React 实现动画这个命题，DOM 操作已经是一条死路，而 CSS3 动画又只能实现一些最简单的功能。这时候 ReactCSSTransitionGroup 插件无疑是一枚强心剂。 
+ React  渲染结果的任何变化，无非是组件节点的增、添、删除和组件属性的变化。React Transition 帮助开发者识别组件的子组件们的增与删。下面让我们来谈谈 React Transition 的设计、用法、实现原理，以及基于 React Transition 封装的又一个好工具 React CSS Transition。 

#### React Transition 的设计及用法

+ 学习 API 或者用法很简单，但是在学习 API 的时候，我们不妨也来思考一下 React Transition API 的设计，说不定会有更多的收获。 
+ React Transition 如何帮助开发者识别增删的节点呢？方法有很多，而 React 结合自己的特点，设计了以生命周期函数的方式来实现，即让子组件的每一个实例都实现相应的生命周期函数。当 React Transition 识别到某个子组件增或删时，则调用它相应的生命周期函数。我们可以在生命周期函数中实现动画逻辑。

+ 事实上，一个组件中所有子组件的增删动画逻辑大同小异（动效的统一性）。如果每一个子组件的动效相同，那么每一个子组件可以共用同一个生命周期函数。因此，React Transition 提供了  childFactory  配置，让用户自定义一个封装子组件的工厂方法，为子组件加上相应的生命周期函数。 
+ React Transition 提供了哪些生命周期呢？想想也知道，它们无非是： 
  + componentWillAppear
  + componentDidAppear
  + componentWillEnter
  + componentDidEnter
  + componentWillLeave
  + componentDidLeave

+ component Willxxx  在什么时候触发很容易判断，只需在  component Will Receive Props  中对this.props.children 和 next Props.children 做一个比较即可。而 component Didxxx 要何时触发呢？

+ 可以给 componentWillxxx 提供一个回调函数，用来执行 componentDidxxx。 

+ React Transition 的 API 设计正是这样的，你若感到迷惑，可以先来看一个例子。 

+ 之前说过，React Transition 对 CSS 动画做了封装，因此我们来实现一个 React Transition 的 JavaScript 动画。在实现 React Transition 的 childFactory 工厂方法的时候，我们可以先实现一个 JSTransitionChild 的类： 

+ ```REACT
  update(done, now) { 
    if (!this.leaveTime) { 
      this.leaveTime = now; 
    } 
    const { duration } = this.props; 
    const passedTime = now - this.enterTime; 
    if (passedTime > duration) { 
      if (this.cafId) { 
        caf(this.cafId); 
        this.leaveTime = null; 
      } 
      done(); 
      return; 
    } 
    const progress = ease(passedTime / duration); 
    this.setState({ 
      progress, 
    }) 
    this.cafId = raf(this.enter.bind(this, done)); 
  } 
  componentWillLeave(done) { 
    if (this.cafId) { 
      caf(this.cafId); 
      this.leaveTime = null; 
    } 
    raf(this.update.bind(this, done)); 
  } 
  ```

+ 虽然我们没有实现  componentDidLeave  函数，但是仍然如实地在正确的地方执行了  done  回调，确保 componentDidLeave 执行。这是为什么呢？ 

+ componentWillLeave  中的回调函数（即这里的  done）有点特殊。我们知道，React  动画归根结底是让状态变化变慢，或者说延迟变化。那么对于消失的动画来说，我们要花费一段时间展现消失的动画，就必须让消失的子组件延迟消失，在这段时间内暂时保留。因此，这里的回调函数不仅仅是执行 componentDidLeave，也执行了让这个子组件从子组件集中消失的操作。

#### React CSS Transition 设计及用法

+ React Transition 还对 CSS 动画做了专门的封装。用 CSS3 来做 React 动画简直完美！我们不用像 JavaScript 动画那样用 setState 来让状态延缓更新，CSS3 中就有让状态延迟更新的方法。我们把延迟更新状态的逻辑交给 CSS，不仅可以让代码更加专注于业务逻辑，更为简洁，还能提高动画的性能。 

+ React CSS Transition 为子组件的每个生命周期加了不同的 className，这样用户可以很方便地根据 className 的变化来实现动画。例如： 

  ```react
  <ReactCSSTransitionGroup 
    transitionName="example" 
    transitionEnterTimeout={400} 
  > 
    {items} 
  </ReactCSSTransitionGroup> 
  ```

+ 对应的 SCSS 代码为： 

  ```scss
  .example-enter { 
    transform: scaleY(0); 
    &.example-enter-active { 
      transform: scaleY(1); 
      transition: transform .4s ease; 
    } 
  } 
  
  ```

+ 这样便轻松地实现了 items 中新增元素的动画。

+ 在使用 React Transition 时，如何设定子组件集的 key 也颇有学问，毕竟代表一个元素的不是它的位置，而是它的 key 值。 

+ 例如：我们要展现 10 年来 GDP 排名前 10 的省份，把动画加在某个名次省份发生更新的元素上，此时可以把 key 设置为 \${名次}-​${省份id}。 

+ 当然，如果使用 react-smooth 来实现，会更简洁： 

  ```react
  const enter = { 
   from: 'scaleY(0)', 
   to: 'scaleY(1)', 
   attributeName: 'transform', 
   duration: 400, 
  }; 
  // 支持列表动画 
  <AnimateGroup enter={enter}> 
    {items} 
  </AnimateGroup> 
  
  ```

### 缓动函数

+ 虽然 CSS 动画简单易用而且性能高，但是 JavaScript 动画依然有其必要性，而且也非常重要。而谈到 JavaScript 动画，不得不说一说缓动函数。
+ 缓动函数是什么，它是一个返回当前帧动画进度的函数。 

**缓动函数用户体验**

+ 从动画体验的角度来说，不同的缓动函数会带给用户不同的缓动体验。以我们常见的缓动函数 linear、ease 和 spring 为例，缓动体验一般为 linear < ease < spring。 
+ 为什么这么说呢？linear、ease 和 spring 其实刚好代表 3 种缓动函数类型。其中，linear 是一种匀速运动，给人的感觉是机械、呆板、没有生机，只有工厂里的机器是保持速度一成不变的！人们喜欢有生命的运动。 
+ ease、spring 都是变速运动，那么为什么 spring 的缓动体验要比 ease 更好呢？物理原则是优秀用户体验（UX）的核心原则之一，界面设计遵从物体在**真实世界**中的运动规律，会让人们感觉更加自然、舒适。 

+ spring 是最经典、最常用的物理缓动过程。而 cubic-bezier（三次贝塞尔曲线） 因为具有很强的控制能力，人们可以非常简单、直观地配置一条 y - t 曲线作为缓动过程。因此，spring 和 cubic-bezier（如  ease、ease-in、ease-out、ease-in-out、linear）在动画中最为常用。
+ 所以下面先以 spring 为例探讨一种通用的物理缓动的实现方法，然后谈谈如何实现 cubic-bezier 的缓动过程。 

**物理缓动**

+ 根据经典力学的观点，世界上所有的原子每时每刻仿佛都会根据当前速度、受力和位置计算出下一刻的速度、受力和位置。上帝有一台超级计算机吗？非也，计算机反而是我们利用原子的这些特性拼装出来的。不过现在，我们要用计算机，像上帝那样再造一个世界。
+ 物理缓动是模仿现实世界物体运动的缓动，我们可以先模拟物理规律，然后用最简洁的物理法则的表述方式——物理公式来计算物体状态。一个简单的思路跃然纸上： 
  + 在每一帧中对动画对象进行受力分析，计算该帧动画对象的加速度；
  + 如果知道该帧的速度、位置，就可以根据该帧的加速度、速度、位置，计算下一帧的速
    度、位置；
  + 当我们知道第一帧的速度和位置，就可以像多米诺骨牌那样算出动画对象每一帧的位置！
  + 任何物理缓动都可以这样完成！

**模拟物理规律**

+ 万变不离其宗，这里  spring  只是一个简单的例子。使用这种通用的模拟物理规律的方法，我们可以实现任意物理动画的缓动，比如一个复杂而炫酷的用 three.js 实现的动画①。 

+ 现在，我们利用 react-smooth 来实现弹簧动画： 

  ```react
  <Animate from={{left: 0}} to={{left: 10}} ease="spring"> 
    {style => <div style={style}>test</div>} 
  </Animate> 
  
  ```

+ 不过说到 spring 动画，不得不提起 react-motion 库。下面是使用 react-motion 库实现一个开关的例子： 

  ```react
  import React, { Component } from 'react'; 
  class Switch extends Component { 
    constructor(props) { 
      super(props); 
      this.handleClick = this.handleClick.bind(this); 
      this.state = { 
        open: false, 
      }; 
    } 
    handleClick() { 
      this.setState({ 
        open: !this.state.open, 
      }); 
    } 
    render() { 
      return ( 
        <Motion style={{x: spring(this.state.open ? 400 : 0)}}> 
          {({x}) => 
          <div className="demo"> 
          <div 
            className="demo-block" 
            onClick={this.handleClick} 
            style={{ 
              transform: `translate3d(${x}px, 0, 0)`, 
            }} 
            /> 
        </div> 
          } 
        </Motion> 
      ); 
    } 
  } 
  
  ```

**cubic-bezier 缓动**

+ 物理动画固然炫酷，但是 cubic-bezier 同样是一个非常优秀的缓动过程。 
+ cubic-bezier 可以非常直观、方便地配置一条变速运动的缓动曲线。由于 CSS 原生提供 cubic- bezier 的缓动函数，所以 cubic-bezier 在 Web 动画中得到大量使用。 
+ 然而，由于 CSS 这种 DSL 的局限性，我们经常不得不用程序语言来实现一个缓动过程。举一个最简单的例子，由于 CSS 的缓动只能作用于值类型的 CSS 属性，所以假设要根据某种规则对 SVG path 的 d 属性做动画，CSS 便毫无用武之地。此时人们往往会用丑陋的 linear 缓动实现一个 JavaScript 动画，说好的变速运动呢？ 
+ 因此，有必要用程序语言实现一个 cubic-bezier。 
+ cubic-bezier 函数表达式

## 自动化测试 

+ 测试可以让项目保持健壮，在后期维护和扩展的过程中，减少犯错的几率。当项目发布时，代码能通过所有测试也代表所覆盖到的场景全部通过。自动化测试就是把整个流程自动化，代替复杂的人工点击。同时通过配置回调钩子，可以让测试定期执行或在每次发布前执行。自动化测试包含很多内容，本节主要指对 React 渲染的 UI 层功能的自动化测试。 
+ 写测试之前需要了解测试工具。首先需要一个测试执行器，用于执行测试用例，Mocha 是最流行的测试执行器之一。除此之外，还要使用 Chai 等库来做测试断言。熟悉这两个工具后，我们就可以搭建完整的测试环境了。 
+ React 对测试有完善的支持，目前比较完善的 React 测试框架有 Jest 和 Enzyme，下面会介绍这两个框架。

### Jest

+ Jest 是由 Facebook 开源的 React 单元测试框架，内部 DOM 操作基于 JSDOM，语法和断言基于 Jasmine 框架。它有以下 4 个特点： 
  + 自动找到测试；
  + 自动 mock 模拟依赖包，达到单元测试的目的；
  + 并不需要真实 DOM 环境执行，而是 JSDOM 模拟的 DOM；
  + 多进程并行执行测试。
+ 当使用 Jest 来测试 React 组件时，还要引入 react-addons-test-utils 插件，用于模拟浏览器事件和对 DOM 进行校验。它提供的常用方法如下。 
  + Simulate.{eventName} (DOMElement element, [object eventData])：模拟触发事件。
  + renderIntoDocument(ReactElement instance)：渲染 React 组件到文档中，这里的文档节点由 JSDOM 提供。
  + findRenderedDOMComponentWithClass(ReactComponent tree, string className)：从渲染的 DOM 树中查找含有 class 的节点。
  + findRenderedDOMComponentWithTag(ReactComponent tree, function componentClass)：从
    渲染的 DOM 树中找到指定组件的节点。

**Jest 实例**

+ ```react
  // ./__test__/tab-test.js 
  jest.unmock('../tab.js'); 
  import React from 'react'; 
  import ReactDOM from 'react-dom'; 
  import TestUtils from 'react-addons-test-utils'; 
  import Tab from '../Tab'; 
  describe('Tab', () => { 
    it('render the tab content', () => { 
      // 根据 data 渲染出 Tab 内容 
      const tab = TestUtils.renderIntoDocument( 
        <Tabs classPrefix={'tabs'} defaultActiveIndex={0} className="ui-tabs"> 
          <TabPane order="0" tab={'Tab 1'}>第一个 Tab 里的内容</TabPane> 
          <TabPane order="1" tab={'Tab 2'}>第二个 Tab 里的内容</TabPane> 
          <TabPane order="2" tab={'Tab 3'}>第三个 Tab 里的内容</TabPane> 
        </Tabs> 
      ); 
      const tabNode = ReactDOM.findDOMNode(tab); 
      // 验证渲染出 3 个 Tab 
      expect(tab.querySelectorAll('.tabs-tab').length).toEqual(3); 
      // 验证默认选中第一个 Tab，即索引为 0 的子元素含有 active 的 class 
      expect(tab.querySelectorAll('.tabs-tab')[0].classList.contains('tabs-active')).toBe(true); 
    }); 
  }); 
  // 验证了渲染后，还需要验证点击后能切换到新的 Tab： 
  describe('Tab', () => { 
    it('changes active tab after click', () => { 
      const tab = TestUtils.renderIntoDocument( 
        <Tabs classPrefix={'tabs'} defaultActiveIndex={0} className="ui-tabs"> 
          <TabPane order="0" tab={'Tab 1'}>第一个 Tab 里的内容</TabPane> 
          <TabPane order="1" tab={'Tab 2'}>第二个 Tab 里的内容</TabPane> 
          <TabPane order="2" tab={'Tab 3'}>第三个 Tab 里的内容</TabPane> 
        </Tabs> 
      ); 
      // 模拟点击第三个标签 
      TestUtils.Simulate.click( 
        tab.querySelectorAll('.tabs-tab')[2] 
      ); 
      // 第一个标签取消选中，第三个标签被选中 
      expect(tab.querySelectorAll('.tabs-tab ')[0].classList.contains('tabs-active')).toBe(false);    
      expect(tab.querySelectorAll('.tabs-tab')[2].classList.contains('tabs-active')).toBe(true); 
    }); 
  }); 
  ```

+ 综上，使用 Jest 测试组件非常容易。它既可以模拟渲染 DOM 节点，也可以模拟触发 DOM 事件。在大部分情况下，它已经很好用。 

**浅渲染机制**

+ 浅渲染（shallow  rendering）很有趣，意思就是只渲染组件中的第一层，这样测试执行器就不需要关心 DOM 和执行环境了。 

**全渲染机制**

+ 使用 JSDOM：使用 Java Script 模拟 DOM 环境，能满足 90% 的使用场景。这是 Jest 内部所使用的全渲染框架。
+ 使用 Cheerio：类似 JSDOM，更轻的实现，类似 jQuery 的语法。这是 Enzyme 内部使用的全渲染框架。
+ 使用  Karma：在真实的浏览器中执行测试，也支持在多个浏览器中依次执行测试，使用的是真实 DOM 环境，但速度稍慢。

### Enzyme 

+ Enzyme 是由 Airbnb 开源的 React 组件测试框架。与 Jest 相比，Enzyme 提供类似 jQuery 操作 DOM 的语法，在做测试断言时更灵活、易用。React 官方正讨论用 Enzyme 替代 Test Utils，这也许在下一版中就会实现。 

### 自动化测试

+ 现在是时候把整个流程自动化起来了，你需要一个持续集成服务器（CI）来把整个流程自动化。如果使用 GitHub 或 Gitlab 来管理代码，你可以使用 Travis CI 或 Circle CI。 
+ 每当有新的 Commit 提交或 PR 发起后，CI 就会自动执行测试，我们可以及时看到测试结果。 在后端工程中，早就流传着“如果这个库没有测试代码，那谁敢用”的话，可见测试在现代软件开发中扮演着越来越重要的角色，前端引入单元测试也是因为复杂客户端应用的大趋势。我们不得不对复杂的交互逻辑进行提前验证，以保证在修改功能时避免主功能上的问题。 

# 3. 解读 React 源码

+ 本章会通过分析 **React 15.0** 的源码，深入 Virtual DOM 内部的实现机制和原理，让我们一步步揭开 Virtual DOM 的神秘面纱，探索其内部的精彩世界！ 

## 初探 React 源码 

+ 在深入分析 React 源码之前，我们先大致了解一下 React 源码的组织结构，如图 3-1 所示。
+ ![1552016873296](F:\OneDrive\JS\纲略合集\assets\1552016873296.png) 
+ addons：包含一系列的工具方法插件，如 PureRenderMixin、CSSTransitionGroup、Fragment、
  LinkedStateMixin 等。
+ isomorphic：包含一系列同构方法。
+ shared：包含一些公用或常用方法，如 Transaction、CallbackQueue 等。
+ test：包含一些测试方法等。
+ core/tests：包含一些边界错误的测试用例。
+ renderers：是 React 代码的核心部分，它包含了大部分功能实现，此处对其进行单独分析。 
+ ![1552020090476](F:\OneDrive\JS\纲略合集\assets\1552020090476.png) 
  + renderers 分为 dom 和 shared 目录。 
  + dom：包含 client、server 和 shared。
    + server：主要包含服务端渲染的实现和方法（如  ReactServerRendering、ReactServer-RenderingTransaction 等）。
    + shared：包含文本组件（ReactDOMTextComponent）、标签组件（ReactDOMComponent）、
      DOM 属性操作（DOMProperty、DOMPropertyOperations）、CSS 属性操作（CSSProperty、
      CSSPropertyOperations）等。
  + shared：包含 event 和 reconciler。
    + event：包含一些更为底层的事件方法，如事件插件中心（EventPluginHub）、事件注册
      （EventPluginRegistry）、事件传播（EventPropagators）以及一些事件通用方法。 
    + React  自定义了一套通用事件的插件系统，该系统包含事件监听器、事件发射器、事件插件中心、点击事件、进/出事件、简单事件、合成事件以及一些事件方法，如图 3-3 所示。 
    + ![1552020106620](F:\OneDrive\JS\纲略合集\assets\1552020106620.png) 
    + reconciler：称为协调器，它是最为核心的部分，包含  React  中自定义组件的实现（React CompositeComponent）、组件生命周期机制、set State  机制（React Updates、React Update Queue）、DOM diff 算法（React MultiChild）等重要的特性方法。 

+ 那么，为何说 reconciler 是 React 最为核心的部分呢？ 
+ 在 Web 开发中，要将更新的数据实时反应到 UI 上，就不可避免地需要对 DOM 进行操作，而复杂频繁的 DOM 操作通常是产生性能瓶颈的原因之一。为此，React 引入了 Virtual DOM 机制。毫不夸张地说，Virtual DOM 是 React 的核心与精髓所在，而 reconciler 就是实现 Virtual DOM 的主要源码。 
+ Virtual DOM 实际上是在浏览器端用 JavaScript 实现的一套 DOM API，它之于 React 就好似一个虚拟空间，包括一整套 Virtual DOM 模型、生命周期的维护和管理、性能高效的 diff 算法和将 Virtual DOM 展示为原生 DOM 的 Patch 方法等。 
+ 基于 React 进行开发时，所有的 DOM 树都是通过 Virtual DOM 构造的。React 在 Virtual DOM 上实现了 DOM diff 算法，当数据更新时，会通过 diff 寻找到需要变更的 DOM 节点，并只对变化的部分进行实际的浏览器的 DOM 更新，而不是重新渲染整个 DOM 树。 
+ React 也能够实现 Virtual DOM 的批处理更新，当操作 Virtual DOM 时, 不会马上生成真实的 DOM，而是会将一个事件循环（event  loop）内的两次数据更新进行合并，这样就使得  React  能够在事件循环的结束之前完全不用操作真实的 DOM。例如，多次进行节点内容 A→B，B→A 的变化，React 会将多次数据更新合并为 A→B→A，即 A→A，认为数据并没有更新，因此 UI 也不会发生任何变化。如果通过手动控制，这种逻辑通常是极其复杂的。 
+ 尽管每一次都需要构造完整的 Virtual DOM 树，但由于 Virtual DOM 是 JavaScript 对象，性能极高，而对原生 DOM 进行操作的仅仅是 diff 部分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到具体的 DOM 元素，而只需要关心在任意数据状态下，整个界面是如何渲染的。 
+ 那么，React 中是如何实现 Virtual DOM 机制的呢？为众人所津津乐道的 diff 算法到底有何神秘之处呢？组件的生命周期又是如何进行管理的呢？ 
+ 从下一节开始，我们将通过分析 React 15.0 源码，深入研究 Virtual DOM 内部的实现机制及原理。 

## Virtual DOM 模型 

+ Virtual DOM 之于 React，就好比一个虚拟空间，React 的所有工作几乎都是基于 Virtual DOM 完成的。其中，Virtual DOM 模型负责 Virtual DOM 底层框架的构建工作，它拥有一整套的 Virtual DOM  标签，并负责虚拟节点及其属性的构建、更新、删除等工作。那么，Virtual  DOM  模型到底是如何构建虚拟节点，如何更新节点属性的呢？ 

+ 其实，构建一套简易 Virtual DOM 模型并不复杂，它只需要具备一个 DOM 标签所需的基本元素即可：

  + 标签名

  + 节点属性，包含样式、属性、事件等

  + 子节点

  + 标识 id 

  + ```js
    { 
      // 标签名 
     tagName: 'div', 
      // 属性 
     properties: { 
       // 样式 
       style: {} 
      }, 
      // 子节点 
     children: [], 
      // 唯一标识 
      key: 1 
    } 
    ```

+ **Virtual  DOM  中的节点称为  React Node**，它分为3种类型  React Element、React Fragment  和React Text。其中，React Element 又分为 React ComponentElement 和 React DOMElement。 

+ 下面是 ReactNode 中不同类型节点所需要的**基础元素**：

+ 那么，Virtual DOM 模型是如何根据这些节点类型来创建元素的呢？

### 创建 React 元素 

+ 在 1.2 节里，我们介绍过 JSX 的语法，现在先来回顾下它的用法。下面是一段 JSX 与编译后的 JavaScript： 

  ```js
  const Nav, Profile; 
  // 输入（JSX）：
  const app = <Nav color="blue"><Profile>click</Profile></Nav>; 
  // 输出（JavaScript）：
  const app = React.createElement( 
    Nav, 
    {color:"blue"}, 
    React.createElement(Profile, null, "click") 
  ); 
  ```

+ 通过  JSX  创建的虚拟元素最终会被编译成调用  React  的  createElement  方法。那么 createElement  方法到底做了什么，它的奥秘是什么呢？

+ 我们来解读相关源码（源码路径：/v15.0.0/src/isomorphic/classic/element/ReactElement.js）： 

+ Virtual DOM 模型通过 create Element 创建虚拟元素，那又是如何创建组件的呢？ 

### 初始化组件入口

+ 当使用 React 创建组件时，首先会调用 **instantiateReactComponent**，这是初始化组件的入口函数，它通过判断 node 类型来区分不同组件的入口。 
+ 当 node 为空时，说明 node 不存在，则初始化空组件 ReactEmptyComponent.create(instan- tiateReactComponent)。
+ 当 node 类型为对象时，即是 DOM 标签组件或自定义组件，那么如果 **element 类型为字符串**时，则初始化  DOM  标签组件  **ReactNativeComponent**.createInternalComponent(element)，否则初始化自定义组件 **ReactCompositeComponent**Wrapper()。
+ 当  node  类型为字符串或数字时，则初始化文本组件  ReactNativeComponent.create
  InstanceForText(node)。
+ 如果是其他情况，则不作处理。
+ ![1552033086110](F:\OneDrive\JS\纲略合集\assets\1552033086110.png) 

#### 文本组件

+ 当 node 类型为文本节点时是不算 Virtual DOM 元素的，但 React 为了保持渲染的一致性，将其封装为文本组件 ReactDOMTextComponent。 
+ 在执行 mount Component 方法时，React DOMText Component 通过 transaction.use Create Element 判断该文本是否是通过 create Element 方法创建的节点，如果是，则为该节点创建相应的标签和标识  dom ID，这样每个文本节点也能与其他  React  节点一样拥有自己的唯一标识，同时也拥有了 Virtual DOM diff 的权利。但如果不是通过 create Element 创建的文本，React 将不再为其创建 <span> 和 dom ID 标识，而是直接返回文本内容。
+ 不再为裸露的文本内容包裹 <span> 标签，是 React 15.0 版本的更新点之一。此前，React 为裸露的文本内容包裹上  <span>  标签，其实并没有产生任何作用，反而增加了不必要的标签，因此 React 15.0 版本将去掉这些操作。 
+ 在执行 receiveComponent 方法时，可以通过 DOMChildrenOperations.replaceDelimitedText 
  (commentNodes[0], commentNodes[1], nextStringText) 来更新文本内容。 
+ ![1552033665787](F:\OneDrive\JS\纲略合集\assets\1552033665787.png) 

#### DOM 标签组件

+ Virtual DOM 模型涵盖了几乎所有的原生 DOM 标签，如 <div>、<p>、<span> 等。当开发者使用 React 时，此时的 <div> 并不是原生 <div> 标签，它其实是 React 生成的 Virtual DOM 对象，只不过标签名称相同罢了。React 的大部分工作都是在 Virtual DOM 中完成的，对于原生 DOM 而言，Virtual DOM 就如同一个隔离的沙盒，因此 React 的处理并不是直接操作和污染原生 DOM，这样不仅保持了性能上的高效和稳定，而且降低了直接操作原生 DOM 而导致错误的风险。
+ React DOMComponent 针对 Virtual DOM 标签的处理主要分为以下两个部分： 
  + 属性的更新，包括更新样式、更新属性、处理事件等；
  + 子节点的更新，包括更新内容、更新子节点，此部分涉及 diff 算法。

**1. 更新属性**

+ 当执行 **mountComponent** 方法时，ReactDOMComponent 首先会生成标记和标签，通过 this.
  createOpenTagMarkupAndPutListeners(transaction) 来**处理 DOM 节点的属性和事件**。 
  + 如果存在事件，则针对当前的节点添加事件代理，即调用  enqueuePutListener(this,
    propKey, propValue, transaction)。
  + 如果存在样式，首先会对样式进行合并操作 Object.assign({}, props.style)，然后通过
    CSSPropertyOperations.createMarkupForStyles(propValue, this) 创建样式。
  + 通过 DOMPropertyOperations.createMarkupForProperty(propKey, propValue) 创建属性。
  + 通过 DOMPropertyOperations.createMarkupForID(this._domID) 创建唯一标识。
+ _createOpenTagMarkupAndPutListeners 方法的源码如下（源码路径：/v15.0.0/src/renderers/ 
  dom/shared/ReactDOMComponent.js）： 
+ 当 执 行 **receiveComponent** 方 法 时 ， React DOMComponent 会 通 过 this.updateComponent
  (transaction, prevElement, nextElement, context) 来更新 DOM 节点属性。
+ 先是**删除不需要的旧属性**。
  + 如果不需要旧样式，则遍历旧样式集合，并对每个样式进行置空删除；
  + 如果不需要事件，则将其事件监听的属性去掉，即针对当前的节点取消事件代理 deleteListener(this,  propKey) ； 
  + 如 果 旧 属 性 不在新 属 性 集合里 时 ，则 需要 删 除旧 属性 DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey)。  
+ 再是**更新新属性**。
  + 如果存在新样式，则将新样式进行合并 Object.assign({}, nextProp)；
  + 如果在旧样式中但不在新样式中，则清除该样式；
  + 如果既在旧样式中也在新样式中，且不相同，则更新该样式 styleUpdates[styleName] = nextProp[styleName]；
  + 如果在新样式中，但不在旧样式中，则直接更新为新样式  styleUpdates = nextProp；
  + 如果存在事件更新，则添加事件监听的属性 enqueuePutListener(this, propKey, nextProp, transaction)；
  + 如果存在新属性，则添加新属性 ， 或 者 更 新 旧 的 同 名 属 性DOMPropertyOperations.setValueForAttribute(node,  propKey, nextProp)。 
+ 至此，ReactDOMComponent 完成了 DOM 节点属性更新的操作，相关代码如下： 

**2.更新子节点**

+ 当执行  **mountComponent**  方法时，React DOMComponent  会通过  this._create Content Markup
  (transaction, props, context) 来处理 DOM 节点的内容。

+ 首先，获取节点内容  props.dangerouslySetInnerHTML。如果存在子节点，则通过  this. 
  mountChildren(childrenToUse, transaction, context) 对子节点进行初始化渲染：

+ 当执行  **receiveComponent**  方法时，React DOMComponent  会通过  this._updateDOMChildren
  (lastProps, nextProps, transaction, context) 来更新 DOM 内容和子节点。   

+ 先是**删除不需要的子节点和内容**。

  + 如果旧节点存在，而新节点不存在，说明当前节点在更新后被删除，此时执行方法this.updateChildren(null, transaction, context)；
  + 如果旧的内容存在，而新的内容不存在，说明当前内容在更新后被删除，此时执行方法  this.updateText- 
    Content('')。 

+ 再是**更新子节点和内容**。

  + 如果新子节点存在，则更新其子节点，此时执行方法 this.update- 
    Children(nextChildren, transaction, context)；
  + 如果新的内容存在，则更新内容，此时执行方法 this.updateTextContent('' + nextContent)。 

+ 至此，ReactDOMComponent 完成了 DOM 子节点和内容的更新操作，相关代码如下： 

  

+ 当卸载组件时，ReactDOMComponent 会进行一系列的操作，如卸载子节点、清除事件监听、
  清空标识等：
+ React DOMComponent 关系如图 3-6 所示。 
+ ![1552035610094](F:\OneDrive\JS\纲略合集\assets\1552035610094.png) 

#### 自定义组件

+ ReactCompositeComponent 自定义组件实现了一整套 **React 生命周期和 set State 机制**，因此自
  定义组件是在生命周期的环境中进行更新属性、内容和子节点的操作。这些更新操作与 
  React DOMComponent 的操作类似，在此就不赘述了。 
+ ![1552093561069](F:\OneDrive\JS\纲略合集\assets\1552093561069.png) 

## 生命周期的管理艺术 

+ 对于 React 组件，生命周期是它的核心概念之一。在 1.5 节中，我们已经大概了解了生命周期的概念及用法，本节将深入源码来剖析 React 生命周期的管理艺术。
+ React  的主要思想是通过构建可复用组件来构建用户界面。所谓组件，其实就是**有限状态机（FSM）**，通过状态渲染对应的界面，且每个组件都有自己的生命周期，它规定了组件的状态和方法需要在哪个阶段改变和执行。 
+ 有限状态机，表示有限个状态以及在这些状态之间的转移和动作等行为的模型。一般通过**状态、事件、转换和动作**来描述有限状态机。
+ 图 3-8 是描述组合锁状态机的模型图，包括 5 个状态、5 个状态自转换、6 个状态间转换和 1 个复位 RESET 转换到状态 s1。状态机能够记住目前所处的状态，可以根据当前的状态做出相应的决策，并且可以在进入不同的状态时做不同的操作。状态机将复杂的关系简单化，利用这种自然而直观的方式可以让代码更容易理解。 
+ ![1552093693317](F:\OneDrive\JS\纲略合集\assets\1552093693317.png) 
+ React  正是利用这一概念，通过管理状态来实现对组件的管理。
  + 例如，某个组件有**显示和隐藏**两个状态，通常会设计两个方法  show()  和  hide()  来实现切换，而  React  只需要设置状态 setState({ showed: true/false }) 即可实现。同时，React 还引入了组件的生命周期这个概念。通过它，就可以实现组件的**状态机控制**，从而达到“**生命周期→状态→组件**”的和谐画面。 
+ 虽然组件、状态机、生命周期这三者都不是 React 独创的，但 Web Components 标准与其中的自定义组件的生命周期的概念相似。就目前而言，React 是将这几种概念结合得相对清晰、流畅的 View 实现。 

### 初探 React 生命周期 

+ 在自定义 React 组件时，我们会根据需要在组件生命周期的不同阶段实现不同的逻辑。为了查看组件生命周期的执行顺序，推荐使用 **react-lifecycle mixin**。将此 mixin 添加到需要观察的组件中，当任何生命周期方法被调用时，就能在控制台观察到对应的生命周期的调用时状态。
+ 通过反复试验，我们得到了组件的生命周期在不同状态下的执行顺序。
  + 当**首次挂载组件**时，按顺序执行 getDefaultProps、getInitialState、componentWillMount、
    render 和 componentDidMount。
  + 当**卸载组件**时，执行 componentWillUnmount。
  + 当**重新挂载组件**时，此时按顺序执行  getInitialState、componentWillMount、render  和
    componentDidMount，但并不执行 getDefaultProps。
  + 当**再次渲染组件**时，组件接受到**更新状态**，此时按顺序执行  componentWillReceiveProps、
    shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate。 
+ 当使用 ES6 classes 构建 React 组件时，static defaultProps = {} 其实就是调用内部的 **getDefaultProps** 方法，constructor 中的 this.state = {} 其实就是调用内部的 **getInitialState** 方法。
+ 因此，源码解读的部分与用 createClass 方法构建组件一样。 
+ ![1552093987602](F:\OneDrive\JS\纲略合集\assets\1552093987602.png) 
+ 那么，为何 React 会按上述顺序执行生命周期？
+ 为何多次渲染时，React 会执行生命周期的不同阶段？
+ 为何 getDefaultProps 只执行了一次？ 

### 详解 React 生命周期 

+ 自定义组件（ReactCompositeComponent）的生命周期主要通过  **3  个阶段**进行管理—— MOUNTING、RECEIVE_PROPS 和 UNMOUNTING，它们负责通知组件当前所处的阶段，应该执行生命周期中的哪个步骤。这 3 个阶段对应 3 种方法，分别为：mountComponent、updateComponent和 unmountComponent，每个方法都提供了几种处理方法，其中带 **will 前缀**的方法在进入状态之前调用，带 **did 前缀**的方法在进入状态之后调用。3 个阶段共包括 5 种处理方法，还有两种特殊状态的处理方法。 
+ ![1552094101387](F:\OneDrive\JS\纲略合集\assets\1552094101387.png) 

#### 使用 createClass 创建自定义组件

+ createClass 是创建自定义组件的入口方法，负责管理生命周期中的 getDefaultProps。**该方法在整个生命周期中只执行一次**，这样所有**实例初始化的 props 将会被共享**。 

  + 在构造函数中初始化，每个实例都可以访问了，所以只执行一次即可

+ 通过 createClass 创建自定义组件，利用**原型继承** ReactClassComponent 父类，按顺序合并 mixin，设置初始化 defaultProps，**返回构造函数**。 

+ 当使用 **ES6 classes** 编写 React 组件时，class MyComponent extends React.Component 其实就
  是**调用内部方法 createClass 创建组件**，相关代码如下（源码路径：/v15.0.0/src/isomorphic/classic/ 
  class/React Class.js#L802）： 

  ```js
  var ReactClass = { 
    // 创建自定义组件 
    createClass: function(spec) { 
      var Constructor = function(props, context, updater) { 
        // 自动绑定 
        if (this.__reactAutoBindPairs.length) { 
          bindAutoBindMethods(this); 
        } 
        this.props = props; 
        this.context = context; 
        this.refs = emptyObject; 
        this.updater = updater || ReactNoopUpdateQueue; 
        this.state = null; 
        // ReactClass 没有构造函数，通过 getInitialState 和 componentWillMount 来代替 
        var initialState = this.getInitialState ? this.getInitialState() : null; 
        this.state = initialState; 
      }; 
      // 原型继承父类 
      Constructor.prototype = new ReactClassComponent(); 
      Constructor.prototype.constructor = Constructor; 
      Constructor.prototype.__reactAutoBindPairs = []; 
      // 合并 mixin
      injectedMixins.forEach( 
        mixSpecIntoComponent.bind(null, Constructor) 
      ); 
      mixSpecIntoComponent(Constructor, spec); 
      // 所有 mixin 合并后初始化 defaultProps(在整个生命周期中，get DefaultProps 只执行一次)
      if (Constructor.getDefaultProps) { 
        Constructor.defaultProps = Constructor.getDefaultProps(); 
      } 
      // 减少查找并设置原型的时间 
      for (var methodName in ReactClassInterface) { 
        if (!Constructor.prototype[methodName]) { 
          Constructor.prototype[methodName] = null; 
        } 
      } 
      return Constructor; 
    }, 
  }; 
  ```

#### 阶段一：MOUNTING

+ mountComponent  负责管理生命周期中的  getInitialState、componentWillMount、render  和 
  componentDidMount。
+ 由于 getDefaultProps 是通过**构造函数**进行管理的，所以也是整个生命周期中最先开始执行的。而 mountComponent 只能望洋兴叹，无法调用到 getDefaultProps。这就解释了为何 getDefault- Props只执行一次。 
+ 由于通过 ReactCompositeComponentBase 返回的是一个虚拟节点，所以需要利用 instantiateReact-Component 去**得到实例**，再使用 mountComponent 拿到结果作为当前自定义元素的结果。
+ 通过 mountComponent **挂载组件，初始化序号、标记等参数**，判断是否为无状态组件，并进行对应的组件初始化工作，比如初始化 props、context 等参数。利用 getInitialState 获取初始化 state、初始化更新队列和更新状态。  
+ 若存在 componentWillMount，则执行。如果此时在 componentWillMount 中调用 setState 方法，是不会触发 re-render的，而是会进行 **state 合并**，且 inst.state = this._processPendingState(inst.props, inst.context) 是在 componentWillMount 之后执行的，因此 componentWillMount 中的 this.state 并不是最新的，**在 render 中才可以获取更新后的 this.state**。 
+ 因此，React 是利用**更新队列** this._pendingStateQueue 以及**更新状态** this._pendingReplaceState 和 this._pendingForceUpdate 来实现 **setState 的异步更新机制**。 
+ 当**渲染完成**后，若存在 component Did Mount，则调用。这就解释了 component Will Mount 、render 、 
  component Did Mount 这三者之间的执行顺序。 
+ 其实，mountComponent  本质上是通过**递归渲染内容**的，由于递归的特性，父组件的
  componentWillMount 在其子组件的 componentWillMount 之前调用，而父组件的 componentDidMount 
  在其子组件的 componentDidMount 之后调用。 
+ ![1552095217518](F:\OneDrive\JS\纲略合集\assets\1552095217518.png) 
+ mountComponent  的 代 码 如 下 （ 源 码 路 径 ： /v15.0.0/src/renderers/shared/reconciler/React- 
  CompositeComponent.js）： 

#### 阶段二：RECEIVE_PROPS

+ updateComponent  负责管理生命周期中的   componentWillReceiveProps 、 shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate。 
+ 首先通过 updateComponent 更新组件，如果前后元素不一致，说明需要进行组件更新。 
+ 若存在 componentWillReceiveProps，则执行。
  + 如果此时在 componentWillReceiveProps 中调用setState，是不会触发 re-render 的，而是会**进行 state 合并**。
  + 且在 componentWillReceiveProps、shouldComponentUpdate 和 componentWillUpdate 中也还是**无法获取到更新后的 this.state**，即此时访问的 this.state 仍然是未更新的数据，需要设置 **inst.state = nextState** 后才可以，因此只有在 render 和 componentDidUpdate 中才能获取到更新后的 this.state。 

+ 调用 shouldComponentUpdate 判断是否需要进行组件更新，如果存在 componentWillUpdate，则执行。 

+ updateComponent  本质上也是通过**递归渲染**内容的，由于递归的特性，父组件的  componentWillUpdate 是在其子组件的  componentWillUpdate 之前调用的，而父组件的  componentDidUpdate 也是在其子组件的 componentDidUpdate 之后调用的。 
+ 当渲染完成之后，若存在 componentDidUpdate，则触发，这就解释了 componentWillReceiveProps、componentWillUpdate、 render、componentDidUpdate 它们之间的执行顺序。

**注意：** 

+ 禁止在 shouldComponentUpdate 和 componentWillUpdate 中**调用 setState**，这会造成循环调用，直至耗光浏览器内存后崩溃。 
+ ![1552095743537](F:\OneDrive\JS\纲略合集\assets\1552095743537.png) 
+ updateComponent 相关源码如下： 

#### 阶段三：UNMOUNTING

+ unmountComponent 负责管理生命周期中的 componentWillUnmount。 
+ 如果存在 componentWillUnmount，则执行并重置所有相关参数、更新队列以及更新状态，如果此时在 componentWillUnmount 中**调用 setState，是不会触发 re-render 的**，这是因为所有更新队列和更新状态都被重置为 null，并清除了公共类，完成了组件卸载操作。unmountComponent 的代码如下： 



+ 至此，我们跟随着 React 源码的脚步完整地了解其生命周期的执行过程，你是否已经对 React 生命周期有了更深刻的理解了呢？ 
+ 生命周期和 state 状态让 React 组件无比灵活与强大，同时也使得组件变得复杂而难以维护。
+ 在实际的项目开发中，我们经常需要编写一些**自身没有状态，只是从父组件接受  props，并根据这些属性进行渲染的简单组件**，这不仅让组件的开发变得简单、高效，也便于对状态进行统一管理。因此，在 React 开发中，一个很重要的原则就是**让组件尽可能是无状态**的。 
+ 当然，React 官方也是鼓励这一原则的。在 React 0.14 之后，便推出了无状态组件，大大增强了 React 组件编写的便捷性，也提升了整体的渲染性能。 
  + hooks进一步加强了无状态组件？

### 无状态组件

+ 我们在 1.3 节中提到过无状态组件。无状态组件只是一个 render 方法，并没有组件类的实例化过程，也没有实例返回。比如： 

  ```react
  const HelloWorld = (props) => <div>{props.name}</div>; 
  ReactDOM.render(<HelloWorld name="Hello World!" />, App); 
  ```

+ render 函数和 shouldConstruct 函数的代码如下（源码路径：/v15.0.0/src/renderers/shared/re- 
  conciler/ReactCompositeComponent.js）： 

  ```js
  // 无状态组件只有一个 render 函数 
  StatelessComponent.prototype.render = function() { 
   var Component = ReactInstanceMap.get(this)._currentElement.type; 
    // 没有 state 状态 
   var element = Component(this.props, this.context, this.updater); 
    warnIfInvalidElement(Component, element); 
   return element; 
  }; 
  function shouldConstruct(Component) { 
   return Component.prototype && Component.prototype.isReactComponent; 
  } 
  ```

+ 无状态组件没有状态，没有生命周期，只是简单地接受 props 渲染生成 DOM 结构，是一个纯粹为渲染而生的组件。由于无状态组件有简单、便捷、高效等诸多优点，所以如果可能的话，请**尽量使用无状态组件**。

+ 最后用一张图再次归纳一下生命周期，如图 3-13 所示。

+ ![1552096164808](F:\OneDrive\JS\纲略合集\assets\1552096164808.png) 

## 解密 setState 机制 

+ state 是 React 中重要的概念。第 1 章中提到过，React 是通过管理状态来实现对组件的管理。那么，React 是如何控制组件的状态的，又是如何利用状态来管理组件的呢？ 
+ 众所周知，React 通过 this.state 来访问 state，通过 this.setState() 方法来更新 state。**当this.setState() 被调用的时候，React 会重新调用 render 方法来重新渲染 UI。** 
+ 想必  setState  已经是我们再熟悉不过的  API，然而你真的了解它吗？本节将为我们解密 setState 的更新机制。 

### setState 异步更新

+ React 初学者常会写出 this.state.value = 1 这样的代码，这是完全错误的写法。 绝对不要直接修改 this.state，这不仅是一种低效的做法，而且很有可能会被之后的操作替换。 

+ setState 通过一个**队列机制**实现 state 更新。当执行 setState 时，会将需要更新的 state 合并后放入状态队列，而不会立刻更新 this.state，队列机制可以高效地批量更新 state。如果不通过 setState  而直接修改  this.state  的值，那么该  state  将**不会被放入状态队列**中，当下次调用 setState 并对状态队列进行合并时，将会忽略之前直接被修改的 state，而造成无法预知的错误。

+ 因此，应该使用 setState 方法来更新 state，同时 React 也正是利用状态队列机制实现了 setState 的异步更新，避免频繁地重复更新 state。相关代码如下：

  ```js
  // 将新的 state 合并到状态更新队列中 
  var nextState = this._processPendingState(nextProps, nextContext); 
  // 根据更新队列和 shouldComponentUpdate 的状态来判断是否需要更新组件 
  var shouldUpdate = 
   this._pendingForceUpdate || 
   !inst.shouldComponentUpdate || 
    inst.shouldComponentUpdate(nextProps, nextState, nextContext); 
  ```

### setState 循环调用风险

+ 当调用 setState 时，实际上会执行 enqueueSetState 方法，并对 partialState 以及_pendingStateQueue 更新队列进行合并操作，最终通过 enqueueUpdate 执行 state 更新。 
+ 而 performUpdateIfNecessary 方法会获取 \_pendingElement、\_pendingStateQueue、\_pending- 
  ForceUpdate，并**调用 receiveComponent 和 updateComponent 方法进行组件更新**。 
  如果在shouldComponentUpdate  或   componentWillUpdate  方 法 中 调 用   setState ， 此 时 
  this._pendingStateQueue != null，则 performUpdateIfNecessary 方法就会调用 updateComponent 
  方法进行组件更新，但 updateComponent 方法又会调用 shouldComponentUpdate 和 componentWill- 
  Update 方法，因此造成循环调用，使得浏览器内存占满后崩溃，如图 3-14 所示。 
+ ![1552097490884](F:\OneDrive\JS\纲略合集\assets\1552097490884.png) 
+ 接着我们来看 setState 的源码： 

### setState 调用栈 

+ 既然 setState 最终是通过 enqueueUpdate 执行 state 更新，那么 enqueueUpdate 到底是如何更新 state 的呢？ 

+ 首先，看看下面这个问题，你是否能够正确回答呢？ 

  ```js
  import React, { Component } from 'react'; 
  class Example extends Component { 
    constructor() { 
      super(); 
      this.state = { 
        val: 0 
      }; 
    } 
    componentDidMount() { 
      this.setState({val: this.state.val + 1}); 
      console.log(this.state.val);   // 第 1 次输出
      this.setState({val: this.state.val + 1}); 
      console.log(this.state.val);   // 第 2 次输出
      setTimeout(() => { 
        this.setState({val: this.state.val + 1}); 
        console.log(this.state.val);  // 第 3 次输出
        this.setState({val: this.state.val + 1}); 
        console.log(this.state.val);  // 第 4 次输出
      }, 0); 
    } 
    render() { 
      return null; 
    } 
  } 
  ```

+ 上述代码中， 4 次 console.log 打印出来的 val 分别是：0、0、2、3。

+ 假如结果与你心中的答案不完全相同，那么你应该会感兴趣 enqueueUpdate 到底做了什么？ 图 3-15 是一个简化的 setState 调用栈，注意其中核心的状态判断。 

+ ![1552097674801](F:\OneDrive\JS\纲略合集\assets\1552097674801.png) 

+ enqueueUpdate 的代码如下（源码路径：/v15.0.0/src/ renderers/shared/reconciler/ReactUpdates. 
  js）： 

  ```js
  function enqueueUpdate(component) { 
    ensureInjected(); 
    // 如果不处于批量更新模式 
   if (!batchingStrategy.isBatchingUpdates) { 
     batchingStrategy.batchedUpdates(enqueueUpdate, component); 
     return; 
    } 
    // 如果处于批量更新模式，则将该组件保存在 dirtyComponents 中 
    dirtyComponents.push(component); 
  } 
  ```

+ 如果 isBatchingUpdates 为 true，则对所有队列中的更新执行 batchedUpdates 方法，否则只把当前组件（即调用了 setState 的组件）放入 dirtyComponents 数组中。例子中 4 次 setState 调用的表现之所以不同，这里逻辑判断起了关键作用。 

+ 那么  batchingStrategy  究竟做什么呢？其实它只是一个简单的对象，定义了一个 isBatchingUpdates 的布尔值，以及 batchedUpdates 方法（源码路径：/v15.0.0/src/renderers/shared/ reconciler/React Default Batching Strategy.js）：

+ ```js
  var ReactDefaultBatchingStrategy = { 
   isBatchingUpdates: false, 
    batchedUpdates: function(callback, a, b, c, d, e) { 
     var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates; 
     ReactDefaultBatchingStrategy.isBatchingUpdates = true; 
   if (alreadyBatchingUpdates) { 
    callback(a, b, c, d, e); 
     } else { 
    transaction.perform(callback, null, a, b, c, d, e); 
     } 
    }, 
  } 
  ```

+ 值得注意的是， batchedUpdates 方法中有一个 transaction.perform 调用，这是本章后续要介绍的核心概念——事务（transaction）。 

### 初识事务 

+ 事务源码中有一幅图，形象地解释了它的作用，如图 3-16 所示（本节的源码路径：/v15.0.0/ src/shared/utils/Transaction.js）

+ ![1552097920922](F:\OneDrive\JS\纲略合集\assets\1552097920922.png) 

+ 事务就是将需要执行的方法使用 wrapper 封装起来，再通过事务提供的 perform 方法执行。而在 perform 之前，先执行所有 wrapper 中的 initialize 方法，执行完 perform 之后（即执行 method 方法后）再执行所有的 close 方法。一组 initialize 及 close 方法称为一个 wrapper。从图3-16中可以看出，事务支持多个 wrapper 叠加。 

+ 到实现上，事务提供了一个 mixin 方法供其他模块实现自己需要的事务。而要使用事务的模块，除了需要把  mixin  混入自己的事务实现中外，还要额外实现一个抽象的  getTransaction-Wrappers 接口。这个接口用来获取所有需要封装的前置方法（initialize）和收尾方法（close），因此它需要返回一个数组的对象，每个对象分别有 **key** 为 initialize 和 close 的方法。 

+ 下面是一个简单使用事务的例子：

  ```js
  var Transaction = require('./Transaction'); 
  // 我们自己定义的事务 
  var MyTransaction = function() { 
    // ... 
  }; 
  Object.assign(MyTransaction.prototype, Transaction.Mixin, { 
    getTransactionWrappers: function() { 
      return [{ 
        initialize: function() { 
          console.log('before method perform'); 
        }, 
        close: function() { 
          console.log('after method perform'); 
        } 
      }]; 
    }; 
  }); 
  var transaction = new MyTransaction(); 
  var testMethod = function() { 
    console.log('test'); 
  } 
  transaction.perform(testMethod); 
  // 打印的结果如下： 
  // before method perform 
  // test 
  // after method perform 
  
  ```

+ 当然，在 React 中还做了异常处理等工作，这里就不详细展开了。如果你有兴趣，可以继续翻看源码。 

### 解密 setState 

+ 说了这么多，事务到底是怎么导致前面所述的 setState 的各种不同表现的呢？ 

+ 这里我们先要了解事务跟 setState 的不同表现有什么关系。首先，我们把4次 setState 简单归类，前两次属于一类，因为它们在**同一次调用栈**中执行，setTimeout 中的两次 setState 属于另一类，原因同上。下面我们分别看看这两类 setState 的调用栈，如图 3-17 和图 3-18 所示。

+ ![1552098215163](F:\OneDrive\JS\纲略合集\assets\1552098215163.png) 

+ 很明显，在  componentDidMount  中直接调用的两次  setState，其调用栈更加复杂；而setTimeout 中调用的两次 setState，其调用栈则简单很多。下面重点看看第一类 setState 的调用栈，有没有发现什么？没错，就是 **batchedUpdates** 方法，原来早在 setState 调用前，已经处于 batchedUpdates 执行的事务中了。

+   那这次 batchedUpdate 方法，又是谁调用的呢？让我们往前再追溯一层，原来是 React Mount.js中的 _renderNewRootComponent 方法。也就是说，**整个将 React 组件渲染到 DOM 中的过程就处于一个大的事务中。** 

+ 接下来的解释就顺理成章了，因为在 componentDidMount 中调用 set State 时，batching Strategy的 is Batching Updates 已经**被设为 true**，所以两次 set State 的结果并没有立即生效，而是被放进了 dirtyComponents 中。这也解释了两次打印 this.state.val 都是 0 的原因，因为新的 state 还没有被应用到组件中。

+ 再 反 观 setTimeout中的两 次 setState ， **因为没有前置的 batchedUpdate 调用** ，所以batchingStrategy 的 isBatchingUpdates **标志位是 false**，也就导致了新的 state 马上生效，没有走到 dirtyComponents 分支。也就是说，setTimeout 中第一次执行 setState 时，this.state.val为 1，而 setState 完成后打印时this.state.val 变成了 2。第二次的 setState 同理。

+ 前面介绍事务时，也提到了其在 React 源码中的多处应用，像 initialize、perform、close、closeAll、notifyAll 等方法出现在调用栈中，都**说明当前处于一个事务中**。  

+ 既然事务这么有用，我们写应用代码时能使用它吗？很可惜，答案是不能。尽管 React 不建议我们直接使用事务，但在 React 15.0 之前的版本中还是为开发者提供了 batchedUpdates 方法，它可以解决针对一开始例子中 setTimeout 里的两次 setState 导致两次 render 的情况： 

  ```react
  import ReactDOM, { unstable_batchedUpdates } from 'react-dom'; 
  unstable_batchedUpdates(() => { 
   this.setState(val: this.state.val + 1); 
    this.setState(val: this.state.val + 1); 
  }); 
  ```

+ 在 React 15.0 以及之后版本中，已经彻底将 batchedUpdates 这个 API 移除了，因此不再建议开发者使用它。

## diff 算法 

+ diff 作为 Virtual DOM 的加速器，其算法上的改进优化是 React 整个界面渲染的基础和性能保障，同时也是 React 源码中最神秘、最不可思议的部分。本节依然从源码入手，深入剖析 diff 的不可思议之处。
+ React  中最值得称道的部分莫过于  Virtual  DOM  模型与  diff  的完美结合，特别是其高效的 diff 算法，可以让用户无需顾忌性能问题而“任性自由”地刷新页面，让开发者也可以无需关心 Virtual DOM 背后的运作原理。因为 diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行原生  DOM  操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。因此，Virtual DOM 模型与 diff 是保证 React 性能口碑的幕后推手。 
+ diff 算法也并非其首创。正是因为该算法的普适度高，就更应该认可 React 针对 diff 算法优化所做的努力与贡献，这更能体现 React 创作者们的魅力与智慧！

### 传统 diff 算法 

+ 计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法①通过**循环递归对节点进行依次对比**，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕呢？这意味着如果要展示 1000 个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了。如今的 CPU 每秒钟能执行大约 30 亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。
+ 因此，如果 React 只是单纯地引入 diff 算法而没有任何的优化改进，那么其效率远远无法满足前端渲染所要求的性能。如果想要将 diff 思想引入 Virtual DOM，就要设计一种稳定、高效的 diff 算法，这个 React 做到了！ 
+ 那么，diff 到底是如何实现的呢？  

### 详解 diff

+ React 将 Virtual DOM 树转换成 actual DOM 树的最少操作的过程称为调和（reconciliation）。diff 算法便是调和的具体实现。那么这个过程是怎么实现的呢？ 
+ React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。 

#### diff 策略

+ 策略一：Web UI 中 DOM 节点**跨层级的移动操作**特别少，可以忽略不计。
+ 策略二：拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
+ 策略三：对于同一层级的一组子节点，它们可以通过**唯一 id** 进行区分。
+ 基于以上策略，React 分别对 **tree diff、component diff 以及 element diff** 进行算法优化。事实也证明这 3 个前提策略是合理且准确的，它保证了整体界面构建的性能。 

### tree diff

+ 基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。 

+ 既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 **updateDepth** 对 Virtual DOM 树进行层级控制，只会对相同层级的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在时，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。 

+ updateChildren 方法对应的源码如下： 

  ```js
  updateChildren: function(nextNestedChildrenElements, transaction, context) { 
    updateDepth++; 
    var errorThrown = true; 
    try { 
      this._updateChildren(nextNestedChildrenElements, transaction, context); 
      errorThrown = false; 
    } finally { 
      updateDepth--; 
      if (!updateDepth) { 
        if (errorThrown) { 
          clearQueue(); 
        } else { 
          processQueue(); 
        } 
      } 
    } 
  } 
  
  ```

+ 你可能存在这样的疑问：如果出现了 DOM 节点跨层级的移动操作，diff 会有怎样的表现呢？我们不妨试验一番。

+ 如图 3-19 所示，A 节点（包括其子节点）整个被移动到 D 节点下，由于 React 只会简单地考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A（包括子节点）作为其子节点。此时，diff 的执行情况：create A → create B → create C → delete A。 

+ ![1552100686543](F:\OneDrive\JS\纲略合集\assets\1552100686543.png) 

+ 由此可以发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的整个树被**重新创建**。这是一种**影响 React 性能**的操作，因此官方建议不要进行 DOM 节点跨层级的操作。 

+ 在开发组件时，**保持稳定的 DOM 结构**会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真正地移除或添加 DOM 节点。 

### component diff

+ React 是基于组件构建应用的，对于组件间的比较所采取的策略也是非常简洁、高效的。 
  + 如果是**同一类型**的组件，按照原策略继续比较 Virtual DOM 树即可。
  + 如果不是，则将该组件判断为 **dirty component**，从而替换整个组件下的所有子节点。
  + 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切知道这点，那么就可以节省大量的 diff 运算时间。因此，React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff 算法分析。
+ 如图 3-20 所示，当组件 D 变为组件 G 时，即使这两个组件结构相似，**一旦 React 判断 D 和 G 是不同类型的组件**，就不会比较二者的结构，而是直接删除组件 D，重新创建组件 G 及其子节点。
  + ![1552100923471](F:\OneDrive\JS\纲略合集\assets\1552100923471.png) 
+ 虽然当两个组件是**不同类型但结构相似**时，diff 会影响性能，但正如 React 官方博客所言：不同类型的组件很少存在相似 DOM 树的情况，因此这种极端因素很难在实际开发过程中造成重大的影响。 

### element diff

+ 当节点处于同一层级时，diff  提供了  3  种节点操作，分别为  I**NSERT_MARKUP（插入）、MOVE_**
  **EXISTING（移动）和 REMOVE_NODE（删除）**。 

  + **INSERT_MARKUP**：新的组件类型不在旧集合里，即全新的节点，需要对新节点执行插入操作。 
  + **MOVE_EXISTING**：旧集合中有新**组件类型**，且 element 是可更新的类型，generateComponent-
    Children 已调用  receiveComponent，这种情况下  prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。
  + **REMOVE_NODE**：旧组件类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者旧组件不在新集合里的，也需要执行删除操作。

+ 相关代码如下： 

  ```js
  function makeInsertMarkup(markup, afterNode, toIndex) { 
    return { 
      type: ReactMultiChildUpdateTypes.INSERT_MARKUP, 
      content: markup, 
      fromIndex: null, 
      fromNode: null, 
      toIndex: toIndex, 
      afterNode: afterNode, 
    }; 
  } 
  function makeMove(child, afterNode, toIndex) { 
    return { 
      type: ReactMultiChildUpdateTypes.MOVE_EXISTING, 
      content: null, 
      fromIndex: child._mountIndex, 
      fromNode: ReactReconciler.getNativeNode(child), 
      toIndex: toIndex, 
      afterNode: afterNode, 
    }; 
  } 
  function makeRemove(child, node) { 
    return { 
      type: ReactMultiChildUpdateTypes.REMOVE_NODE, 
      content: null, 
      fromIndex: child._mountIndex, 
      fromNode: node, 
      toIndex: null, 
      afterNode: null, 
    }; 
  } 
  
  ```

+ 如图 3-21 所示，旧集合中包含节点A、B、C 和 D，更新后的新集合中包含节点 B、A、D 和 C，此时新旧集合进行 diff 差异化对比，发现 B != A，则创建并插入 B 至新集合，删除旧集合 A；以此类推，创建并插入 A、D 和 C，删除 B、C 和 D。 

+ ![1552106297406](F:\OneDrive\JS\纲略合集\assets\1552106297406.png) 

+ React  发现这类操作烦琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行**位置移动**即可。 

+ 针对这一现象，React 提出优化策略：允许开发者对**同一层级的同组子节点，添加唯一 key 进行区分**，虽然只是小小的改动，性能上却发生了翻天覆地的变化！ 

+ 新旧集合所包含的节点如图 3-22 所示，进行 diff 差异化对比后，**通过 key 发现新旧集合中的节点都是相同的节点**，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作即可。 

  + 因此，如果key是普通的index则没有意义，还是会全部进行更新

+ 那么，如此高效的 diff 到底是如何运作的呢？让我们通过源码详细分析一下。 

+ 首先，对新集合中的节点进行循环遍历 for (name in nextChildren)，通过唯一的 key 判断新旧集合中是否存在相同的节点 if (prevChild === nextChild)

  + 如果存在相同节点，则进行移动操作，但在移动前需要将**当前节点在旧集合中的位置**与  lastIndex 进行比较  if (child.\_mountIndex < lastIndex)，否则不执行该操作。
  + 这是一种顺序优化手段，lastIndex 一直在更新，表示访问过的节点在旧集合中最右的位置（即**最大的位置**）。如果新集合中当前访问的节点比 lastIndex 大，说明当前访问节点在旧集合中就比上一个节点位置靠后，则**该节点不会影响其他节点的位置**，因此不用添加到差异队列中，即不执行移动操作。只有当访问的节点比 lastIndex 小时，才需要进行移动操作。 

**例子一：新旧集合中存在相同节点但位置不同时**

+ 以图 3-22 为例，下面更为清晰直观地描述 diff 的差异化对比过程。 
+ 从新集合中取得 B：
  + 然后判断旧集合中是否存在相同节点 B，此时发现存在节点 B
  + 接着通过对比节点位置**判断是否进行移动操作**。
    + B 在旧集合中的位置 B.\\_mountIndex = 1，此时 lastIndex = 0，不满足 child.\\_mountIndex < lastIndex 的条件，因此**不对 B 进行移动操作**。
  + 更新 lastIndex = Math.max(prevChild.\\_mountIndex, lastIndex)，其中 prevChild.\_ mountIndex 表示B**在旧集合中的位置**，则lastIndex = 1，
  + 并将B的位置更新为新集合中的位置 prevChild.\\_mountIndex = nextIndex，此时新集合中 B.\_mountIndex = 0，
  + nextIndex++ 进入下一个节点的判断。 
+ 从新集合中取得 A：
  + 然后判断旧集合中是否存在相同节点 A，此时发现存在节点 A
  + 接着通过对比节点位置判断是否进行移动操作。
    + A 在旧集合中的位置 A.\\_mountIndex = 0，此时 lastIndex = 1，满足 child.\\_mountIndex < lastIndex 的条件，因此对 A 进行移动操作enqueueMove(this, child.\\_mountIndex, toIndex)，其中 toIndex 其实就是 nextIndex，表示 A 需要移动到的位置。
  + 更新 lastIndex = Math.max(prevChild.\\_mountIndex, lastIndex)，则lastIndex = 1
  + 并将  A  的位置更新为新集合中的位置  prevChild.\\_mountIndex =nextIndex，此时新集合中 A.\\_mountIndex = 1，
  + nextIndex++ 进入下一个节点的判断。
+ 从新集合中取得 D：
  + 然后判断旧集合中是否存在相同节点 D，此时发现存在节点 D
  + 接着通过对比节点位置判断是否进行移动操作。
    + D 在旧集合中的位置 D.\_mountIndex = 3，此时 lastIndex = 1，不满足 child.\_mountIndex < lastIndex 的条件，因此不对 D 进行移动操作。
  + 更新 lastIndex = Math.max(prevChild.\_mountIndex, lastIndex)，则 lastIndex =3
  + 并将 D 的位置更新为新集合中的位置 prevChild.\_mountIndex = nextIndex，此时新集合中 D.\_mountIndex = 2
  + nextIndex++ 进入下一个节点的判断。
+ 从新集合中取得 C：
  + 然后判断旧集合中是否存在相同节点 C，此时发现存在节点 C
  + 接着通过对比节点位置判断是否进行移动操作。
    + C 在旧集合中的位置 C.\_mountIndex = 2，此时 lastIndex = 3，满足 child.\_mountIndex < lastIndex的条件，因此对 C 进行移动操作enqueueMove(this, child.\_mountIndex, toIndex)。
  + 更新lastIndex = Math.max(prevChild.\_mountIndex, lastIndex)，则  lastIndex = 3
  + 并将  C  的位置更新为新集合中的位置prevChild.\_mountIndex = nextIndex，此时新集合中 A.\_mountIndex = 3，
  + nextIndex++ 进入下一个节点的判断。
+ 由于C 已经是最后一个节点，因此 diff 操作到此完成。

**例子二：新集合中有新加入的节点且旧集合存在需要删除的节点**

+ 上面主要分析新旧集合中存在相同节点但位置不同时，对节点进行位置移动的情况。如果新集合中有新加入的节点且旧集合存在需要删除的节点，那么 diff 又是如何对比运作的呢？ 
+ 下面以图 3-23 为例进行介绍
+ ![1552111535055](F:\OneDrive\JS\纲略合集\assets\1552111535055.png) 
+ 从新集合中取得B：
  + 然后判断旧集合中存在是否相同节点 B，可以发现存在节点 B。
  + 由于B 在旧集合中的位置 B.\_mountIndex = 1，此时 lastIndex = 0，因此不对 B 进行移动操作。
  + 更新lastIndex = 1，并将 B 的位置更新为新集合中的位置 B.\_mountIndex = 0，nextIndex++，进入下一个节点的判断。
+ 从新集合中取得 E：
  + 然后判断旧集合中是否存在相同节点 E，可以**发现不存在**，此时可以创建新节点 E。
  + 更新 lastIndex = 1，并将 E 的位置更新为新集合中的位置，nextIndex++，进入下一个节点的判断。
+ 从新集合中取得 C：
  + 然后判断旧集合中是否存在相同节点 C，此时可以发现存在节点 C。
  + 由于  C  在旧集合中的位置  C.\_mountIndex = 2，lastIndex = 1，此时  C.\_mountIndex >lastIndex，因此不对 C 进行移动操作。
  + 更新 lastIndex = 2，并将 C 的位置更新为新集合中的位置，nextIndex++，进入下一个节点的判断。
+ 从新集合中取得 A：
  + 然后判断旧集合中是否存在相同节点 A，此时发现存在节点 A。
  + 由于A 在旧集合中的位置 A.\_mountIndex = 0，lastIndex = 2，此时 A.\_mountIndex < lastIndex，
    因此对 A 进行移动操作。
  + 更新 lastIndex = 2，并将 A 的位置更新为新集合中的位置，nextIndex++，进入下一个节点的判断。
+ 当完成新集合中所有节点的**差异化对比**后，还需要对旧集合进行循环遍历，判断是否存在新集合中没有但旧集合中仍存在的节点，此时发现存在这样的节点 D，因此删除节点 D，
+ 到此 diff 操作全部完成。
+ 相关代码如下（源码路径：/v15.0.0/src/renderers/shared/reconciler/ReactMultiChild.js）： 

**例子三：**

+ 当然，diff 还存在些许不足与待优化的地方。如图 3-24 所示，若新集合的节点更新为 D、A、B、C，与旧集合相比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 执行移动操作，然而由于 D 在旧集合中的位置是最大的，导致其他节点的 _mountIndex <lastIndex，造成 D 没有执行移动操作，而是 A、B、C 全部移动到 D 节点后面的现象。 
+ ![1552111820453](F:\OneDrive\JS\纲略合集\assets\1552111820453.png) 
+ 在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作。当节点数量过大或更新操作过于频繁时，这在一定程度上会影响 React 的渲染性能。 

## React Patch 方法 

+ 通过前面的内容，我们了解了 React 如何构建虚拟标签，执行组件生命周期，更新 state，计算 tree diff 等，这一系列操作都还是在 Virtual DOM 中进行的。
+ 然而**浏览器**中并未能显示出更新的数据，那么 React 又是如何让浏览器展示出最新的数据呢？ 
+ React Patch 实现了关键的最后一步。所谓 Patch，简而言之就是将 tree diff 计算出来的 DOM **差异队列**更新到真实的 DOM 节点上，最终让浏览器能够渲染出更新的数据。
+ 可以这么说，如果没有 Patch，那么 React 之前基于 Virtual DOM 做再多性能优化的操作都是徒劳，因为浏览器并不认识 Virtual DOM。
+ 虽然 Patch 方法如此重要，但它的实现却非常简洁明了，主要是通过遍历差异队列实现的。遍历差异队列时，通过**更新类型**进行相应的操作，包括：新节点的插入、已有节点的移动和移除等。 

+ 这里为什么可以**直接依次插入节点**呢？原因就是在 diff 阶段添加差异节点到差异队列时，本身就是有序添加。也就是说，新增节点（包括 move 和 insert）在队列里的顺序就是最终真实 DOM 的顺序，因此可以直接依次根据 index 去插入节点。而且，React 并不是计算出一个差异就去执行一次  Patch，而是计算出全部差异并放入差异队列后，再一次性地去执行  Patch 方法完成真实 DOM 的更新。 
+ Patch 方 法 的 源 码 如 下 （ 源 码 路 径 ： /v15.0.0/src/renderers/dom/client/utils/DOMChildren- Operations.js）： 

## 小结

+ 除了本章分析的核心方法，React 还有许多优秀的实现，比如对象生成时内存的线程池管理、事件系统的优化、服务端的渲染等。在本章写作的过程中，React 15.0 版本又进行了几次小版本的更新，还发表了多年的研究成果 React Fiber，希望读者自行阅读源码分析其实现原理。 