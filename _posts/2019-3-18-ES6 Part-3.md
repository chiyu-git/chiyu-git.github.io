---
layout: post
#标题配置
title:  ES6 Note Part-3
#时间配置
date:   2019-3-18 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note front-end
---

* content
{:toc}


# 23.Class的基本语法

## 简介

### 类的由来

- JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。

  ```javascript
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }
  
  Point.prototype.toString = function () {
    return '(' + this.x + ', ' + this.y + ')';
  };
  
  var p = new Point(1, 2);
  ```

- 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。

- ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过**`class`关键字**，可以定义类。

- 基本上，ES6 的`class`可以看作只是一个**语法糖**，它的绝大部分功能，ES5 都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的`class`改写，就是下面这样。

  ```javascript
  class Point { // 仅定义类名
    constructor(x, y) { // 构造函数
      this.x = x;
      this.y = y;
    }
  
    toString() { // 定义类的方法
      return '(' + this.x + ', ' + this.y + ')';
    }
  }
  ```

- `Point`类除了构造方法，还定义了一个`toString`方法。注意，定义“类”的方法的时候，前面不需要加上`function`这个关键字，直接把函数定义放进去了就可以了。**另外，方法之间不需要逗号分隔，加了会报错。**

- ES6 的类，完全可以看作构造函数的另一种写法。

  ```javascript
  class Point {
    // ...
  }
  
  typeof Point // "function"
  Point === Point.prototype.constructor // true
  ```

- 上面代码表明，**类的数据类型就是函数，类本身就指向构造函数**。

- 使用的时候，也是直接对类使用`new`命令，跟构造函数的用法完全一致。

  ```javascript
  class Bar {
    doStuff() {
      console.log('stuff');
    }
  }
  
  var b = new Bar();
  b.doStuff() // "stuff"
  ```

- 构造函数的`prototype`属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的`prototype`属性上面。

  ```javascript
  class Point {
    constructor() {
      // ...
    }
  
    toString() {
      // ...
    }
  
    toValue() {
      // ...
    }
  }
  
  // 等同于
  
  Point.prototype = {
    constructor() {},
    toString() {},
    toValue() {},
  };
  ```

- 在类的实例上面调用方法，其实就是调用原型上的方法。

- ```javascript
  class B {}
  let b = new B();
  
  b.constructor === B.prototype.constructor // true
  ```

- 上面代码中，`b`是`B`类的实例，它的`constructor`方法就是`B`类原型的`constructor`方法。

- 由于类的方法都定义在`prototype`对象上面，所以类的**新方法可以添加**在`prototype`对象上面。`Object.assign`方法可以很方便地一次向类添加多个方法。

  ```javascript
  class Point {
    constructor(){
      // ...
    }
  }
  
  Object.assign(Point.prototype, {
    toString(){},
    toValue(){}
  });
  ```

- `prototype`对象的`constructor`属性，直接指向“类”的本身，这与 ES5 的行为是一致的。

- ```js
  Point.prototype.constructor === Point // true
  ```

- 另外，类的内部所有定义的方法，**都是不可枚举的（non-enumerable）**。

  ```javascript
  class Point {
    constructor(x, y) {
      // ...
    }
  
    toString() {
      // ...
    }
  }
  
  Object.keys(Point.prototype)
  // []
  Object.getOwnPropertyNames(Point.prototype)
  // ["constructor","toString"]
  ```

- 上面代码中，`toString`方法是`Point`类内部定义的方法，它是不可枚举的。**这一点与 ES5 的行为不一致**。

  ```javascript
  var Point = function (x, y) {
    // ...
  };
  
  Point.prototype.toString = function() {
    // ...
  };
  
  Object.keys(Point.prototype)
  // ["toString"]
  Object.getOwnPropertyNames(Point.prototype)
  // ["constructor","toString"]
  ```

- 上面代码采用 ES5 的写法，`toString`方法就是可枚举的。

### constructor 方法 

- `constructor`方法是类的默认方法，**通过`new`命令生成对象实例时，自动调用该方法。**一个类必须有`constructor`方法，**如果没有显式定义，一个空的`constructor`方法会被默认添加。**

  ```javascript
  class Point {
  }
  
  // 等同于
  class Point {
    constructor() {}
  }
  ```

- 上面代码中，定义了一个空的类`Point`，JavaScript 引擎会自动为它添加一个空的`constructor`方法。

- `constructor`方法**默认返回实例对象（即`this`）**，完全**可以指定返回另外一个对象**。

  ```javascript
  class Foo {
    constructor() {
      return Object.create(null);
    }
  }
  
  new Foo() instanceof Foo
  // false
  ```

- **上面代码中，`constructor`函数返回一个全新的对象，结果导致实例对象不是`Foo`类的实例。**

- **类必须使用`new`调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用`new`也可以执行。**

  ```javascript
  class Foo {
    constructor() {
      return Object.create(null);
    }
  }
  
  Foo()
  // TypeError: Class constructor Foo cannot be invoked without 'new'
  ```

### 类的实例

- 生成类的实例的写法，与 ES5 完全一样，也是使用`new`命令。前面说过，如果忘记加上`new`，像函数那样调用`Class`，将会报错。

  ```javascript
  class Point {
    // ...
  }
  
  // 报错
  var point = Point(2, 3);
  
  // 正确
  var point = new Point(2, 3);
  ```

- 与 ES5 一样，**实例的属性除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。**

- ```javascript
  //定义类
  class Point {
  
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
  
    toString() {
      return '(' + this.x + ', ' + this.y + ')';
    }
  
  }
  
  var point = new Point(2, 3);
  
  point.toString() // (2, 3)
  
  point.hasOwnProperty('x') // true
  point.hasOwnProperty('y') // true
  point.hasOwnProperty('toString') // false
  point.__proto__.hasOwnProperty('toString') // true
  ```

- 上面代码中，`x`和`y`都是实例对象`point`自身的属性（因为定义在`this`变量上），所以`hasOwnProperty`方法返回`true`，而`toString`是原型对象的属性（因为定义在`Point`类上），所以`hasOwnProperty`方法返回`false`。这些都与 ES5 的行为保持一致。

- 与 ES5 一样，**类的所有实例共享一个原型对象。**

  ```javascript
  var p1 = new Point(2,3);
  var p2 = new Point(3,2);
  
  p1.__proto__ === p2.__proto__
  //true
  ```

- 上面代码中，`p1`和`p2`都是`Point`的实例，它们的原型都是`Point.prototype`，所以`__proto__`属性是相等的。

- 这也意味着，**可以通过实例的`__proto__`属性为“类”添加方法。**

  > `__proto__` 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 `Object.getPrototypeOf` 方法来获取实例对象的原型，然后再来为原型添加方法/属性。

- ```javascript
  var p1 = new Point(2,3);
  var p2 = new Point(3,2);
  
  p1.__proto__.printName = function () { return 'Oops' };
  
  p1.printName() // "Oops"
  p2.printName() // "Oops"
  
  var p3 = new Point(4,2);
  p3.printName() // "Oops
  ```

- 上面代码在`p1`的原型上添加了一个`printName`方法，由于`p1`的原型就是`p2`的原型，因此`p2`也可以调用这个方法。而且，此后新建的实例`p3`也可以调用这个方法。这意味着，使用实例的`__proto__`属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。

### 取值函数（getter）和存值函数（setter）

- 与 ES5 一样，**在“类”的内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。**

- 定义的属性没有this关键字，但还是给到了实例对象？或者是通过原型链调用的？其实是通过原型链调用的

  ```javascript
  class MyClass {
    constructor() {
      // ...
    }
    get prop() {
      return 'getter';
    }
    set prop(value) {
      console.log('setter: '+value);
    }
  }
  
  let inst = new MyClass();
  
  inst.prop = 123;
  // setter: 123
  
  inst.prop
  // 'getter'
  ```

- 上面代码中，`prop`属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。

- **存值函数和取值函数是设置在属性的 Descriptor 对象上的。**

  ```javascript
  class CustomHTMLElement {
    constructor(element) {
      this.element = element;
    }
  
    get html() {
      return this.element.innerHTML;
    }
  
    set html(value) {
      this.element.innerHTML = value;
    }
  }
  
  var descriptor = Object.getOwnPropertyDescriptor(
    CustomHTMLElement.prototype, "html"
  );
  
  "get" in descriptor  // true
  "set" in descriptor  // true
  ```

- 上面代码中，存值函数和取值函数是定义在`html`属性的描述对象上面，这与 ES5 完全一致。

### 属性表达式

- 类的属性名，可以采用表达式。

  ```javascript
  let methodName = 'getArea';
  
  class Square {
    constructor(length) {
      // ...
    }
  
    [methodName]() {
      // ...
    }
  }
  ```

- 上面代码中，`Square`类的方法名`getArea`，是从表达式得到的。

### Class 表达式

- 与函数一样，类也可以使用表达式的形式定义。

  ```javascript
  const MyClass = class Me {
    getClassName() {
      return Me.name;
    }
  };
  ```

- 上面代码使用表达式定义了一个类。需要注意的是，**这个类的名字是`Me`，但是`Me`只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用`MyClass`引用。**

  ```javascript
  let inst = new MyClass();
  inst.getClassName() // Me
  Me.name // ReferenceError: Me is not defined
  ```

- 上面代码表示，`Me`只在 Class 内部有定义。

- 如果**类的内部没用到的话，可以省略`Me`，**也就是可以写成下面的形式。

  ```javascript
  const MyClass = class { /* ... */ };
  ```

- 采用 Class 表达式，可以写出**立即执行的 Class**,其实就是加一个new关键字，声明类之后马上赋值

  ```javascript
  let person = new class {
    constructor(name) {
      this.name = name;
    }
  
    sayName() {
      console.log(this.name);
    }
  }('张三');
  
  person.sayName(); // "张三"
  ```

- 上面代码中，`person`是一个立即执行的类的实例。

### 注意点

**（1）严格模式**

- 类和模块的内部，默认就是严格模式，所以不需要使用`use strict`指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，**所以 ES6 实际上把整个语言升级到了严格模式**。

**（2）不存在提升**

- 类不存在变量提升（hoist），这一点与 ES5 完全不同。

  ```javascript
  new Foo(); // ReferenceError
  class Foo {}
  ```

- 上面代码中，`Foo`类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。**这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。**

  ```javascript
  {
    let Foo = class {};
    class Bar extends Foo {
    }
  }
  ```

- **上面的代码不会报错，因为`Bar`继承`Foo`的时候，`Foo`已经有定义了。但是，如果存在`class`的提升，上面代码就会报错，因为`class`会被提升到代码头部，而`let`命令是不提升的，所以导致`Bar`继承`Foo`的时候，`Foo`还没有定义。**

**（3）name 属性**

- 由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被`Class`继承，包括`name`属性。

  ```javascript
  class Point {}
  Point.name // "Point"
  ```

- `name`属性总是返回紧跟在`class`关键字后面的类名。

**（4）Generator 方法**

- 如果某个方法之前加上星号（`*`），就表示该方法是一个 Generator 函数。

  ```javascript
  class Foo {
    constructor(...args) {
      this.args = args;
    }
    * [Symbol.iterator]() {
      for (let arg of this.args) {
        yield arg;
      }
    }
  }
  
  for (let x of new Foo('hello', 'world')) {
    console.log(x);
  }
  // hello
  // world
  ```

- 上面代码中，`Foo`类的`Symbol.iterator`方法前有一个星号，表示该方法是一个 Generator 函数。`Symbol.iterator`方法返回一个`Foo`类的默认遍历器，`for...of`循环会自动调用这个遍历器。

**（5）this 的指向**

- 类的方法内部如果含有`this`，它**默认指向类的实例**。但是，必须非常小心，一旦单独使用该方法，很可能报错。

  ```javascript
  class Logger {
    printName(name = 'there') {
      this.print(`Hello ${name}`);
    }
  
    print(text) {
      console.log(text);
    }
  }
  
  const logger = new Logger();
  const { printName } = logger;
  printName(); // TypeError: Cannot read property 'print' of undefined
  ```

- 上面代码中，`printName`方法中的`this`，默认指向`Logger`类的实例。但是，如果将这个方法提取出来单独使用**，`this`会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是`undefined`），从而导致找不到`print`方法而报错**。

- 一个比较简单的解决方法是，在构造方法中**绑定`this`，**这样就不会找不到`print`方法了。

  ```javascript
  class Logger {
    constructor() {
      this.printName = this.printName.bind(this);
    }
  
    // ...
  }
  ```

- 另一种解决方法是**使用箭头函数**。

  ```javascript
  class Logger {
    constructor() {
      this.printName = (name = 'there') => {
        this.print(`Hello ${name}`);
      };
    }
  
    // ...
  }
  ```

- 还有一种解决方法是使用`Proxy`，获取方法的时候，自动绑定`this`。

  ```javascript
  function selfish (target) {
    const cache = new WeakMap();
    const handler = {
      get (target, key) {
        const value = Reflect.get(target, key);
        if (typeof value !== 'function') {
          return value;
        }
        if (!cache.has(value)) {
          cache.set(value, value.bind(target));
        }
        return cache.get(value);
      }
    };
    const proxy = new Proxy(target, handler);
    return proxy;
  }
  
  const logger = selfish(new Logger());
  ```

## 静态方法

- 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，**加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。**

  ```javascript
  class Foo {
    static classMethod() {
      return 'hello';
    }
  }
  
  Foo.classMethod() // 'hello'
  
  var foo = new Foo();
  foo.classMethod()
  // TypeError: foo.classMethod is not a function
  ```

- 上面代码中，`Foo`类的`classMethod`方法前有`static`关键字，表明该方法是一个静态方法，可以直接在`Foo`类上调用（`Foo.classMethod()`），而不是在`Foo`类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。

- 注意，如果**静态方法包含`this`关键字，这个`this`指的是类，而不是实例**。

  ```javascript
  class Foo {
    static bar() {
      this.baz();
    }
    static baz() {
      console.log('hello');
    }
    baz() {
      console.log('world');
    }
  }
  
  Foo.bar() // hello
  ```

- 上面代码中，静态方法`bar`调用了`this.baz`，这里的`this`指的是`Foo`类，而不是`Foo`的实例，等同于调用`Foo.baz`。**另外，从这个例子还可以看出，静态方法可以与非静态方法重名。**

- **本质：类也是要给对象，静态方法定义在类对象身上，而不是类的prototype上**

- **但是：**父类的静态方法，可以被**子类**继承，不会被**实例**继承，

  ```javascript
  class Foo {
    static classMethod() {
      return 'hello';
    }
  }
  
  class Bar extends Foo {
  }
  
  Bar.classMethod() // 'hello'
  ```

- 上面代码中，父类`Foo`有一个静态方法，子类`Bar`可以调用这个方法。

- **本质：把Foo作为Bar的prototype**，所以Foo身上的属性和方法都可以被Bar访问

- **静态方法也是可以从`super`对象上调用的**

  ```javascript
  class Foo {
    static classMethod() {
      return 'hello';
    }
  }
  
  class Bar extends Foo {
    static classMethod() {
      return super.classMethod() + ', too';
    }
  }
  
  Bar.classMethod() // "hello, too"
  ```


## 实例属性的新写法

+ **实例属性除了定义在`constructor()`方法里面的`this`上面，也可以定义在类的最顶层**。

+ **注意：**实例属性的新写法看起来和实例的方法层次一样，但是实例的方法都是在类的原型上的，而新写法定义的属性还是在实例自己身上，新写法仅仅是constructor的语法糖而已

+ ```js
  class IncreasingCounter {
    constructor() {
      this._count = 0;
    }
    get value() {
      console.log('Getting the current value!');
      return this._count;
    }
    increment() {
      this._count++;
    }
  }
  ```

+ 上面代码中，实例属性`this._count`定义在`constructor()`方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。

  ```javascript
  class IncreasingCounter {
    _count = 0;
    get value() {
      console.log('Getting the current value!');
      return this._count;
    }
    increment() {
      this._count++;
    }
  }
  ```

+ 上面代码中，实例属性`_count`与取值函数`value()`和`increment()`方法，处于同一个层级。这时，不需要在实例属性前面加上`this`。

+ 这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。

  ```javascript
  class foo {
    bar = 'hello';
    baz = 'world';
  
    constructor() {
      // ...
    }
  }
  ```

+ 上面的代码，一眼就能看出，`foo`类有两个实例属性，一目了然。另外，写起来也比较简洁。

## 静态属性

+ 静态属性指的是 Class 本身的属性，即`Class.propName`，而不是定义在实例对象（`this`）上的属性。

  ```javascript
  class Foo {
  }
  
  Foo.prop = 1;
  Foo.prop // 1
  ```

+ 上面的写法为`Foo`类定义了一个静态属性`prop`。

+ 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个[提案](https://github.com/tc39/proposal-class-fields)提供了类的静态属性，写法是在实例属性法的前面，加上`static`关键字。

  ```javascript
  class MyClass {
    static myStaticProp = 42;
  
    constructor() {
      console.log(MyClass.myStaticProp); // 42
    }
  }
  ```

+ 这个新写法大大方便了静态属性的表达。

+ ```javascript
  // 老写法
  class Foo {
    // ...
  }
  Foo.prop = 1;
  
  // 新写法
  class Foo {
    static prop = 1;
  }
  ```

+ 上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，**新写法是显式声明（declarative），而不是赋值处理，语义更好**。

- 

## 私有方法和私有属性

+ 私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。

+ 一种做法是在**命名上加以区别**。

  ```javascript
  class Widget {
  
    // 公有方法
    foo (baz) {
      this._bar(baz);
    }
  
    // 私有方法
    _bar(baz) {
      return this.snaf = baz;
    }
  
    // ...
  }
  ```

+ 上面代码中，`_bar`方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。

+ 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。

  ```javascript
  class Widget {
    foo (baz) {
      bar.call(this, baz);
    }
  
    // ...
  }
  
  function bar(baz) {
    return this.snaf = baz;
  }
  ```

+ 上面代码中，`foo`是公开方法，内部调用了`bar.call(this, baz)`。这**使得`bar`实际上成为了当前模块的私有方法**。

+ 还有一种方法是利用`Symbol`值的唯一性，**将私有方法的名字命名为一个`Symbol`值。**

  ```javascript
  const bar = Symbol('bar');
  const snaf = Symbol('snaf');
  
  export default class myClass{
  
    // 公有方法
    foo(baz) {
      this[bar](baz);
    }
  
    // 私有方法
    [bar](baz) {
      return this[snaf] = baz;
    }
  
    // ...
  };
  ```

+ 上面代码中，`bar`和`snaf`都是`Symbol`值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，`Reflect.ownKeys()`依然可以拿到它们。

  ```javascript
  const inst = new myClass();
  
  Reflect.ownKeys(myClass.prototype)
  // [ 'constructor', 'foo', Symbol(bar) ]
  ```

+ 上面代码中，Symbol 值的属性名依然可以从类的外部拿到。

### 私有属性的提案

+ 目前，有一个[提案](https://github.com/tc39/proposal-private-methods)，为`class`加了私有属性。方法是在属性名之前，**使用`#`表示**。

  ```javascript
  class IncreasingCounter {
    #count = 0;
    get value() {
      console.log('Getting the current value!');
      return this.#count;
    }
    increment() {
      this.#count++;
    }
  }
  ```

+ 上面代码中，`#count`就是私有属性，只能在类的内部使用（`this.#count`）。**如果在类的外部使用，就会报错**。

  ```javascript
  const counter = new IncreasingCounter();
  counter.#count // 报错
  counter.#count = 42 // 报错
  ```

+ 下面是另一个例子。

  ```javascript
  class Point {
    #x;
  
    constructor(x = 0) {
      this.#x = +x;
    }
  
    get x() {
      return this.#x;
    }
  
    set x(value) {
      this.#x = +value;
    }
  }
  ```

+ 上面代码中，`#x`就是私有属性，在`Point`类之外是读取不到这个属性的。由于井号`#`是属性名的一部分，使用时必须带有`#`一起使用，**所以`#x`和`x`是两个不同的属性。**

+ 之所以要引入一个新的前缀`#`表示私有属性，而没有采用`private`关键字，是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用`@`表示私有属性，ES6 没有用这个符号而使用`#`，是因为`@`已经被留给了 Decorator。

+ 这种写法不仅可以写私有属性，还可以用来写**私有方法**。

  ```javascript
  class Foo {
    #a;
    #b;
    constructor(a, b) {
      this.#a = a;
      this.#b = b;
    }
    #sum() {
      return #a + #b;
    }
    printSum() {
      console.log(this.#sum());
    }
  }
  ```

+ 上面代码中，`#sum()`就是一个私有方法。

+ 另外，私有属性也可以设置 getter 和 setter 方法。

  ```javascript
  class Counter {
    #xValue = 0;
  
    constructor() {
      super();
      // ...
    }
  
    get #x() { return #xValue; }
    set #x(value) {
      this.#xValue = value;
    }
  }
  ```

+ 上面代码中，`#x`是一个私有属性，它的读写都通过`get #x()`和`set #x()`来完成。

+ 私有属性不限于从`this`引用，只要是在类的内部，实例也可以引用私有属性。

  ```javascript
  class Foo {
    #privateValue = 42;
    static getPrivateValue(foo) {
      return foo.#privateValue;
    }
  }
  
  Foo.getPrivateValue(new Foo()); // 42
  ```

+ 上面代码允许从实例`foo`上面引用私有属性。

+ 私有属性和私有方法前面，也可以加上`static`关键字，表示这是一个静态的私有属性或私有方法。

  ```javascript
  class FakeMath {
    static PI = 22 / 7;
    static #totallyRandomNumber = 4;
  
    static #computeRandomNumber() {
      return FakeMath.#totallyRandomNumber;
    }
  
    static random() {
      console.log('I heard you like random numbers…')
      return FakeMath.#computeRandomNumber();
    }
  }
  
  FakeMath.PI // 3.142857142857143
  FakeMath.random()
  // I heard you like random numbers…
  // 4
  FakeMath.#totallyRandomNumber // 报错
  FakeMath.#computeRandomNumber() // 报错
  ```

+ 上面代码中，`#totallyRandomNumber`是私有属性，`#computeRandomNumber()`是私有方法，只能在`FakeMath`这个类的内部调用，外部调用就会报错。

## 用法总结

- class定义的本质上是一个构造函数，而且是为了模拟传统面向对象的语言，所以语法有点不同

  - 因为是一个函数，而不是一个对象，所以属性的定义使用“=”，
  - 方法的定义，并不是函数的简写形式，因为函数表达式形式定义的函数给到实例，简写写法的给到原型对象
  - 构造函数是整个class {} 代码块，而不仅仅是内部的constructor方法，constructor()和自定义的方法一样，是在原型对象上的一个方法而已，作用是：new时自动调用（而自定义的方法不会），在其内部生命的属性或方法会直接给到实例
  - 可以当成普通函数一样在类的内部调用某个子函数吗？不可以，会报错
  - 也无法直接使用this关键字，必须在函数内部或者用于赋值定义，在内部的this绑定类，但是在构造函数内的this绑定实例

- constructor函数内的，就是ES5的普通构造函数的写法，使用this，给到实例

  - 在constructor函数内无法使用set和get关键字?chrome报错

- 写在类顶部的，是constructor写法的语法糖，可以省略this，直接定义到**实例**身上，可以直接访问

  - 类顶部，只是一种表示形式，写在内部即可
  - 包括函数表达式，也会直接给到实例

- 写在类顶部的方法，是定义到构造函数的**原型链**上的，写法和对象内部的方法简写形式一致，但是：谨记类是一个函数

  - 这种写法在vscode node环境下会报错

- 在类的内部，无法直接定义原型的属性，但是可以使用**setter或者getter函数**定义属性，这样的属性是在原型对象上的，或者在类的外部调用prototype属性，在内部可以调用吗？

- ```js
  class Foo { 
    constructor() {
      // 实例的属性或方法
        this.x = 1 // this绑定实例
      // 无法使用get和set关键字
    }
    // 在实例身上，位置可以任意
    bar = 'hello';
    baz = this.bar; // 'hello',this绑定类
    // 在实例身上
    oppo = function(){}
  
    // 在原型对象上
    toString() {
    // ...
    }
  	// 在原型对象上
  	get prop() {
    return 'getter';
  	}
    set prop(value) {
      console.log('setter: '+value);
    }
  
  }
  const foo = new Foo()
  // foo.hasOwnProperty('oppo') true
  // foo.hasOwnProperty('toString') false 
  // foo.__proto__.hasOwnProperty('toString') true
  ```

- 通过static关键字，可以做到给构造函数对象，类本身添加**方法**，实例自然是无法访问到的

- 而类的**属性**，通过普通对象的形式来添加和访问，实例自然也是无法访问到，而在最新的提案中也可以使用static关键字定义类自身的属性了

- 私有方法和私有属性，类外部不可访问，既可以是构造函数内的，或者类的顶部（原型链），也可以是私有的

- 

## new.target 属性

- `new`是从构造函数生成实例对象的命令。ES6 为`new`命令引入了一个`new.target`属性，该属性一般用在构造函数之中，**返回`new`命令作用于的那个构造函数。**

- 如果构造函数不是通过`new`命令或`Reflect.construct()`调用的，`new.target`会返回`undefined`，因此**这个属性可以用来确定构造函数是怎么调用的。**

  ```javascript
  function Person(name) {
    if (new.target !== undefined) {
      this.name = name;
    } else {
      throw new Error('必须使用 new 命令生成实例');
    }
  }
  
  // 另一种写法
  function Person(name) {
    if (new.target === Person) {
      this.name = name;
    } else {
      throw new Error('必须使用 new 命令生成实例');
    }
  }
  
  var person = new Person('张三'); // 正确
  var notAPerson = Person.call(person, '张三');  // 报错
  ```

- 上面代码确保构造函数只能通过`new`命令调用。

- Class 内部调用`new.target`，返回当前 Class。

  ```javascript
  class Rectangle {
    constructor(length, width) {
      console.log(new.target === Rectangle);
      this.length = length;
      this.width = width;
    }
  }
  
  var obj = new Rectangle(3, 4); // 输出 true
  ```

- **需要注意的是，子类继承父类时，`new.target`会返回子类**。

  ```javascript
  class Rectangle {
    constructor(length, width) {
      console.log(new.target === Rectangle);
      // ...
    }
  }
  
  class Square extends Rectangle {
    constructor(length) {
      super(length, width);
    }
  }
  
  var obj = new Square(3); // 输出 false
  ```

- 上面代码中，`new.target`会返回子类。

- 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。

  ```javascript
  class Shape {
    constructor() {
      if (new.target === Shape) {
        throw new Error('本类不能实例化');
      }
    }
  }
  
  class Rectangle extends Shape {
    constructor(length, width) {
      super();
      // ...
    }
  }
  
  var x = new Shape();  // 报错
  var y = new Rectangle(3, 4);  // 正确
  ```

- 上面代码中，`Shape`类不能被实例化，只能用于继承。

- **注意，在函数外部，使用`new.target`会报错。**

# 24. Class 的继承

## 简介 

- Class 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。

  - Class类用于定义构造函数和原型，extends类似于定义现有的对象为对象的原型

  ```javascript
  class Point {
  }
  
  class ColorPoint extends Point {
  }
  ```

- 上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，**继承了`Point`类的所有属性和方法**。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。

  ```javascript
  class ColorPoint extends Point {
    constructor(x, y, color) {
      super(x, y); // 调用父类的constructor(x, y)
      this.color = color;
    }
  
    toString() {
      return this.color + ' ' + super.toString(); // 调用父类的toString()
    }
  }
  ```

- 上面代码中，`constructor`方法和`toString`方法之中，**都出现了`super`关键字，它在这里表示父类的构造函数，用来新建父类的`this`对象。**

- 子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类自己的`this`对象，必须先通过父类的构造函数完成塑造，**得到与父类同样的实例属性和方法，然后再对其进行加工**，加上子类自己的实例属性和方法。**如果不调用`super`方法，子类就得不到`this`对象。**

  ```javascript
  class Point { /* ... */ }
  
  class ColorPoint extends Point {
    constructor() {
    }
  }
  
  let cp = new ColorPoint(); // ReferenceError
  ```

- 上面代码中，`ColorPoint`继承了父类`Point`，但是它的构造函数没有调用`super`方法，导致新建实例时报错。

- ES5 的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面（`Parent.apply(this)`）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。

- 如果子类没有定义`constructor`方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有`constructor`方法，**同时也会调用super（）**

  ```javascript
  class ColorPoint extends Point {
  }
  
  // 等同于
  class ColorPoint extends Point {
    constructor(...args) {
      super(...args);
    }
  }
  ```

- 另一个需要注意的地方是，在子类的构造函数中，只有调用`super`之后，才可以使用`this`关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有`super`方法才能调用父类实例。

  ```javascript
  class Point {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
  }
  
  class ColorPoint extends Point {
    constructor(x, y, color) {
      this.color = color; // ReferenceError
      super(x, y);
      this.color = color; // 正确
    }
  }
  ```

- 上面代码中，子类的`constructor`方法没有调用`super`之前，就使用`this`关键字，结果报错，而放在`super`方法之后就是正确的。

- 下面是生成子类实例的代码。

  ```javascript
  let cp = new ColorPoint(25, 8, 'green');
  
  cp instanceof ColorPoint // true
  cp instanceof Point // true
  ```

- 上面代码中，实例对象`cp`同时是`ColorPoint`和`Point`两个类的实例，这与 ES5 的行为完全一致，一样可以沿着原型链向上查找

- 最后，父类的静态方法，也会被子类继承。

  ```javascript
  class A {
    static hello() {
      console.log('hello world');
    }
  }
  
  class B extends A {
  }
  
  B.hello()  // hello world
  ```

- 上面代码中，`hello()`是`A`类的静态方法，`B`继承`A`，也继承了`A`的静态方法。

## Object.getPrototypeOf()

- `Object.getPrototypeOf`方法可以用来从子类上获取父类。

  ```javascript
  Object.getPrototypeOf(ColorPoint) === Point
  // true
  ```

- 因此，可以使用这个方法判断，一个类是否继承了另一个类。

## super 关键字

- `super`这个关键字，**既可以当作函数使用，也可以当作对象使用**。在这两种情况下，它的**用法完全不同**，不同情况下既然不同的表现，是的super关键字可以在子类中访问父类的：构造函数（初始化继承）、父类本身（静态方法和属性）、原型对象（沿着父类的原型链）

  - **注意：**用作函数和用作对象，形式上差不多，但是作用差距甚远，要分清

- 第一种情况，`super`作为函数调用时，**代表父类的构造函数**。ES6 要求，子类的构造函数必须执行一次`super`函数，相当于是新建了父类的this

  ```javascript
  class A {}
  
  class B extends A {
    constructor() {
      super(); // 在这一步调用了父类的构造函数，对this的方法和属性进行绑定，实现继承
    }
  }
  ```

- 上面代码中，子类`B`的构造函数之中的`super()`，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。

- **注意**，`super`虽然代表了父类`A`的构造函数，但是**返回的是子类`B`的实例**，即`super`内部的`this`指的是`B`的实例，因此`super()`在这里相当于`A.prototype.constructor.call(this)`。

  ```javascript
  class A {
    constructor() {
      console.log(new.target.name);
    }
  }
  class B extends A {
    constructor() {
      super();
    }
  }
  new A() // A
  new B() // B
  ```

- 上面代码中，`new.target`指向当前正在执行的**构造函数**。可以看到，在`super()`执行时，它指向的是子类`B`的构造函数，而不是父类`A`的构造函数。也就是说，`super()`内部的`this`指向的是`B`。

- **作为函数时**，`super()`只能用在**子类的构造函数**之中，用在其他地方就会报错。

  ```javascript
  class A {}
  
  class B extends A {
    m() {
      super(); // 报错
    }
  }
  ```

- 上面代码中，`super()`用在`B`类的`m`方法之中，就会造成句法错误。

- 第二种情况，`super`作为对象时，**在普通方法中，指向父类的原型对象；在静态方法中，指向父类。**

  ```javascript
  class A {
    p() {
      return 2;
    }
  }
  
  class B extends A {
    constructor() {
      super();
      console.log(super.p()); // 2
    }
  }
  
  let b = new B();
  ```

- 上面代码中，子类`B`当中的`super.p()`，就是将`super`当作一个对象使用。这时，`super`在普通方法之中，指向`A.prototype`，所以`super.p()`就相当于`A.prototype.p()`。

- 这里需要注意，由于`super`指向父类的原型对象，所以定义在**父类实例**上的方法或属性，是无法通过`super`调用的。

  ```javascript
  class A {
    constructor() {
      this.p = 2;
    }
  }
  
  class B extends A {
    get m() {
      return super.p;
    }
  }
  
  let b = new B();
  b.m // undefined
  ```

- 上面代码中，`p`是父类`A`实例的属性，`super.p`就引用不到它。

+ 如果属性定义在父类的原型对象上，`super`就可以取到。

  ```javascript
  class A {}
  A.prototype.x = 2;
  
  class B extends A {
    constructor() {
      super();
      console.log(super.x) // 2
    }
  }
  
  let b = new B();
  ```

+ 上面代码中，属性`x`是定义在`A.prototype`上面的，所以`super.x`可以取到它的值。

+ ES6 规定，在子类普通方法中通过`super`调用父类的方法时，方法内部的`this`指向当前的**子类实例**。

  ```javascript
  class A {
    constructor() {
      this.x = 1;
    }
    print() {
      console.log(this.x);
    }
  }
  
  class B extends A {
    constructor() {
      super();
      this.x = 2;
    }
    m() {
      super.print();
    }
  }
  
  let b = new B();
  b.m() // 2
  ```

+ 上面代码中，`super.print()`虽然调用的是`A.prototype.print()`，但是`A.prototype.print()`内部的`this`指向子类`B`的实例，导致输出的是`2`，而不是`1`。也就是说，实际上执行的是`super.print.call(this)`。

+ 由于`this`指向子类实例，所以如果通过`super`对某个属性赋值，这时`super`就是`this`，赋值的属性会变成子类实例的属性。

  ```javascript
  class A {
    constructor() {
      this.x = 1;
    }
  }
  
  class B extends A {
    constructor() {
      super();
      this.x = 2;
      super.x = 3;
      console.log(super.x); // undefined
      console.log(this.x); // 3
    }
  }
  
  let b = new B();
  ```

+ 上面代码中，`super.x`赋值为`3`，这时等同于对`this.x`赋值为`3`。而当读取`super.x`的时候，读的是`A.prototype.x`，所以返回`undefined`。

+ 如果`super`作为对象，用在静态方法之中，这时`super`将指向父类，而不是父类的原型对象。

  ```javascript
  class Parent {
    static myMethod(msg) {
      console.log('static', msg);
    }
  
    myMethod(msg) {
      console.log('prototype', msg);
    }
  }
  
  class Child extends Parent {
    static myMethod(msg) {
      super.myMethod(msg);
    }
  
    myMethod(msg) {
      super.myMethod(msg);
    }
  }
  
  Child.myMethod(1); // static 1
  
  var child = new Child();
  child.myMethod(2); // prototype 2
  ```

+ 上面代码中，`super`在静态方法之中指向父类，在普通方法之中指向父类的原型对象。因为只有静态方法可以定义在父类身上，其他的属性或这方法都是给到实例或这原型对象的，所以想要获取父类自身的属性也必须在静态方法之中，以做区分

+ 另外，在子类的静态方法中通过`super`调用父类的方法时，方法内部的`this`指向当前的子类，而不是子类的实例。

  ```javascript
  class A {
    constructor() {
      this.x = 1;
    }
    static print() {
      console.log(this.x);
    }
  }
  
  class B extends A {
    constructor() {
      super();
      this.x = 2;
    }
    static m() {
      super.print();
    }
  }
  
  B.x = 3;
  B.m() // 3
  ```

+ 上面代码中，静态方法`B.m`里面，`super.print`指向父类的静态方法。这个方法里面的`this`指向的是`B`，而不是`B`的实例。

+ 注意，使用`super`的时候，必须**显式指定**是作为函数、还是作为对象使用，否则会报错。

  ```javascript
  class A {}
  
  class B extends A {
    constructor() {
      super();
      console.log(super); // 报错
    }
  }
  ```

+ 上面代码中，`console.log(super)`当中的`super`，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明`super`的数据类型，就不会报错。

  ```javascript
  class A {}
  
  class B extends A {
    constructor() {
      super();
      console.log(super.valueOf() instanceof B); // true
    }
  }
  
  let b = new B();
  ```

+ 上面代码中，`super.valueOf()`表明`super`是一个对象，因此就不会报错。同时，由于`super`使得`this`指向`B`的实例，所以`super.valueOf()`返回的是一个`B`的实例。

+ 最后，由于对象总是继承其他对象的，所以**可以在任意一个对象**中，使用`super`关键字。

  ```javascript
  var obj = {
    toString() {
      return "MyObject: " + super.toString();
    }
  };
  
  obj.toString(); // MyObject: [object Object]
  ```

## 类的 prototype 属性和\__proto__属性

- 大多数浏览器的 ES5 实现之中，每一个对象都有`__proto__`属性，指向对应的构造函数的`prototype`属性。Class 作为构造函数的语法糖，同时有`prototype`属性和`__proto__`属性，因此同时存在两条继承链。

  （1）子类的`__proto__`属性，表示**构造函数**的继承，总是指向父类。

  （2）子类`prototype`属性的`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。

  ```javascript
  class A {
  }
  
  class B extends A {
  }
  
  B.__proto__ === A // true
  B.prototype.__proto__ === A.prototype // true
  ```

- 上面代码中，子类`B`的`__proto__`属性指向父类`A`，子类`B`的`prototype`属性的`__proto__`属性指向父类`A`的`prototype`属性。
- 本质：两种身份，作为一个函数，有prototype属性，作为对象，有`__proto__`属性

- 这样的结果是因为，**类的继承是按照下面的模式实现的**。

  ```javascript
  class A {
  }
  
  class B {
  }
  
  // B 的实例继承 A 的实例
  Object.setPrototypeOf(B.prototype, A.prototype);
  
  // B 继承 A 的静态属性
  Object.setPrototypeOf(B, A);
  
  const b = new B();
  ```

- 《对象的扩展》一章给出过`Object.setPrototypeOf`方法的实现。

  ```javascript
  Object.setPrototypeOf = function (obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  ```

- 因此，就得到了上面的结果。

- ```javascript
  Object.setPrototypeOf(B.prototype, A.prototype);
  // 等同于
  B.prototype.__proto__ = A.prototype;
  
  Object.setPrototypeOf(B, A);
  // 等同于
  B.__proto__ = A;
  ```

- 这两条继承链，可以这样理解：作为一个对象，子类（`B`）的原型（`__proto__`属性）是父类（`A`）；作为一个构造函数，子类（`B`）的原型对象（`prototype`属性）是父类的原型对象（`prototype`属性）的实例。

- ```javascript
  Object.create(A.prototype);
  // 等同于
  B.prototype.__proto__ = A.prototype;
  ```

- `extends`关键字后面可以跟多种类型的值。

  ```javascript
  class B extends A {
  }
  ```

- 上面代码的`A`，只要是一个有`prototype`属性的函数，就能被`B`继承。由于函数都有`prototype`属性（除了`Function.prototype`函数），因此`A`可以是任意函数。

- 下面，讨论两种情况。第一种，子类继承`Object`类。

  ```javascript
  class A extends Object {
  }
  
  A.__proto__ === Object // true
  A.prototype.__proto__ === Object.prototype // true
  ```

- 这种情况下，`A`其实就是构造函数`Object`的复制，`A`的实例就是`Object`的实例。

- 第二种情况，不存在任何继承。

  ```javascript
  class A {
  }
  
  A.__proto__ === Function.prototype // true
  A.prototype.__proto__ === Object.prototype // true
  ```

- 这种情况下，`A`作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承`Function.prototype`。但是，`A`调用后返回一个空对象（即`Object`实例），所以`A.prototype.__proto__`指向构造函数（`Object`）的`prototype`属性。

### 实例的 __proto__ 属性

- 子类实例的`__proto__`属性的`__proto__`属性，指向父类实例的`__proto__`属性。也就是说，子类的原型的原型，是父类的原型。

  ```javascript
  var p1 = new Point(2, 3);
  var p2 = new ColorPoint(2, 3, 'red');
  
  p2.__proto__ === p1.__proto__ // false
  p2.__proto__.__proto__ === p1.__proto__ // true
  ```

- 上面代码中，`ColorPoint`继承了`Point`，导致前者原型的原型是后者的原型。

- 因此，通过子类实例的`__proto__.__proto__`属性，可以**修改父类实例**的行为。

  ```javascript
  p2.__proto__.__proto__.printName = function () {
    console.log('Ha');
  };
  
  p1.printName() // "Ha"
  ```

- 上面代码在`ColorPoint`的实例`p2`上向`Point`类添加方法，结果影响到了`Point`的实例`p1`。

## 原生构造函数的继承

- 原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。

  - Boolean()
  - Number()
  - String()
  - Array()
  - Date()
  - Function()
  - RegExp()
  - Error()
  - Object()

- 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个`Array`的子类。

  ```javascript
  function MyArray() {
    Array.apply(this, arguments);
  }
  
  MyArray.prototype = Object.create(Array.prototype, {
    constructor: {
      value: MyArray,
      writable: true,
      configurable: true,
      enumerable: true
    }
  });
  ```

- 上面代码定义了一个继承 Array 的`MyArray`类。但是，这个类的行为与`Array`完全不一致。

  ```javascript
  var colors = new MyArray();
  colors[0] = "red";
  colors.length  // 0
  
  colors.length = 0;
  colors[0]  // "red"
  ```

- 之所以会发生这种情况，是因为**子类无法获得原生构造函数的内部属性**，通过`Array.apply()`或者分配给原型对象都不行。原生构造函数会忽略`apply`方法传入的`this`，也就是说，**原生构造函数的`this`无法绑定，导致拿不到内部属性。**

- ES5 是先新建子类的实例对象`this`，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，`Array`构造函数有一个内部属性`[[DefineOwnProperty]]`，用来定义新属性时，更新`length`属性，这个内部属性无法在子类获取，导致子类的`length`属性行为不正常。

- 下面的例子中，我们想让一个普通对象继承`Error`对象。

  ```javascript
  var e = {};
  
  Object.getOwnPropertyNames(Error.call(e))
  // [ 'stack' ]
  
  Object.getOwnPropertyNames(e)
  // []
  ```

- 上面代码中，我们想通过`Error.call(e)`这种写法，让普通对象`e`具有`Error`对象的实例属性。但是，`Error.call()`完全忽略传入的第一个参数，而是返回一个新对象，`e`本身没有任何变化。这证明了`Error.call(e)`这种写法，无法继承原生构造函数。

- ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象`this`，然后再用子类的构造函数修饰`this`，使得父类的所有行为都可以继承。下面是一个继承`Array`的例子。

  ```javascript
  class MyArray extends Array {
    constructor(...args) {
      super(...args);
    }
  }
  
  var arr = new MyArray();
  arr[0] = 12;
  arr.length // 1
  
  arr.length = 0;
  arr[0] // undefined
  ```

- 上面代码定义了一个`MyArray`类，继承了`Array`构造函数，因此就可以从`MyArray`生成数组的实例。这意味着，**ES6 可以自定义原生数据结构（比如`Array`、`String`等）的子类**，这是 ES5 无法做到的。上面这个例子也说明，`extends`关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。

  ```javascript
  class VersionedArray extends Array {
    constructor() {
      super();
      this.history = [[]];
    }
    commit() {
      this.history.push(this.slice());
    }
    revert() {
      this.splice(0, this.length, ...this.history[this.history.length - 1]);
    }
  }
  
  var x = new VersionedArray();
  
  x.push(1);
  x.push(2);
  x // [1, 2]
  x.history // [[]]
  
  x.commit();
  x.history // [[], [1, 2]]
  
  x.push(3);
  x // [1, 2, 3]
  x.history // [[], [1, 2]]
  
  x.revert();
  x // [1, 2]
  ```

- 上面代码中，`VersionedArray`会通过`commit`方法，将自己的当前状态生成一个版本快照，存入`history`属性。`revert`方法用来将数组重置为最新一次保存的版本。除此之外，`VersionedArray`依然是一个普通数组，所有原生的数组方法都可以在它上面调用。

- 下面是一个自定义`Error`子类的例子，可以用来定制报错时的行为。

  ```javascript
  class ExtendableError extends Error {
    constructor(message) {
      super();
      this.message = message;
      this.stack = (new Error()).stack;
      this.name = this.constructor.name;
    }
  }
  
  class MyError extends ExtendableError {
    constructor(m) {
      super(m);
    }
  }
  
  var myerror = new MyError('ll');
  myerror.message // "ll"
  myerror instanceof Error // true
  myerror.name // "MyError"
  myerror.stack
  // Error
  //     at MyError.ExtendableError
  //     ...
  ```

- 注意，继承`Object`的子类，有一个[行为差异](http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object)。

  ```javascript
  class NewObj extends Object{
    constructor(){
      super(...arguments);
    }
  }
  var o = new NewObj({attr: true});
  o.attr === true  // false
  ```

- 上面代码中，`NewObj`继承了`Object`，但是无法通过`super`方法向父类`Object`传参。这是因为 ES6 改变了`Object`构造函数的行为，一旦发现`Object`方法不是通过`new Object()`这种形式调用，ES6 规定`Object`构造函数会忽略参数。

## Mixin 模式的实现

- Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。

  ```javascript
  const a = {
    a: 'a'
  };
  const b = {
    b: 'b'
  };
  const c = {...a, ...b}; // {a: 'a', b: 'b'}
  ```

- 上面代码中，`c`对象是`a`对象和`b`对象的合成，具有两者的接口。

- 下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。

  ```javascript
  function mix(...mixins) {
    class Mix {
      constructor() {
        for (let mixin of mixins) {
          copyProperties(this, new mixin()); // 拷贝实例属性
        }
      }
    }
  
    for (let mixin of mixins) {
      copyProperties(Mix, mixin); // 拷贝静态属性
      copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性
    }
  
    return Mix;
  }
  
  function copyProperties(target, source) {
    for (let key of Reflect.ownKeys(source)) {
      if ( key !== 'constructor'
        && key !== 'prototype'
        && key !== 'name'
      ) {
        let desc = Object.getOwnPropertyDescriptor(source, key);
        Object.defineProperty(target, key, desc);
      }
    }
  }
  ```

- 上面代码的`mix`函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。

- ```javascript
  class DistributedEdit extends mix(Loggable, Serializable) {
    // ...
  }
  ```

# 25. Module 的语法

## 概述

- 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的`require`、Python 的`import`，甚至就连 CSS 都有`@import`，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。

- 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

- ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。

- ```javascript
  // CommonJS模块
  let { stat, exists, readFile } = require('fs');
  
  // 等同于
  let _fs = require('fs');
  let stat = _fs.stat;
  let exists = _fs.exists;
  let readfile = _fs.readfile;
  ```

- 上面代码的实质是整体加载`fs`模块（即加载`fs`的所有方法），生成一个对象（`_fs`），然后再从这个对象上面读取 3 个方法。这种加载称为**“运行时加载”**，因为只有**运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。**

  

- ES6 模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入。

  ```javascript
  // ES6模块
  import { stat, exists, readFile } from 'fs';
  ```

- 上面代码的实质是从`fs`模块加载 3 个方法，其他方法不加载。这种加载称为**“编译时加载”或者静态加载**，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。

  

- 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入**宏（macro）**和**类型检验（type system）**这些只能靠静态分析实现的功能。

  除了静态加载带来的各种好处，ES6 模块还有以下好处。

  - 不再需要`UMD`模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。
  - 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者`navigator`对象的属性。
  - 不再需要对象作为命名空间（比如`Math`对象），未来这些功能可以通过模块提供。

- 本章介绍 ES6 模块的语法，下一章介绍如何在浏览器和 Node 之中，加载 ES6 模块。

## 严格模式

- ES6 的模块自动采用严格模式，不管你有没有在模块头部加上`"use strict";`。
- 严格模式主要有以下限制。
  - 变量必须声明后再使用
  - 函数的参数不能有同名属性，否则报错
  - 不能使用`with`语句
  - 不能对只读属性赋值，否则报错
  - 不能使用前缀 0 表示八进制数，否则报错
  - 不能删除不可删除的属性，否则报错
  - 不能删除变量`delete prop`，会报错，只能删除属性`delete global[prop]`
  - `eval`不会在它的外层作用域引入变量
  - `eval`和`arguments`不能被重新赋值
  - `arguments`不会自动反映函数参数的变化
  - 不能使用`arguments.callee`
  - 不能使用`arguments.caller`
  - 禁止`this`指向全局对象
  - 不能使用`fn.caller`和`fn.arguments`获取函数调用的堆栈
  - 增加了保留字（比如`protected`、`static`和`interface`）

- 上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。
- 其中，尤其需要注意`this`的限制。ES6 模块之中，顶层的`this`指向`undefined`，即不应该在顶层代码使用`this`。

## export 命令

- 模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的**对外**接口，`import`命令用于**引入**其他模块提供的功能。

- 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量。下面是一个 JS 文件，里面使用`export`命令输出变量。

  ```javascript
  // profile.js
  export var firstName = 'Michael';
  export var lastName = 'Jackson';
  export var year = 1958;
  ```

- 上面代码是`profile.js`文件，保存了用户信息。ES6 将其视为一个模块，里面用`export`命令对外部输出了三个变量。

- `export`的写法，除了像上面这样，还有另外一种。

  ```javascript
  // profile.js
  var firstName = 'Michael';
  var lastName = 'Jackson';
  var year = 1958;
  
  export {firstName, lastName, year};
  ```

- 上面代码在`export`命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在`var`语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。

- `export`命令除了输出变量，还可以输出函数或类（class）。

  ```javascript
  export function multiply(x, y) {
    return x * y;
  };
  ```

- 上面代码对外输出一个函数`multiply`。

- 通常情况下，`export`输出的变量就是本来的名字，但是可以使用`as`关键字重命名。

  ```javascript
  function v1() { ... }
  function v2() { ... }
  
  export {
    v1 as streamV1,
    v2 as streamV2,
    v2 as streamLatestVersion
  };
  ```

- 上面代码使用`as`关键字，重命名了函数`v1`和`v2`的对外接口。重命名后，`v2`可以用不同的名字输出两次。

- 需要特别注意的是，`export`命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。

  ```javascript
  // 报错
  export 1;
  
  // 报错
  var m = 1;
  export m;
  ```

- 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量`m`，还是直接输出 1。`1`只是一个值，不是接口。正确的写法是下面这样。

  ```javascript
  // 写法一
  export var m = 1;
  
  // 写法二
  var m = 1;
  export {m};
  
  // 写法三
  var n = 1;
  export {n as m};
  ```

- 上面三种写法都是正确的，规定了对外的接口`m`。其他脚本可以通过这个接口，取到值`1`。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。

- 同样的，`function`和`class`的输出，也必须遵守这样的写法。

  ```javascript
  // 报错
  function f() {}
  export f;
  
  // 正确
  export function f() {};
  
  // 正确
  function f() {}
  export {f};
  ```

- 另外，`export`语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。

  ```javascript
  export var foo = 'bar';
  setTimeout(() => foo = 'baz', 500);
  ```

- 上面代码输出变量`foo`，值为`bar`，500 毫秒之后变成`baz`。

- 这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新，详见下文《Module 的加载实现》一节。

- 最后，`export`命令可以出现在模块的任何位置，只要处于**模块顶层**就可以。如果处于块级作用域内，就会报错，下一节的`import`命令也是如此。这是因为**处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。**

  ```javascript
  function foo() {
    export default 'bar' // SyntaxError
  }
  foo()
  ```

- 上面代码中，`export`语句放在函数之中，结果报错。

## import 命令

- 使用`export`命令定义了模块的对外接口以后，其他 JS 文件就可以通过`import`命令加载这个模块。

  ```javascript
  // main.js
  import {firstName, lastName, year} from './profile.js';
  
  function setName(element) {
    element.textContent = firstName + ' ' + lastName;
  }
  ```

- 上面代码的`import`命令，用于加载`profile.js`文件，并从中输入变量。`import`命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（`profile.js`）对外接口的名称相同。

- 如果想为输入的变量重新取一个名字，`import`命令要使用`as`关键字，将输入的变量重命名。- 

  ```javascript
  import { lastName as surname } from './profile.js';
  ```

- `import`命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。

- ```javascript
  import {a} from './xxx.js'
  
  a = {}; // Syntax Error : 'a' is read-only;
  ```

- 上面代码中，脚本加载了变量`a`，对其重新赋值就会报错，因为`a`是一个只读的接口。但是，如果`a`是一个对象，改写`a`的**属性**是允许的。

  ```javascript
  import {a} from './xxx.js'
  
  a.foo = 'hello'; // 合法操作
  ```

- 上面代码中，`a`的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，轻易不要改变它的属性。

- `import`后面的`from`指定模块文件的位置，可以是相对路径，也可以是绝对路径，`.js`后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。

  ```javascript
  import {myMethod} from 'util';
  ```

- 上面代码中，`util`是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。

- **注意**，`import`命令具有提升效果，会提升到整个模块的头部，首先执行。

  ```javascript
  foo();
  
  import { foo } from 'my_module';
  ```

- 上面的代码不会报错，因为`import`的执行早于`foo`的调用。这种行为的本质是，`import`命令是编译阶段执行的，在代码运行之前。

- 由于`import`是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。

  ```javascript
  // 报错
  import { 'f' + 'oo' } from 'my_module';
  
  // 报错
  let module = 'my_module';
  import { foo } from module;
  
  // 报错
  if (x === 1) {
    import { foo } from 'module1';
  } else {
    import { foo } from 'module2';
  }
  ```

- 上面三种写法都会报错，因为它们用到了表达式、变量和`if`结构。在静态分析阶段，这些语法都是没法得到值的。

- 最后，`import`语句会执行所加载的模块，因此可以有下面的写法。

  ```javascript
  import 'lodash';
  ```

- 上面代码仅仅执行`lodash`模块，但是不输入任何值。

- 如果多次重复执行同一句`import`语句，那么只会执行一次，而不会执行多次。

  ```javascript
  import 'lodash';
  import 'lodash';
  ```

- 上面代码加载了两次`lodash`，但是只会执行一次。

  ```javascript
  import { foo } from 'my_module';
  import { bar } from 'my_module';
  
  // 等同于
  import { foo, bar } from 'my_module';
  ```

- 上面代码中，虽然`foo`和`bar`在两个语句中加载，但是它们对应的是同一个`my_module`实例。也就是说，`import`语句是 **Singleton 模式**。

- 目前阶段，通过 Babel 转码，CommonJS 模块的`require`命令和 ES6 模块的`import`命令，可以写在同一个模块里面，但是最好不要这样做。因为`import`在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。

  ```javascript
  require('core-js/modules/es6.symbol');
  require('core-js/modules/es6.promise');
  import React from 'React';
  ```

## 模块的整体加载

- 除了指定加载某个输出值，还可以使用整体加载，即用星号（`*`）指定一个对象，所有输出值都加载在这个对象上面。

- 下面是一个`circle.js`文件，它输出两个方法`area`和`circumference`。

- ```javascript
  // circle.js
  
  export function area(radius) {
    return Math.PI * radius * radius;
  }
  
  export function circumference(radius) {
    return 2 * Math.PI * radius;
  }
  ```

- 现在，加载这个模块。

  ```javascript
  // main.js
  
  import { area, circumference } from './circle';
  
  console.log('圆面积：' + area(4));
  console.log('圆周长：' + circumference(14));
  ```

- 上面写法是逐一指定要加载的方法，整体加载的写法如下。

  ```javascript
  import * as circle from './circle';
  
  console.log('圆面积：' + circle.area(4));
  console.log('圆周长：' + circle.circumference(14));
  ```

- 注意，模块整体加载所在的那个对象（上例是`circle`），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。

  ```javascript
  import * as circle from './circle';
  
  // 下面两行都是不允许的
  circle.foo = 'hello';
  circle.area = function () {};
  ```

## export default 命令

- 从前面的例子可以看出，使用`import`命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。

- 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到`export default`命令，为模块指定默认输出。

  ```javascript
  // export-default.js
  export default function () {
    console.log('foo');
  }
  ```

- 上面代码是一个模块文件`export-default.js`，它的默认输出是一个函数。

- 其他模块加载该模块时，`import`命令可以为该匿名函数指定任意名字。

  ```javascript
  // import-default.js
  import customName from './export-default';
  customName(); // 'foo'
  ```

- 上面代码的`import`命令，可以用任意名称指向`export-default.js`输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时`import`命令后面，不使用大括号。

  

- `export default`命令用在非匿名函数前，也是可以的。

  ```javascript
  // export-default.js
  export default function foo() {
    console.log('foo');
  }
  
  // 或者写成
  
  function foo() {
    console.log('foo');
  }
  
  export default foo;
  ```

- 上面代码中，`foo`函数的函数名`foo`，**在模块外部是无效的。加载的时候，视同匿名函数加载**。



- 下面比较一下默认输出和正常输出。

  ```javascript
  // 第一组
  export default function crc32() { // 输出
    // ...
  }
  
  import crc32 from 'crc32'; // 输入
  
  // 第二组
  export function crc32() { // 输出
    // ...
  };
  
  import {crc32} from 'crc32'; // 输入
  ```

- 上面代码的两组写法，第一组是使用`export default`时，对应的`import`语句不需要使用大括号；第二组是不使用`export default`时，对应的`import`语句需要使用大括号。

- `export default`命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此`export default`命令**只能使用一次**。所以，import命令后面才不用加大括号，因为只可能唯一对应`export default`命令。

- **本质上**，`export default`就是输出一个叫做`default`的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。

  ```javascript
  // modules.js
  function add(x, y) {
    return x * y;
  }
  export {add as default};
  // 等同于
  // export default add;
  
  // app.js
  import { default as foo } from 'modules';
  // 等同于
  // import foo from 'modules';
  ```

- 正是因为`export default`命令其实只是输出一个叫做`default`的变量，所以它后面不能跟变量声明语句。

  ```javascript
  // 正确
  export var a = 1;
  
  // 正确
  var a = 1;
  export default a;
  
  // 错误
  export default var a = 1;
  ```

- **上面代码中，`export default a`的含义是将变量`a`的值赋给变量`default`。所以，最后一种写法会报错。**

- 同样地，因为`export default`命令的本质是将后面的值，赋给`default`变量，所以可以直接将一个值写在`export default`之后。

  ```javascript
  // 正确
  export default 42;
  
  // 报错
  export 42;
  ```

- 上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为`default`。

- 有了`export default`命令，输入模块时就非常直观了，以输入 lodash 模块为例。

  ```javascript
  import _ from 'lodash';
  ```

- 如果想在一条`import`语句中，同时输入默认方法和其他接口，可以写成下面这样。

  ```javascript
  import _, { each, forEach } from 'lodash';
  ```

- 对应上面代码的`export`语句如下。

  ```javascript
  export default function (obj) {
    // ···
  }
  
  export function each(obj, iterator, context) {
    // ···
  }
  
  export { each as forEach };
  ```

- 上面代码的最后一行的意思是，暴露出`forEach`接口，默认指向`each`接口，即`forEach`和`each`指向同一个方法。

- `export default`也可以用来输出类。

  ```javascript
  // MyClass.js
  export default class { ... }
  
  // main.js
  import MyClass from 'MyClass';
  let o = new MyClass();
  ```

## export 与 import 的复合写法

- 如果在一个模块之中，先输入后输出同一个模块，`import`语句可以与`export`语句写在一起。

  ```javascript
  export { foo, bar } from 'my_module';
  
  // 可以简单理解为
  import { foo, bar } from 'my_module';
  export { foo, bar };
  ```

- 上面代码中，`export`和`import`语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，`foo`和`bar`实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致**当前模块不能直接使用`foo`和`bar`。**

- 模块的接口改名和整体输出，也可以采用这种写法。

  ```javascript
  // 接口改名
  export { foo as myFoo } from 'my_module';
  
  // 整体输出
  export * from 'my_module';
  ```

- 默认接口的写法如下。

  ```javascript
  export { default } from 'foo';
  ```

- 具名接口改为默认接口的写法如下。

  ```javascript
  export { es6 as default } from './someModule';
  
  // 等同于
  import { es6 } from './someModule';
  export default es6;
  ```

- 同样地，默认接口也可以改名为具名接口。

  ```javascript
  export { default as es6 } from './someModule';
  ```

- 下面三种`import`语句，没有对应的复合写法。

  ```javascript
  import * as someIdentifier from "someModule";
  import someIdentifier from "someModule";
  import someIdentifier, { namedIdentifier } from "someModule";
  ```

- 为了做到形式的对称，现在有[提案](https://github.com/leebyron/ecmascript-export-default-from)，提出补上这三种复合写法。

  ```javascript
  export * as someIdentifier from "someModule";
  export someIdentifier from "someModule";
  export someIdentifier, { namedIdentifier } from "someModule";
  ```

## 模块的继承

- 模块之间也可以继承。

- 假设有一个`circleplus`模块，继承了`circle`模块。

  ```javascript
  // circleplus.js
  
  export * from 'circle';
  export var e = 2.71828182846;
  export default function(x) {
    return Math.exp(x);
  }
  ```

- 上面代码中的`export *`，表示再输出`circle`模块的所有属性和方法。注意，`export *`命令会忽略`circle`模块的`default`方法。然后，上面代码又输出了自定义的`e`变量和默认方法。

- 这时，也可以将`circle`的属性或方法，改名后再输出。

  ```javascript
  // circleplus.js
  
  export { area as circleArea } from 'circle';
  ```

- 上面代码表示，只输出`circle`模块的`area`方法，且将其改名为`circleArea`。

- 加载上面模块的写法如下。

  ```javascript
  // main.js
  
  import * as math from 'circleplus';
  import exp from 'circleplus';
  console.log(exp(math.e));
  ```

- 上面代码中的`import exp`表示，将`circleplus`模块的默认方法加载为`exp`方法。

## 跨模块常量

- 本书介绍`const`命令的时候说过，`const`声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。

  ```javascript
  // constants.js 模块
  export const A = 1;
  export const B = 3;
  export const C = 4;
  
  // test1.js 模块
  import * as constants from './constants';
  console.log(constants.A); // 1
  console.log(constants.B); // 3
  
  // test2.js 模块
  import {A, B} from './constants';
  console.log(A); // 1
  console.log(B); // 3
  ```

- 如果要使用的常量非常多，可以建一个专门的`constants`目录，将各种常量写在不同的文件里面，保存在该目录下。

  ```javascript
  // constants/db.js
  export const db = {
    url: 'http://my.couchdbserver.local:5984',
    admin_username: 'admin',
    admin_password: 'admin password'
  };
  
  // constants/user.js
  export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];
  ```

- 然后，将这些文件输出的常量，合并在`index.js`里面。

  ```javascript
  // constants/index.js
  export {db} from './db';
  export {users} from './users';
  ```

- 使用的时候，直接加载`index.js`就可以了。

  ```javascript
  // script.js
  import {db, users} from './constants/index';
  ```

## import()

### 简介

- 前面介绍过，`import`命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（`import`命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。

  ```javascript
  // 报错
  if (x === 2) {
    import MyModual from './myModual';
  }
  ```

- 上面代码中，引擎处理`import`语句是在编译时，这时不会去分析或执行`if`语句，所以`import`语句放在`if`代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，`import`和`export`命令只能在模块的顶层，不能在代码块之中（比如，在`if`代码块之中，或在函数之中）。
- 这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，**条件加载**就不可能实现。如果`import`命令要取代 Node 的`require`方法，这就形成了一个障碍。因为`require`是运行时加载模块，`import`命令无法取代`require`的动态加载功能。

  ```javascript
  const path = './' + fileName;
  const myModual = require(path);
  ```

- 上面的语句就是动态加载，`require`到底加载哪一个模块，只有运行时才知道。`import`命令做不到这一点。

- 因此，有一个[提案](https://github.com/tc39/proposal-dynamic-import)，建议引入`import()`函数，完成动态加载。

  ```javascript
  import(specifier)
  ```

- 上面代码中，`import`函数的参数`specifier`，**指定所要加载的模块的位置**。`import`命令能够接受什么参数，`import()`函数就能接受什么参数，两者区别主要是后者为动态加载。

- `import()`返回一个 Promise 对象。下面是一个例子。

  ```javascript
  const main = document.querySelector('main');
  
  import(`./section-modules/${someVariable}.js`)
    .then(module => {
      module.loadPageInto(main);
    })
    .catch(err => {
      main.textContent = err.message;
    });
  ```

- `import()`函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，`import()`函数与所加载的模块没有静态连接关系，这点也是与`import`语句不相同。`import()`类似于 Node 的`require`方法，**区别主要是前者是异步加载，后者是同步加载。**

### 适用场合

（1）按需加载。

- `import()`可以在需要的时候，再加载某个模块。

  ```javascript
  button.addEventListener('click', event => {
    import('./dialogBox.js')
    .then(dialogBox => {
      dialogBox.open();
    })
    .catch(error => {
      /* Error handling */
    })
  });
  ```

- 上面代码中，`import()`方法放在`click`事件的监听函数之中，只有用户点击了按钮，才会加载这个模块

（2）条件加载

- `import()`可以放在`if`代码块，根据不同的情况，加载不同的模块。

  ```javascript
  if (condition) {
    import('moduleA').then(...);
  } else {
    import('moduleB').then(...);
  }
  ```

- 上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。

（3）动态的模块路径

- `import()`允许模块路径动态生成。

  ```javascript
  import(f())
  .then(...);
  ```

- 上面代码中，根据函数`f`的返回结果，加载不同的模块。

### 注意点

- `import()`加载模块成功以后，这个模块会作为一个对象，当作`then`方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。

  ```javascript
  import('./myModule.js')
  .then(({export1, export2}) => {
    // ...·
  });
  ```

- 上面代码中，`export1`和`export2`都是`myModule.js`的输出接口，可以解构获得。

- 如果模块有`default`输出接口，可以用参数直接获得。

  ```javascript
  import('./myModule.js')
  .then(myModule => {
    console.log(myModule.default);
  });
  ```

- 上面的代码也可以使用具名输入的形式。

  ```javascript
  import('./myModule.js')
  .then(({default: theDefault}) => {
    console.log(theDefault);
  });
  ```

- 如果想同时加载多个模块，可以采用下面的写法。

  ```javascript
  Promise.all([
    import('./module1.js'),
    import('./module2.js'),
    import('./module3.js'),
  ])
  .then(([module1, module2, module3]) => {
     ···
  });
  ```

- `import()`也可以用在 async 函数之中。

  ```javascript
  async function main() {
    const myModule = await import('./myModule.js');
    const {export1, export2} = await import('./myModule.js');
    const [module1, module2, module3] =
      await Promise.all([
        import('./module1.js'),
        import('./module2.js'),
        import('./module3.js'),
      ]);
  }
  main();
  ```

# 26. Module 的加载实现

## 浏览器加载

### 传统方法

- HTML 网页中，浏览器通过`<script>`标签加载 JavaScript 脚本。

  ```html
  <!-- 页面内嵌的脚本 -->
  <script type="application/javascript">
    // module code
  </script>
  
  <!-- 外部脚本 -->
  <script type="application/javascript" src="path/to/myModule.js">
  </script>
  ```

- 上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此`type="application/javascript"`可以省略。

- 默认情况下，浏览器是**同步**加载 JavaScript 脚本，即渲染引擎遇到`<script>`标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。

- 如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以**浏览器允许脚本异步加载**，下面就是两种异步加载的语法。

  ```html
  <script src="path/to/myModule.js" defer></script>
  <script src="path/to/myModule.js" async></script>
  ```

- 上面代码中，`<script>`标签打开`defer`或`async`属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。

- `defer`与`async`的区别是：`defer`要等到**整个页面**在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；`async`一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，`defer`是“渲染完再执行”，`async`是“下载完就执行”。另外，如果有多个`defer`脚本，会按照它们在页面出现的顺序加载，而多个`async`脚本是不能保证加载顺序的。

### 加载规则

- 浏览器加载 ES6 模块，也使用`<script>`标签，但是要加入`type="module"`属性。

  ```html
  <script type="module" src="./foo.js"></script>
  ```

- 上面代码在网页中插入一个模块`foo.js`，由于`type`属性设为`module`，所以浏览器知道这是一个 ES6 模块。

- 浏览器对于带有`type="module"`的`<script>`，都是**异步加载**，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了`<script>`标签的`defer`属性。

  ```html
  <script type="module" src="./foo.js"></script>
  <!-- 等同于 -->
  <script type="module" src="./foo.js" defer></script>
  ```

- 如果网页有多个`<script type="module">`，它们会按照在页面出现的顺序依次执行。

- \<script>标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。

- ```js
  <script type="module" src="./foo.js" async></script>
  ```

- 一旦使用了`async`属性，`<script type="module">`就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。

- ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。

  ```html
  <script type="module">
    import utils from "./utils.js";
  
    // other code
  </script>
  ```

- 对于外部的模块脚本（上例是`foo.js`），有几点需要注意。

  - 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。
  - 模块脚本自动采用严格模式，不管有没有声明`use strict`。
  - 模块之中，可以使用`import`命令加载其他模块（`.js`后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用`export`命令输出对外接口。
  - 模块之中，顶层的`this`关键字返回`undefined`，而不是指向`window`。也就是说，在模块顶层使用`this`关键字，是无意义的。
  - 同一个模块如果加载多次，将只执行一次。

- 下面是一个示例模块。

  ```javascript
  import utils from 'https://example.com/js/utils.js';
  
  const x = 1;
  
  console.log(x === window.x); //false
  console.log(this === undefined); // true
  ```

- 利用顶层的`this`等于`undefined`这个语法点，可以侦测当前代码是否在 ES6 模块之中。

  ```javascript
  const isNotModuleScript = this !== undefined;
  ```

## ES6 模块与 CommonJS 模块的差异

- 讨论 Node 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。
- 它们有两个**重大差异**。
  - CommonJS 模块输出的是一个**值的拷贝**，ES6 模块输出的是**值的引用**。
  - CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
- 第二个差异是因为 CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

- 下面重点解释第一个差异。

- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件`lib.js`的例子。

  ```javascript
  // lib.js
  var counter = 3;
  function incCounter() {
    counter++;
  }
  module.exports = {
    counter: counter,
    incCounter: incCounter,
  };
  ```

- 上面代码输出内部变量`counter`和改写这个变量的内部方法`incCounter`。然后，在`main.js`里面加载这个模块。

  ```javascript
  // main.js
  var mod = require('./lib');
  
  console.log(mod.counter);  // 3
  mod.incCounter();
  console.log(mod.counter); // 3
  ```

- 上面代码说明，`lib.js`模块加载以后，它的内部变化就影响不到输出的`mod.counter`了。这是因为`mod.counter`是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。

  ```javascript
  // lib.js
  var counter = 3;
  function incCounter() {
    counter++;
  }
  module.exports = {
    get counter() {
      return counter
    },
    incCounter: incCounter,
  };
  ```

- 上面代码中，输出的`counter`属性实际上是一个取值器函数。现在再执行`main.js`，就可以正确读取内部变量`counter`的变动了。

  ```bash
  $ node main.js
  3
  4
  ```

- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

- 还是举上面的例子。

  ```javascript
  // lib.js
  export let counter = 3;
  export function incCounter() {
    counter++;
  }
  
  // main.js
  import { counter, incCounter } from './lib';
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 4
  ```

- 上面代码说明，ES6 模块输入的变量`counter`是活的，完全反应其所在模块`lib.js`内部的变化。

- 再举一个出现在`export`一节中的例子。

  ```javascript
  // m1.js
  export var foo = 'bar';
  setTimeout(() => foo = 'baz', 500);
  
  // m2.js
  import {foo} from './m1.js';
  console.log(foo);
  setTimeout(() => console.log(foo), 500);
  ```

- 上面代码中，`m1.js`的变量`foo`，在刚加载时等于`bar`，过了 500 毫秒，又变为等于`baz`。

- 我们看看，`m2.js`能否正确读取这个变化。

  ```bash
  $ babel-node m2.js
  
  bar
  baz
  ```

- 上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。

- 由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。

  ```javascript
  // lib.js
  export let obj = {};
  
  // main.js
  import { obj } from './lib';
  
  obj.prop = 123; // OK
  obj = {}; // TypeError
  ```

- 上面代码中，`main.js`从`lib.js`输入变量`obj`，可以对`obj`添加属性，但是重新赋值就会报错。因为变量`obj`指向的地址是只读的，不能重新赋值，这就好比`main.js`创造了一个名为`obj`的`const`变量。

- 最后，`export`通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。

  ```javascript
  // mod.js
  function C() {
    this.sum = 0;
    this.add = function () {
      this.sum += 1;
    };
    this.show = function () {
      console.log(this.sum);
    };
  }
  
  export let c = new C();
  ```

- 上面的脚本`mod.js`，输出的是一个`C`的实例。不同的脚本加载这个模块，得到的都是同一个实例。

  ```javascript
  // x.js
  import {c} from './mod';
  c.add();
  
  // y.js
  import {c} from './mod';
  c.show();
  
  // main.js
  import './x';
  import './y';
  ```

- 现在执行`main.js`，输出的是`1`。

- ```bash
  $ babel-node main.js
  1
  ```

- 这就证明了`x.js`和`y.js`加载的都是`C`的同一个实例。

## Node 加载

### 概述

- Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS **采用各自的加载方案**。

- Node 要求 ES6 模块采用`.mjs`后缀文件名。也就是说，只要脚本文件里面使用`import`或者`export`命令，那么就必须采用`.mjs`后缀名。`require`命令不能加载`.mjs`文件，会报错，只有`import`命令才可以加载`.mjs`文件。反过来，`.mjs`文件里面也不能使用`require`命令，必须使用`import`。

- 目前，这项功能还在试验阶段。安装 Node v8.5.0 或以上版本，要用`--experimental-modules`参数才能打开该功能。

- ```js
  $ node --experimental-modules my-app.mjs
  ```

- 为了与浏览器的`import`加载规则相同，Node 的`.mjs`文件支持 URL 路径。

  ```javascript
  import './foo?query=1'; // 加载 ./foo 传入参数 ?query=1
  ```

- 上面代码中，脚本路径带有参数`?query=1`，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有`:`、`%`、`#`、`?`等特殊字符，最好对这些字符进行转义。

- 目前，Node 的`import`命令只支持加载本地模块（`file:`协议），不支持加载远程模块。

- 如果模块名不含路径，那么`import`命令会去`node_modules`目录寻找这个模块。

  ```javascript
  import 'baz';
  import 'abc/123';
  ```

- 如果模块名包含路径，那么`import`命令会按照路径去寻找这个名字的脚本文件。

  ```javascript
  import 'file:///etc/config/app.json';
  import './foo';
  import './foo?search';
  import '../bar';
  import '/baz';
  ```

- 如果脚本文件省略了后缀名，比如`import './foo'`，Node 会依次尝试四个后缀名：`./foo.mjs`、`./foo.js`、`./foo.json`、`./foo.node`。如果这些脚本文件都不存在，Node 就会去加载`./foo/package.json`的`main`字段指定的脚本。如果`./foo/package.json`不存在或者没有`main`字段，那么就会依次加载`./foo/index.mjs`、`./foo/index.js`、`./foo/index.json`、`./foo/index.node`。如果以上四个文件还是都不存在，就会抛出错误。

- 最后，Node 的`import`命令是异步加载，这一点与浏览器的处理方法相同。

### 内部变量

- ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。

- 首先，就是`this`关键字。ES6 模块之中，顶层的`this`指向`undefined`；CommonJS 模块的顶层`this`指向当前模块，这是两者的一个**重大差异**。

- 其次，以下这些顶层变量在 ES6 模块之中都是不存在的。

  - `arguments`
  - `require`
  - `module`
  - `exports`
  - `__filename`
  - `__dirname`

- 如果你一定要使用这些变量，有一个变通方法，就是写一个 CommonJS 模块输出这些变量，然后再用 ES6 模块加载这个 CommonJS 模块。但是这样一来，该 ES6 模块就不能直接用于浏览器环境了，所以不推荐这样做。

- ```javascript
  // expose.js
  module.exports = {__dirname};
  
  // use.mjs
  import expose from './expose.js';
  const {__dirname} = expose;
  ```

- 上面代码中，`expose.js`是一个 CommonJS 模块，输出变量`__dirname`，该变量在 ES6 模块之中不存在。ES6 模块加载`expose.js`，就可以得到`__dirname`。

### ES6 模块加载 CommonJS 模块

- CommonJS 模块的输出都定义在`module.exports`这个属性上面。Node 的`import`命令加载 CommonJS 模块，Node 会自动将`module.exports`属性，当作模块的默认输出，即等同于`export default xxx`。

- 下面是一个 CommonJS 模块。

  ```javascript
  // a.js
  module.exports = {
    foo: 'hello',
    bar: 'world'
  };
  
  // 等同于
  export default {
    foo: 'hello',
    bar: 'world'
  };
  ```

- `import`命令加载上面的模块，`module.exports`会被视为默认输出，即`import`命令实际上输入的是这样一个对象`{ default: module.exports }`。

- 所以，一共有三种写法，可以拿到 CommonJS 模块的`module.exports`。

  ```javascript
  // 写法一
  import baz from './a';
  // baz = {foo: 'hello', bar: 'world'};
  
  // 写法二
  import {default as baz} from './a';
  // baz = {foo: 'hello', bar: 'world'};
  
  // 写法三
  import * as baz from './a';
  // baz = {
  //   get default() {return module.exports;},
  //   get foo() {return this.default.foo}.bind(baz),
  //   get bar() {return this.default.bar}.bind(baz)
  // }
  ```

- 上面代码的第三种写法，可以通过`baz.default`拿到`module.exports`。`foo`属性和`bar`属性就是可以通过这种方法拿到了`module.exports`。

- 下面是一些例子。

  ```javascript
  // b.js
  module.exports = null;
  
  // es.js
  import foo from './b';
  // foo = null;
  
  import * as bar from './b';
  // bar = { default:null };
  ```

- 上面代码中，`es.js`采用第二种写法时，要通过`bar.default`这样的写法，才能拿到`module.exports`。

- ```javascript
  // c.js
  module.exports = function two() {
    return 2;
  };
  
  // es.js
  import foo from './c';
  foo(); // 2
  
  import * as bar from './c';
  bar.default(); // 2
  bar(); // throws, bar is not a function
  ```

- 上面代码中，`bar`本身是一个对象，不能当作函数调用，只能通过`bar.default`调用。

- CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。

  ```javascript
  // foo.js
  module.exports = 123;
  setTimeout(_ => module.exports = null);
  ```

- 上面代码中，对于加载`foo.js`的脚本，`module.exports`将一直是`123`，而不会变成`null`。

- 由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，所以采用`import`命令加载 CommonJS 模块时，不允许采用下面的写法。

  ```javascript
  // 不正确
  import { readFile } from 'fs';
  ```

- 上面的写法不正确，因为`fs`是 CommonJS 格式，只有在运行时才能确定`readFile`接口，而`import`命令要求编译时就确定这个接口。解决方法就是改为整体输入。

  ```javascript
  // 正确的写法一
  import * as express from 'express';
  const app = express.default();
  
  // 正确的写法二
  import express from 'express';
  const app = express();
  ```

### CommonJS 模块加载 ES6 模块

- CommonJS 模块加载 ES6 模块，不能使用`require`命令，而要使用`import()`函数。ES6 模块的所有输出接口，会成为输入对象的属性。

  ```javascript
  // es.mjs
  let foo = { bar: 'my-default' };
  export default foo;
  
  // cjs.js
  const es_namespace = await import('./es.mjs');
  // es_namespace = {
  //   get default() {
  //     ...
  //   }
  // }
  console.log(es_namespace.default);
  // { bar:'my-default' }
  ```

- 上面代码中，`default`接口变成了`es_namespace.default`属性。

- 下面是另一个例子

  ```javascript
  // es.js
  export let foo = { bar:'my-default' };
  export { foo as bar };
  export function f() {};
  export class c {};
  
  // cjs.js
  const es_namespace = await import('./es');
  // es_namespace = {
  //   get foo() {return foo;}
  //   get bar() {return foo;}
  //   get f() {return f;}
  //   get c() {return c;}
  // }
  ```

## 循环加载

- “循环加载”（circular dependency）指的是，`a`脚本的执行依赖`b`脚本，而`b`脚本的执行又依赖`a`脚本。

  ```javascript
  // a.js
  var b = require('b');
  
  // b.js
  var a = require('a');
  ```

- 通常，“循环加载”表示**存在强耦合**，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。

- 但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现`a`依赖`b`，`b`依赖`c`，`c`又依赖`a`这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。

- 对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。

### CommonJS 模块的加载原理

- 介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。

- CommonJS 的一个模块，就是一个脚本文件。`require`命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。

  ```javascript
  {
    id: '...',
    exports: { ... },
    loaded: true,
    ...
  }
  ```

- 上面代码就是 Node 内部加载模块后生成的一个对象。该对象的`id`属性是**模块名**，`exports`属性是模块输出的各个接口，`loaded`属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。

- 以后需要用到这个模块的时候，就会到`exports`属性上面取值。即使再次执行`require`命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，**CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存**。

### CommonJS 模块的循环加载

+ CommonJS 模块的重要特性是加载时执行，即脚本代码在`require`的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。

+ 让我们来看，Node [官方文档](https://nodejs.org/api/modules.html#modules_cycles)里面的例子。脚本文件`a.js`代码如下。

  ```javascript
  exports.done = false;
  var b = require('./b.js');
  console.log('在 a.js 之中，b.done = %j', b.done);
  exports.done = true;
  console.log('a.js 执行完毕');
  ```

+ 上面代码之中，`a.js`脚本先输出一个`done`变量，然后加载另一个脚本文件`b.js`。注意，此时`a.js`代码就停在这里，等待`b.js`执行完毕，再往下执行。

+ 再看`b.js`的代码。

  ```javascript
  exports.done = false;
  var a = require('./a.js');
  console.log('在 b.js 之中，a.done = %j', a.done);
  exports.done = true;
  console.log('b.js 执行完毕');
  ```
+ 上面代码之中，`b.js`执行到第二行，就会去加载`a.js`，这时，就发生了“循环加载”。系统会去`a.js`模块对应对象的`exports`属性取值，可是因为`a.js`还没有执行完，**从`exports`属性只能取回已经执行的部分，而不是最后的值。**

+ `a.js`已经执行的部分，只有一行。

  ```javascript
  exports.done = false;
  ```

+ 因此，对于`b.js`来说，它从`a.js`只输入一个变量`done`，值为`false`。
+ 然后，`b.js`接着往下执行，等到全部执行完毕，再把执行权交还给`a.js`。于是，`a.js`接着往下执行，直到执行完毕。我们写一个脚本`main.js`，验证这个过程。

+ ```javascript
  var a = require('./a.js');
  var b = require('./b.js');
  console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done);
  ```

+ 执行`main.js`，运行结果如下。

  ```bash
  $ node main.js
  
  在 b.js 之中，a.done = false
  b.js 执行完毕
  在 a.js 之中，b.done = true
  a.js 执行完毕
  在 main.js 之中, a.done=true, b.done=true
  ```

+ 上面的代码证明了两件事。一是，在`b.js`之中，`a.js`没有执行完毕，只执行了第一行。二是，`main.js`执行到第二行时，不会再次执行`b.js`，而是输出缓存的`b.js`的执行结果，即它的第四行。

  ```javascript
  exports.done = true;
  ```

+ 总之，CommonJS 输入的是被输出值的拷贝，不是引用。

+ 另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。

  ```javascript
  var a = require('a'); // 安全的写法
  var foo = require('a').foo; // 危险的写法
  
  exports.good = function (arg) {
    return a.foo('good', arg); // 使用的是 a.foo 的最新值
  };
  
  exports.bad = function (arg) {
    return foo('bad', arg); // 使用的是一个部分加载时的值
  };
  ```

+ 上面代码中，如果发生循环加载，`require('a').foo`的值很可能后面会被改写，改用`require('a')`会更保险一点。

### ES6 模块的循环加载

+ ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用`import`从一个模块加载变量（即`import foo from 'foo'`），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。

+ 请看下面这个例子

  ```javascript
  // a.mjs
  import {bar} from './b';
  console.log('a.mjs');
  console.log(bar);
  export let foo = 'foo';
  
  // b.mjs
  import {foo} from './a';
  console.log('b.mjs');
  console.log(foo);
  export let bar = 'bar';
  ```

+ 上面代码中，`a.mjs`加载`b.mjs`，`b.mjs`又加载`a.mjs`，构成循环加载。执行`a.mjs`，结果如下。

+ ```bash
  $ node --experimental-modules a.mjs
  b.mjs
  ReferenceError: foo is not defined
  ```

+ 上面代码中，执行`a.mjs`以后会报错，`foo`变量未定义，这是为什么？

  

+ 让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行`a.mjs`以后，引擎发现它加载了`b.mjs`，因此会**优先执行`b.mjs`，**然后再执行`a.mjs`。接着，执行`b.mjs`的时候，已知它从`a.mjs`输入了`foo`接口，这时不会去执行`a.mjs`，而是认为这个接口已经存在了，继续往下执行。执行到第三行`console.log(foo)`的时候，才发现这个接口根本没定义，因此报错。



+ 解决这个问题的方法，就是让`b.mjs`运行的时候，`foo`已经有定义了。这可以通过将`foo`写成函数来解决。

  ```javascript
  // a.mjs
  import {bar} from './b';
  console.log('a.mjs');
  console.log(bar());
  function foo() { return 'foo' }
  export {foo};
  
  // b.mjs
  import {foo} from './a';
  console.log('b.mjs');
  console.log(foo());
  function bar() { return 'bar' }
  export {bar};
  ```

+ 这时再执行`a.mjs`就可以得到预期结果。

  ```bash
  $ node --experimental-modules a.mjs
  b.mjs
  foo
  a.mjs
  bar
  ```

+ 这是因为函数具有提升作用，在执行`import {bar} from './b'`时，函数`foo`就已经有定义了，所以`b.mjs`加载的时候不会报错。这也意味着，如果把函数`foo`改写成函数表达式，也会报错。

  ```javascript
  // a.mjs
  import {bar} from './b';
  console.log('a.mjs');
  console.log(bar());
  const foo = () => 'foo';
  export {foo};
  ```

+ 上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。

+ 我们再来看 ES6 模块加载器[SystemJS](https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md)给出的一个例子。

  ```javascript
  // even.js
  import { odd } from './odd'
  export var counter = 0;
  export function even(n) {
    counter++;
    return n === 0 || odd(n - 1);
  }
  
  // odd.js
  import { even } from './even';
  export function odd(n) {
    return n !== 0 && even(n - 1);
  }
  ```

+ 上面代码中，`even.js`里面的函数`even`有一个参数`n`，只要不等于 0，就会减去 1，传入加载的`odd()`。`odd.js`也会做类似操作。

+ 运行上面这段代码，结果如下。

  ```javascript
  $ babel-node
  > import * as m from './even.js';
  > m.even(10);
  true
  > m.counter
  6
  > m.even(20)
  true
  > m.counter
  17
  ```

+ 上面代码中，参数`n`从 10 变为 0 的过程中，`even()`一共会执行 6 次，所以变量`counter`等于 6。第二次调用`even()`时，参数`n`从 20 变为 0，`even()`一共会执行 11 次，加上前面的 6 次，所以变量`counter`等于 17。

+ 这个例子要是改写成 CommonJS，就根本无法执行，会报错。

  ```javascript
  // even.js
  var odd = require('./odd');
  var counter = 0;
  exports.counter = counter;
  exports.even = function (n) {
    counter++;
    return n == 0 || odd(n - 1);
  }
  
  // odd.js
  var even = require('./even').even;
  module.exports = function (n) {
    return n != 0 && even(n - 1);
  }
  ```

+ 上面代码中，`even.js`加载`odd.js`，而`odd.js`又去加载`even.js`，形成“循环加载”。这时，执行引擎就会输出`even.js`已经执行的部分（不存在任何结果），所以在`odd.js`之中，变量`even`等于`undefined`，等到后面调用`even(n - 1)`就会报错。

  ```bash
  $ node
  > var m = require('./even');
  > m.even(10)
  TypeError: even is not a function
  ```

## ES6 模块的转码

+ 浏览器目前还不支持 ES6 模块，为了现在就能使用，可以将其转为 ES5 的写法。除了 Babel 可以用来转码之外，还有以下两个方法，也可以用来转码。

### ES6 module transpiler

+ [ES6 module transpiler](https://github.com/esnext/es6-module-transpiler)是 square 公司开源的一个转码器，可以将 ES6 模块转为 CommonJS 模块或 AMD 模块的写法，从而在浏览器中使用。

+ 首先，安装这个转码器。

  ```bash
  $ npm install -g es6-module-transpiler
  ```

+ 然后，使用`compile-modules convert`命令，将 ES6 模块文件转码。

  ```bash
  $ compile-modules convert file1.js file2.js
  ```

+ `-o`参数可以指定转码后的文件名。

  ```bash
  $ compile-modules convert -o out.js file1.js
  ```

### SystemJS

+ 另一种解决方法是使用 [SystemJS](https://github.com/systemjs/systemjs)。它是一个垫片库（polyfill），可以在浏览器内加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式。它在后台调用的是 Google 的 Traceur 转码器。

+ 使用时，先在网页内载入`system.js`文件。

  ```html
  <script src="system.js"></script>
  ```

+ 然后，使用`System.import`方法加载模块文件。

  ```html
  <script>
    System.import('./app.js');
  </script>
  ```

+ 上面代码中的`./app`，指的是当前目录下的 app.js 文件。它可以是 ES6 模块文件，`System.import`会自动将其转码。

+ 需要注意的是，`System.import`使用异步加载，返回一个 Promise 对象，可以针对这个对象编程。下面是一个模块文件。

  ```javascript
  // app/es6-file.js:
  
  export class q {
    constructor() {
      this.es6 = 'hello';
    }
  }
  ```

+ 然后，在网页内加载这个模块文件。

  ```html
  <script>
  
  System.import('app/es6-file').then(function(m) {
    console.log(new m.q().es6); // hello
  });
  
  </script>
  ```

+ 上面代码中，`System.import`方法返回的是一个 Promise 对象，所以可以用`then`方法指定回调函数。

# 27. 编程风格

+ 下面的内容主要参考了 [Airbnb](https://github.com/airbnb/javascript) 公司的 JavaScript 风格规范。

## 块级作用域

### let 取代 var

+ ES6 提出了两个新的声明变量的命令：`let`和`const`。其中，`let`完全可以取代`var`，因为两者语义相同，而且`let`没有副作用。

  ```javascript
  'use strict';
  
  if (true) {
    let x = 'hello';
  }
  
  for (let i = 0; i < 10; i++) {
    console.log(i);
  }
  ```

+ 上面代码如果用`var`替代`let`，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，`var`命令做不到这一点。

+ `var`命令存在变量提升效用，`let`命令没有这个问题。

  ```javascript
  'use strict';
  
  if (true) {
    console.log(x); // ReferenceError
    let x = 'hello';
  }
  ```

+ 上面代码如果使用`var`替代`let`，`console.log`那一行就不会报错，而是会输出`undefined`，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。

+ 所以，建议不再使用`var`命令，而是使用`let`命令取代。

### 全局常量和线程安全

+ 在`let`和`const`之间，建议优先使用`const`，尤其是在全局环境，不应该设置变量，只应设置常量。
+ `const`优于`let`有几个**原因**。
  + 一个是`const`可以提醒阅读程序的人，这个变量不应该改变；
  + 另一个是`const`比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；
  + 最后一个原因是 JavaScript 编译器会对`const`进行优化，所以多使用`const`，有利于提高程序的运行效率，也就是说`let`和`const`的本质区别，其实是编译器内部的处理不同。

+ ```javascript
  // bad
  var a = 1, b = 2, c = 3;
  
  // good
  const a = 1;
  const b = 2;
  const c = 3;
  
  // best
  const [a, b, c] = [1, 2, 3];
  ```

+ `const`声明常量还有两个**好处**
  + 一是阅读代码的人立刻会意识到不应该修改这个值
  + 二是防止了无意间修改变量值所导致的错误。

+ 所有的函数都应该设置为常量。
+ 长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时`let`表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。

## 字符串

+ **静态字符串**一律使用单引号或反引号，**不使用双引号**。**动态字符串**使用反引号。

  ```javascript
  // bad
  const a = "foobar";
  const b = 'foo' + a + 'bar';
  
  // acceptable
  const c = `foobar`;
  
  // good
  const a = 'foobar';
  const b = `foo${a}bar`;
  ```

## 解构赋值

+ 使用数组成员对变量赋值时，优先使用解构赋值。

  ```javascript
  const arr = [1, 2, 3, 4];
  
  // bad
  const first = arr[0];
  const second = arr[1];
  
  // good
  const [first, second] = arr;
  ```

+ 函数的参数如果是对象的成员，优先使用解构赋值。

  ```javascript
  // bad
  function getFullName(user) {
    const firstName = user.firstName;
    const lastName = user.lastName;
  }
  
  // good
  function getFullName(obj) {
    const { firstName, lastName } = obj;
  }
  
  // best
  function getFullName({ firstName, lastName }) {
  }
  ```

+ 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。

  ```javascript
  // bad
  function processInput(input) {
    return [left, right, top, bottom];
  }
  
  // good
  function processInput(input) {
    return { left, right, top, bottom };
  }
  
  const { left, right } = processInput(input);
  ```

## 对象

+ 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。

  ```javascript
  // bad
  const a = { k1: v1, k2: v2, };
  const b = {
    k1: v1,
    k2: v2
  };
  
  // good
  const a = { k1: v1, k2: v2 };
  const b = {
    k1: v1,
    k2: v2,
  };
  ```

+ 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用`Object.assign`方法。

  ```javascript
  // bad
  const a = {};
  a.x = 3;
  
  // if reshape unavoidable
  const a = {};
  Object.assign(a, { x: 3 });
  
  // good
  const a = { x: null };
  a.x = 3;
  ```

+ 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。

  ```javascript
  // bad
  const obj = {
    id: 5,
    name: 'San Francisco',
  };
  obj[getKey('enabled')] = true;
  
  // good
  const obj = {
    id: 5,
    name: 'San Francisco',
    [getKey('enabled')]: true,
  };
  ```

+ 上面代码中，对象`obj`的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建`obj`的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。

+ 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。

  ```javascript
  var ref = 'some value';
  
  // bad
  const atom = {
    ref: ref,
  
    value: 1,
  
    addValue: function (value) {
      return atom.value + value;
    },
  };
  
  // good
  const atom = {
    ref,
  
    value: 1,
  
    addValue(value) {
      return atom.value + value;
    },
  };
  ```

## 数组

+ 使用扩展运算符（...）拷贝数组。

  ```javascript
  // bad
  const len = items.length;
  const itemsCopy = [];
  let i;
  
  for (i = 0; i < len; i++) {
    itemsCopy[i] = items[i];
  }
  
  // good
  const itemsCopy = [...items];
  ```

+ 使用 Array.from 方法，将类似数组的对象转为数组。

  ```javascript
  const foo = document.querySelectorAll('.foo');
  const nodes = Array.from(foo);
  ```

## 函数 

+ 立即执行函数可以写成箭头函数的形式。

  ```javascript
  (() => {
    console.log('Welcome to the Internet.');
  })();
  ```

+ 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。

  ```javascript
  // bad
  [1, 2, 3].map(function (x) {
    return x * x;
  });
  
  // good
  [1, 2, 3].map((x) => {
    return x * x;
  });
  
  // best
  [1, 2, 3].map(x => x * x);
  ```

+ 箭头函数取代`Function.prototype.bind`，不应再用 self/_this/that 绑定 this。

  ```javascript
  // bad
  const self = this;
  const boundMethod = function(...params) {
    return method.apply(self, params);
  }
  
  // acceptable
  const boundMethod = method.bind(this);
  
  // best
  const boundMethod = (...params) => method.apply(this, params);
  ```

+ 简单的、单行的、不会复用的函数，建议采用箭头函数。**如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。**

+ 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。

  ```javascript
  // bad
  function divide(a, b, option = false ) {
  }
  
  // good
  function divide(a, b, { option = false } = {}) {
  }
  ```

+ 不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替。因为 rest 运算符**显式表明**你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。

  ```javascript
  // bad
  function concatenateAll() {
    const args = Array.prototype.slice.call(arguments);
    return args.join('');
  }
  
  // good
  function concatenateAll(...args) {
    return args.join('');
  }
  ```

+ 使用默认值语法设置函数参数的默认值。

  ```javascript
  // bad
  function handleThings(opts) {
    opts = opts || {};
  }
  
  // good
  function handleThings(opts = {}) {
    // ...
  }
  ```

## Map 结构

+ 注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要`key: value`的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。

  ```javascript
  let map = new Map(arr);
  
  for (let key of map.keys()) {
    console.log(key);
  }
  
  for (let value of map.values()) {
    console.log(value);
  }
  
  for (let item of map.entries()) {
    console.log(item[0], item[1]);
  }
  ```

## Class 

+ 总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。

  ```javascript
  // bad
  function Queue(contents = []) {
    this._queue = [...contents];
  }
  Queue.prototype.pop = function() {
    const value = this._queue[0];
    this._queue.splice(0, 1);
    return value;
  }
  
  // good
  class Queue {
    constructor(contents = []) {
      this._queue = [...contents];
    }
    pop() {
      const value = this._queue[0];
      this._queue.splice(0, 1);
      return value;
    }
  }
  ```

+ 使用`extends`实现继承，因为这样更简单，不会有破坏`instanceof`运算的危险。

  ```javascript
  // bad
  const inherits = require('inherits');
  function PeekableQueue(contents) {
    Queue.apply(this, contents);
  }
  inherits(PeekableQueue, Queue);
  PeekableQueue.prototype.peek = function() {
    return this._queue[0];
  }
  
  // good
  class PeekableQueue extends Queue {
    peek() {
      return this._queue[0];
    }
  }
  ```

## 模块

+ 首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用`import`取代`require`。

  ```javascript
  // bad
  const moduleA = require('moduleA');
  const func1 = moduleA.func1;
  const func2 = moduleA.func2;
  
  // good
  import { func1, func2 } from 'moduleA';
  ```

+ 使用`export`取代`module.exports`。

  ```javascript
  // commonJS的写法
  var React = require('react');
  
  var Breadcrumbs = React.createClass({
    render() {
      return <nav />;
    }
  });
  
  module.exports = Breadcrumbs;
  
  // ES6的写法
  import React from 'react';
  
  class Breadcrumbs extends React.Component {
    render() {
      return <nav />;
    }
  };
  
  export default Breadcrumbs;
  ```

+ 如果模块只有一个输出值，就使用`export default`，如果模块有多个输出值，就不使用`export default`，`export default`与普通的`export`不要同时使用。

+ 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。

  ```javascript
  // bad
  import * as myObject from './importModule';
  
  // good
  import myObject from './importModule';
  ```

+ 如果模块默认输出一个函数，函数名的首字母应该小写。

  ```javascript
  function makeStyleGuide() {
  }
  
  export default makeStyleGuide;
  ```

+ 如果模块默认输出一个对象，对象名的首字母应该大写。

  ```javascript
  const StyleGuide = {
    es6: {
    }
  };
  
  export default StyleGuide;
  ```

## ESLint 的使用 

+ ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。

  首先，安装 ESLint。

  ```bash
  $ npm i -g eslint
  ```

+ 然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。

+ ```bash
  $ npm i -g eslint-config-airbnb
  $ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react
  ```

+ 最后，在项目的根目录下新建一个`.eslintrc`文件，配置 ESLint。

  ```javascript
  {
    "extends": "eslint-config-airbnb"
  }
  ```

+ 现在就可以检查，当前项目的代码是否符合预设的规则。

+ `index.js`文件的代码如下。

  ```javascript
  var unusued = 'I have no purpose!';
  
  function greet() {
      var message = 'Hello, World!';
      alert(message);
  }
  
  greet();
  ```

+ 使用 ESLint 检查这个文件，就会报出错误。

  ```bash
  $ eslint index.js
  index.js
    1:1  error  Unexpected var, use let or const instead          no-var
    1:5  error  unusued is defined but never used                 no-unused-vars
    4:5  error  Expected indentation of 2 characters but found 4  indent
    4:5  error  Unexpected var, use let or const instead          no-var
    5:5  error  Expected indentation of 2 characters but found 4  indent
  
  ✖ 5 problems (5 errors, 0 warnings)
  ```

+ 上面代码说明，原文件有五个错误，其中两个是不应该使用`var`命令，而要使用`let`或`const`；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。

# 28. 读懂 ECMAScript 规格

## 概述 

+ 规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。
+ 一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。
+ 这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。
+ 本章介绍如何读懂 ECMAScript 6 的规格文件。
+ ECMAScript 6 的规格，可以在 ECMA 国际标准组织的官方网站（[www.ecma-international.org/ecma-262/6.0/](http://www.ecma-international.org/ecma-262/6.0/)）免费下载和在线阅读。

+ 这个规格文件相当庞大，一共有 26 章，A4 打印的话，足足有 545 页。它的特点就是规定得非常细致，每一个语法行为、每一个函数的实现都做了详尽的清晰的描述。基本上，编译器作者只要把每一步翻译成代码就可以了。这很大程度上，保证了所有 ES6 实现都有一致的行为。
+ ECMAScript 6 规格的 26 章之中，第 1 章到第 3 章是对文件本身的介绍，与语言关系不大。第 4 章是对这门语言总体设计的描述，有兴趣的读者可以读一下。第 5 章到第 8 章是语言宏观层面的描述。第 5 章是规格的名词解释和写法的介绍，第 6 章介绍数据类型，第 7 章介绍语言内部用到的抽象操作，第 8 章介绍代码如何运行。第 9 章到第 26 章介绍具体的语法。
+ 对于一般用户来说，除了第 4 章，其他章节都涉及某一方面的细节，不用通读，只要在用到的时候，查阅相关章节即可。

## 术语

+ ES6 规格使用了一些专门的术语，了解这些术语，可以帮助你读懂规格。本节介绍其中的几个。

### 抽象操作

+ 所谓“抽象操作”（abstract operations）就是引擎的一些内部方法，外部不能调用。规格定义了一系列的抽象操作，规定了它们的行为，留给各种引擎自己去实现。

+ 举例来说，`Boolean(value)`的算法，第一步是这样的。

  > 1. Let `b` be `ToBoolean(value)`.

+ 这里的`ToBoolean`就是一个抽象操作，是引擎内部求出布尔值的算法。

+ 许多函数的算法都会多次用到同样的步骤，所以 ES6 规格将它们抽出来，定义成“抽象操作”，方便描述。

### Record 和 field

+ ES6 规格将键值对（key-value map）的**数据结构**称为 Record，其中的每一组键值对称为 field。这就是说，一个 Record 由多个 field 组成，而每个 field 都包含一个键名（key）和一个键值（value）。

### [[Notation]]

+ ES6 规格大量使用`[[Notation]]`这种**书写法**，比如`[[Value]]`、`[[Writable]]`、`[[Get]]`、`[[Set]]`等等。它用来指代 field 的键名。

+ 举例来说，`obj`是一个 Record，它有一个`Prototype`属性。ES6 规格不会写`obj.Prototype`，而是写`obj.[[Prototype]]`。一般来说，使用`[[Notation]]`这种书写法的属性，都是对象的内部属性。

+ 所有的 JavaScript 函数都有一个内部属性`[[Call]]`，用来运行该函数。

  ```javascript
  F.[[Call]](V, argumentsList)
  ```

+ 上面代码中，`F`是一个函数对象，`[[Call]]`是它的内部方法，`F.[[call]]()`表示运行该函数，`V`表示`[[Call]]`运行时`this`的值，`argumentsList`则是调用时传入函数的参数。

### Completion Record

+ 每一个语句都会返回一个 Completion Record，表示运行结果。每个 Completion Record 有一个`[[Type]]`属性，表示运行结果的类型。

  `[[Type]]`属性有五种可能的值。

  - normal
  - return
  - throw
  - break
  - continue

+ 如果`[[Type]]`的值是`normal`，就称为 normal completion，表示运行正常。其他的值，都称为 abrupt completion。其中，开发者只需要关注`[[Type]]`为`throw`的情况，即运行出错；`break`、`continue`、`return`这三个值都只出现在特定场景，可以不用考虑。

## 抽象操作的标准流程

+ 抽象操作的运行流程，一般是下面这样。

  > 1. Let `resultCompletionRecord` be `AbstractOp()`.
  > 2. If `resultCompletionRecord` is an abrupt completion, return `resultCompletionRecord`.
  > 3. Let `result` be `resultCompletionRecord.[[Value]]`.
  > 4. return `result`.

+ 上面的第一步是调用抽象操作`AbstractOp()`，得到`resultCompletionRecord`，这是一个 Completion Record。第二步，如果这个 Record 属于 abrupt completion，就将`resultCompletionRecord`返回给用户。如果此处没有返回，就表示运行结果正常，所得的值存放在`resultCompletionRecord.[[Value]]`属性。第三步，将这个值记为`result`。第四步，将`result`返回给用户。

+ ES6 规格将这个标准流程，使用简写的方式表达。

  > 1. Let `result` be `AbstractOp()`.
  > 2. `ReturnIfAbrupt(result)`.
  > 3. return `result`.

+ 这个简写方式里面的`ReturnIfAbrupt(result)`，就代表了上面的第二步和第三步，即如果有报错，就返回错误，否则取出值。

  甚至还有进一步的简写格式。

  > 1. Let `result` be `? AbstractOp()`.
  > 2. return `result`.

+ 上面流程的`?`，就代表`AbstractOp()`可能会报错。一旦报错，就返回错误，否则取出值。

+ 除了`?`，ES 6 规格还使用另一个简写符号`!`。

  > 1. Let `result` be `! AbstractOp()`.
  > 2. return `result`.

+ 上面流程的`!`，代表`AbstractOp()`不会报错，返回的一定是 normal completion，总是可以取出值。

## 相等运算符

+ 下面通过一些例子，介绍如何使用这份规格。
+ 相等运算符（`==`）是一个很让人头痛的运算符，它的语法行为多变，不符合直觉。这个小节就看看规格怎么规定它的行为。
+ 请看下面这个表达式，请问它的值是多少。

+ ```javascript
  0 == null
  ```

+ 如果你不确定答案，或者想知道语言内部怎么处理，就可以去查看规格，[7.2.12 小节](http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-equality-comparison)是对相等运算符（`==`）的描述。

+ 规格对每一种语法行为的描述，都分成两部分：先是总体的行为描述，然后是实现的算法细节。相等运算符的总体描述，只有一句话。

+ > “The comparison `x == y`, where `x` and `y` are values, produces `true` or `false`.”

+ 上面这句话的意思是，相等运算符用于比较两个值，返回`true`或`false`。

+ 下面是算法细节。

  > 1. ReturnIfAbrupt(x).
  > 2. ReturnIfAbrupt(y).
  > 3. If `Type(x)` is the same as `Type(y)`, then Return the result of performing Strict Equality  Comparison `x === y`.
  > 4. If `x` is `null` and `y` is `undefined`, return `true`.
  > 5. If `x` is `undefined` and `y` is `null`, return `true`.
  > 6. If `Type(x)` is Number and `Type(y)` is String, return the result of the comparison `x == ToNumber(y)`.
  > 7. If `Type(x)` is String and `Type(y)` is Number, return the result of the comparison `ToNumber(x) == y`.
  > 8. If `Type(x)` is Boolean, return the result of the comparison `ToNumber(x) == y`.
  > 9. If `Type(y)` is Boolean, return the result of the comparison `x == ToNumber(y)`.
  > 10. If `Type(x)` is either String, Number, or Symbol and `Type(y)`is Object, then return the result of the comparison `x == ToPrimitive(y)`.
  > 11. If `Type(x)` is Object and `Type(y)` is either String, Number, or Symbol, then return the result of the comparison `ToPrimitive(x) == y`.
  > 12. Return `false`.

+ 上面这段算法，一共有 12 步，翻译如下。

  > 1. 如果`x`不是正常值（比如抛出一个错误），中断执行。
  > 2. 如果`y`不是正常值，中断执行。
  > 3. 如果`Type(x)`与`Type(y)`相同，执行严格相等运算`x === y`。
  > 4. 如果`x`是`null`，`y`是`undefined`，返回`true`。
  > 5. 如果`x`是`undefined`，`y`是`null`，返回`true`。
  > 6. 如果`Type(x)`是数值，`Type(y)`是字符串，返回`x == ToNumber(y)`的结果。
  > 7. 如果`Type(x)`是字符串，`Type(y)`是数值，返回`ToNumber(x) == y`的结果。
  > 8. 如果`Type(x)`是布尔值，返回`ToNumber(x) == y`的结果。
  > 9. 如果`Type(y)`是布尔值，返回`x == ToNumber(y)`的结果。
  > 10. 如果`Type(x)`是字符串或数值或`Symbol`值，`Type(y)`是对象，返回`x == ToPrimitive(y)`的结果。
  > 11. 如果`Type(x)`是对象，`Type(y)`是字符串或数值或`Symbol`值，返回`ToPrimitive(x) == y`的结果。
  > 12. 返回`false`。

+ 由于`0`的类型是数值，`null`的类型是 Null（这是规格[4.3.13 小节](http://www.ecma-international.org/ecma-262/6.0/#sec-terms-and-definitions-null-type)的规定，是内部 Type 运算的结果，跟`typeof`运算符无关）。因此上面的前 11 步都得不到结果，要到第 12 步才能得到`false`。

  ```javascript
  0 == null // false
  ```

## 数组的空位

+ 下面再看另一个例子。

  ```javascript
  const a1 = [undefined, undefined, undefined];
  const a2 = [, , ,];
  
  a1.length // 3
  a2.length // 3
  
  a1[0] // undefined
  a2[0] // undefined
  
  a1[0] === a2[0] // true
  ```

+ 上面代码中，数组`a1`的成员是三个`undefined`，数组`a2`的成员是三个空位。这两个数组很相似，长度都是 3，每个位置的成员读取出来都是`undefined`。

+ 但是，它们实际上存在重大差异。

  ```javascript
  0 in a1 // true
  0 in a2 // false
  
  a1.hasOwnProperty(0) // true
  a2.hasOwnProperty(0) // false
  
  Object.keys(a1) // ["0", "1", "2"]
  Object.keys(a2) // []
  
  a1.map(n => 1) // [1, 1, 1]
  a2.map(n => 1) // [, , ,]
  ```

+ 上面代码一共列出了四种运算，数组`a1`和`a2`的结果都不一样。前三种运算（`in`运算符、数组的`hasOwnProperty`方法、`Object.keys`方法）都说明，数组`a2`取不到属性名。最后一种运算（数组的`map`方法）说明，数组`a2`没有发生遍历。

+ 为什么`a1`与`a2`成员的行为不一致？数组的成员是`undefined`或空位，到底有什么不同？

  规格的[12.2.5 小节《数组的初始化》](http://www.ecma-international.org/ecma-262/6.0/#sec-array-initializer)给出了答案。

  > “Array elements may be elided at the beginning, middle or end of the element list. Whenever a comma in the element list is not preceded by an AssignmentExpression (i.e., a comma at the beginning or after another comma), the missing array element contributes to the length of the Array and increases the index of subsequent elements. Elided array elements are not defined. If an element is elided at the end of an array, that element does not contribute to the length of the Array.”

+ 翻译如下。

  > "数组成员可以省略。只要逗号前面没有任何表达式，数组的`length`属性就会加 1，并且相应增加其后成员的位置索引。被省略的成员不会被定义。如果被省略的成员是数组最后一个成员，则不会导致数组`length`属性增加。”

+ 上面的规格说得很清楚，数组的空位会反映在`length`属性，也就是说空位有自己的位置，但是这个位置的值是未定义，即这个值是不存在的。如果一定要读取，结果就是`undefined`（因为`undefined`在 JavaScript 语言中表示不存在）。
+ 这就解释了为什么`in`运算符、数组的`hasOwnProperty`方法、`Object.keys`方法，都取不到空位的属性名。因为这个属性名根本就不存在，规格里面没说要为空位分配属性名(位置索引），只说要为下一个元素的位置索引加 1。
+ 至于为什么数组的`map`方法会跳过空位，请看下一节。

## 数组的 map 方法

+ 规格的[22.1.3.15 小节](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.map)定义了数组的`map`方法。该小节先是总体描述`map`方法的行为，里面没有提到数组空位。

+ 后面的算法描述是这样的。

  > 1. Let `O` be `ToObject(this value)`.
  > 2. `ReturnIfAbrupt(O)`.
  > 3. Let `len` be `ToLength(Get(O, "length"))`.
  > 4. `ReturnIfAbrupt(len)`.
  > 5. If `IsCallable(callbackfn)` is `false`, throw a TypeError exception.
  > 6. If `thisArg` was supplied, let `T` be `thisArg`; else let `T` be `undefined`.
  > 7. Let `A` be `ArraySpeciesCreate(O, len)`.
  > 8. `ReturnIfAbrupt(A)`.
  > 9. Let `k` be 0.
  > 10. Repeat, while `k` < `len`
  >     1. Let `Pk` be `ToString(k)`.
  >     2. Let `kPresent` be `HasProperty(O, Pk)`.
  >     3. `ReturnIfAbrupt(kPresent)`.
  >     4. If `kPresent` is `true`, then
  >        1. Let `kValue` be `Get(O, Pk)`.
  >        2. `ReturnIfAbrupt(kValue)`.
  >        3. Let `mappedValue` be `Call(callbackfn, T, «kValue, k, O»)`.
  >        4. `ReturnIfAbrupt(mappedValue)`.
  >        5. Let `status` be `CreateDataPropertyOrThrow (A, Pk, mappedValue)`.
  >        6. `ReturnIfAbrupt(status)`.
  >     5. Increase `k` by 1.
  > 11. Return `A`.

+ 翻译如下。

  > 1. 得到当前数组的`this`对象
  > 2. 如果报错就返回
  > 3. 求出当前数组的`length`属性
  > 4. 如果报错就返回
  > 5. 如果 map 方法的参数`callbackfn`不可执行，就报错
  > 6. 如果 map 方法的参数之中，指定了`this`，就让`T`等于该参数，否则`T`为`undefined`
  > 7. 生成一个新的数组`A`，跟当前数组的`length`属性保持一致
  > 8. 如果报错就返回
  > 9. 设定`k`等于 0
  > 10. 只要`k`小于当前数组的`length`属性，就重复下面步骤
  >     1. 设定`Pk`等于`ToString(k)`，即将`K`转为字符串
  >     2. 设定`kPresent`等于`HasProperty(O, Pk)`，即求当前数组有没有指定属性
  >     3. 如果报错就返回
  >     4. 如果`kPresent`等于`true`，则进行下面步骤
  >        1. 设定`kValue`等于`Get(O, Pk)`，取出当前数组的指定属性
  >        2. 如果报错就返回
  >        3. 设定`mappedValue`等于`Call(callbackfn, T, «kValue, k, O»)`，即执行回调函数
  >        4. 如果报错就返回
  >        5. 设定`status`等于`CreateDataPropertyOrThrow (A, Pk, mappedValue)`，即将回调函数的值放入`A`数组的指定位置
  >        6. 如果报错就返回
  >     5. `k`增加 1
  > 11. 返回`A`

+ 仔细查看上面的算法，可以发现，当处理一个全是空位的数组时，前面步骤都没有问题。进入第 10 步中第 2 步时，`kPresent`会报错，因为空位对应的属性名，对于数组来说是不存在的，因此就会返回，不会进行后面的步骤。

  ```javascript
  const arr = [, , ,];
  arr.map(n => {
    console.log(n);
    return 1;
  }) // [, , ,]
  ```

+ 上面代码中，`arr`是一个全是空位的数组，`map`方法遍历成员时，发现是空位，就直接跳过，不会进入回调函数。因此，回调函数里面的`console.log`语句根本不会执行，整个`map`方法返回一个全是空位的新数组。

+ V8 引擎对`map`方法的[实现](https://github.com/v8/v8/blob/44c44521ae11859478b42004f57ea93df52526ee/src/js/array.js#L1347)如下，可以看到跟规格的算法描述完全一致。

  ```javascript
  function ArrayMap(f, receiver) {
    CHECK_OBJECT_COERCIBLE(this, "Array.prototype.map");
  
    // Pull out the length so that modifications to the length in the
    // loop will not affect the looping and side effects are visible.
    var array = TO_OBJECT(this);
    var length = TO_LENGTH_OR_UINT32(array.length);
    return InnerArrayMap(f, receiver, array, length);
  }
  
  function InnerArrayMap(f, receiver, array, length) {
    if (!IS_CALLABLE(f)) throw MakeTypeError(kCalledNonCallable, f);
  
    var accumulator = new InternalArray(length);
    var is_array = IS_ARRAY(array);
    var stepping = DEBUG_IS_STEPPING(f);
    for (var i = 0; i < length; i++) {
      if (HAS_INDEX(array, i, is_array)) {
        var element = array[i];
        // Prepare break slots for debugger step in.
        if (stepping) %DebugPrepareStepInIfStepping(f);
        accumulator[i] = %_Call(f, receiver, element, i, array);
      }
    }
    var result = new GlobalArray();
    %MoveArrayContents(accumulator, result);
    return result;
  }
  ```

# ArrayBuffer

# 最新提案

# Decorator

# 参考