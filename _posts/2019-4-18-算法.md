---
layout: post
#标题配置
title:  算法
#时间配置
date:   2019-4-18 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note base
---

* content
{:toc}





# 复杂度

## 复杂度分析

- **复杂度**也叫**渐进复杂度**，包括**时间复杂度**和**空间复杂度**，一个表示执行的快慢，一个表示内存的消耗，用来分析算法执行效率与数据规模之间的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。

### 为什么需要复杂度分析

- 学习数据和算法就是为了解“快”和“省”的问题，也就是如何设计你的代码才能使运算效率更快，占用空间更小。那如何来计算代码执行效率呢？这里就会用到复杂度分析。
- 虽然我们可以用代码准确的计算出执行时间，但是这也会有很多局限性。
- 数据规模的不同会直接影响到测试结果。比如说同一个排序算法，排序顺序不一样，那么最后的计算效率的结果也会不一样；如果恰好已经是排序好的了数组，那么执行时间就会更短。又比如说如果数据规模比较小的话，测试结果可能也无法反应算法的性能。
- 测试的环境不同也会影响到测试结果。比如说同一套代码分别在 i3 和 i7 处理器上进行测试，那么 i7 上的测试时间肯定会比 i3 上的短。
- 所以需要一个不用准确的测试结果来衡量，就可以粗略地估计代码执行时间的方法。这就是**复杂度分析**。

### 大 O 复杂度表示法

- 以一个例子开始，请估算下面代码的执行时间

  ```js
  function total(n) { // 1
    var sum = 0; // 2
    for (var i = 0; i < n; i++) { // 3
      sum += i; // 4
    } //5 
  } //6
  ```

- 我们假设每行代码执行的时间都一样，记做 t，那么上面的函数中的第 2 行需要 1 个 t 的时间，第 3 行 和 第 4 行分别需要 n 个 t 的时间，那么这段代码总的执行时间为 (2n+1)*t。

- 那么按照上面的分析方法，请估算下面代码的执行时间

  ```js
  function total(n) { // 1
    var sum = 0; // 2
    for (var i = 0; i < n; i++) { // 3 
      for (var j = 0; j < n; j++) { // 4
        sum = sum + i + j; // 5
      }
    }
  }
  ```

- 第 2 行需要一个 t 的时间，第 3 行需要 n 个 t 的时间，第 4 行和第 5 行分别需要 n^2 个的时间，那么这段代码总的执行时间为 (2n^2+n+1)*t 的时间。

- 从数学角度来看，我们可以得出个规律：代码的总执行时间 T(n) 与每行代码的执行次数成正比

- T(n) = O(f(n))

- 在这个公式中，T(n) 表示代码的执行时间；n 表示数据规模的大小；f(n) 表示每行代码执行的**次数总和**；O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

- 所以上边两个函数的执行时间可以标记为 T(n) = O(2n+1) 和 T(n) = O(2n^2+n+1)。这就是**大 O 时间复杂度表示法**，它不代表代码真正的执行时间，而是表示**代码随数据规模增长的变化趋势**，简称**时间复杂度**。

- 而且当 n 很大时，我们可以**忽略常数项**，只保留一个最大量级即可。所以上边的代码执行时间可以简单标记为 T(n) = O(n) 和 T(n) = O(n^2)。

### 时间复杂度分析

- 那如何分析一段代码的时间复杂度呢，可以利用下面的几个方法

#### **加法法则：**

- **总复杂度等于量级最大的那段代码的复杂度。**

- ```js
  function total(n) { 
    // 第一个 for 循环
    var sum1 = 0; 
    for (var i = 0; i < n; i++) {
      for (var j = 0; j < n; j++) {
        sum1 = sum1 + i + j; 
      }
    }
    // 第二个 for 循环
    var sum2 = 0;
    for(var i=0;i<1000;i++) {
      sum2 = sum2 + i;
    }
    // 第三个 for 循环
    var sum3 = 0;
    for (var i = 0; i < n; i++) {
      sum3 = sum3 + i;
    }
  }
  
  ```

- 我们先分别分析每段 for 循环的时间复杂度，再取他们中最大的量级来作为整段代码的时间复杂度。

- 第一段 for 循环的时间复杂度为 O(n^2)。

- 第二段 for 循环执行了 1000 次，是个常数量级，尽管对代码的执行时间会有影响，但是当 n 无限大的时候，就可以忽略。因为它本身对增长趋势没有影响，所以这段代码的时间复杂度可以忽略。

- 第三段 for 循环的时间复杂度为 O(n)。

- 总上，取最大量级，所以整段代码的时间复杂度为 O(n^2)。

#### 乘法法则

- 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

- ```js
  function f(i) {
    var sum = 0;
    for (var j = 0; j < i; j++) {
      sum += i;
    }
    return sum;
  }
  function total(n) {
    var res = 0;
    for (var i = 0; i < n; i++) {
      res = res + f(i); // 调用 f 函数
    }
  }
  ```

- 单独看 total 函数的时间复杂度就是为 T1(n)=O(n)，但是考虑到 f 函数的时间复杂度也为 T2(n)=O(n)。 所以整段代码的时间复杂度为 T(n) = T1(n) * T2(n) = O(n*n)=O(n^2)。

### 常见的时间复杂度分析

- ![img](https://pic3.zhimg.com/80/v2-0725ac96068e0634bfdfda2aa2bab17e_hd.jpg) 
- 如上图可以粗略的分为两类，**多项式量级**和**非多项式量级**。其中，**非多项式量级**只有两个：O(2^n) 和 O(n!) 对应的增长率如下图所示
- ![img](https://pic4.zhimg.com/80/v2-150e16309802ea969940cac4e30385e7_hd.jpg) 
- 当数据规模 n 增长时，**非多项式量级**的执行时间就会急剧增加，所以，**非多项式量级**的代码算法是非常低效的算法。

#### O(1)

- O(1) 只是常量级时间复杂度表示法，并不是代码只有一行，比如说下面这段代码

  ```js
  function total() {
    var sum = 0;
    for(var i=0;i<100;i++) {
      sum += i;
    }
  }
  ```

- 虽然有这么多行，即使 for 循环执行了 100 次，但是代码的执行时间不随 n 的增大而增长，所以这样的代码复杂度就为 O(1)。

#### O(logn)、O(nlogn)

- 对数阶时间复杂度的常见代码如下

  ```js
  function total1(n) {
    var sum = 0;
    var i = 1;
    while (i <= n) {
      sum += i;
      i = i * 2;
    }
  }
  function total2(n) {
    var sum = 0;
    for (var i = 1; i <= n; i = i * 2) {
      sum += i;
    }
  }
  ```

- 上面两个函数都有一个相同点，变量 i 从 1 开始取值，每循环一次乘以 2，当大于 n 时，循环结束。实际上，i 的取值就是一个等比数列，就像下面这样

- 2^0 2^1 2^2 ... 2^k... 2^x =n;

- 所以只要知道 x 的值，就可以知道这两个函数的执行次数了。那由 2^x = n 可以得出 x = log2^n，所以这两个函数的时间复杂度为 O(log2^n)。

- 再看下面两个函数的时间复杂度

  ```js
  function total1(n) {
    var sum = 0;
    var i = 1;
    while (i <= n) {
      sum += i;
      i = i * 3;
    }
  }
  function total2(n) {
    var sum = 0;
    for (var i = 1; i <= n; i = i * 3) {
      sum += i;
    }
  }
  ```

- 由上可以得知，这两个函数的时间复杂度为 O(log3^n) 。

- 由于我们可以忽略常数，也可以忽略对数中的底数，所以在对数阶复杂度中，统一表示为 O(logn)；那 O(nlogn) 的含义就很明确了，时间复杂度 为O(logn) 的代码执行了 n 次。

#### O(m+n)、O(m*n)

- ```js
  function total(m,n) {
    var sum1 = 0;
    for (var i = 0; i < n; i++) {
      sum1 += i;
    }
    var sum2 = 0;
    for (var i = 0; i < m; i++) {
      sum2 += i;
    }
    return sum1 + sum2;
  }
  ```

- 因为我们无法评估 m 和 n 谁的量级比较大，所以就**不能忽略掉其中一个**，这个函数的复杂度是有两个数据的量级来决定的，所以此函数的时间复杂度为 O(m+n)；那么 O(m*n) 的时间复杂度类似。

### 空间复杂度分析

- 空间复杂度的话和时间复杂度类似推算即可。 所谓空间复杂度就是**表示算法的存储空间和数据规模之间的关系**。

- 比如说分析下面代码的空间复杂度：

  ```js
  function initArr(n) {
    var arr = [];
    for (var i = 0; i < n; i++) {
      arr[i] = i;
    }
  }
  ```

- 根据时间复杂度的推算，忽略掉常数量级，每次数组赋值都会申请一个空间存储变量，所以此函数的空间复杂度为 O(n)。

- 常见的空间复杂度只有 O(1)、O(n)、O(n^2)。其他的话很少会用到。

### 复杂度优化

- ```js
  function total(n) {
    var sum = 0;
    for (var i = 1; i <= n; i++) {
      sum += i;
    }
    return sum;
  }
  ```

- 此函数的时间复杂度你现在应该很容易就能看出来了，为 O(n)。

- 我觉得这个时间复杂度有点高了，我想要 O(1) 的时间复杂度函数来实现这个算法，可以吗？

- 可以的，小数学神通高斯教会我们一招，如下

  ```js
  function total(n) {
    var sum = n*(n+1)/2
    return sum;
  }
  ```

- 此函数的时间复杂度仅仅为 O(1)，在数据规模比较庞大的时候，下面的函数是不是明显比上面的函数运算效率更高呢。

## 最好、最坏时间复杂度分析

- ```js
  function find(n, x, arr) {
    let ind = -1;
    for (let i = 0; i < n; i++) {
      if (arr[i] === x) ind = i;
    }
    return ind;
  }
  ```

- 上面函数的功能就是查找一个变量 x 是否在 数组 arr 中，如果在的话，返回所在的位置，否则就返回 -1。通过上一节的学习分析，这个函数的时间复杂度就很容易知道了，为 O(n)。

- 接下来，稍微优化下这个 `find` 函数，如果查找到目标的话，就没必要再往后查找了。

  ```js
  function find(n, x, arr) {
    let ind = -1;
    for (let i = 0; i < n; i++) {
      if (arr[i] === x){
        ind = i;
        break;
      } 
    }
    return ind;
  }
  ```

- 现在代码的时间复杂度还为 O(n)吗？不确定，利用上一章的分析法就无法解决了。

- 因为要查找的变量 x 可能会出现在数组的任意位置。如果变量 x 恰好是数组中第一个元素，那么函数就会 `break` ，后续就不会继续遍历了，那时间复杂度就是 O(1)。但如果恰好是数组中第末个元素，或者数组中不存在变量 x 的话，那就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这个函数的时间复杂度是不一样的。

- 为了表示代码在不同情况下的不同时间复杂度，需要了解以下三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度

### 理想情况

- **最好情况时间复杂度**：在最理想的情况下，执行这段代码的时间复杂度。比如说刚才那段函数，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这种情况下对应的时间复杂度就是**最好情况时间复杂度**。

### 糟糕情况

- **最坏情况时间复杂度**：在最糟糕的情况下，执行这段代码的时间复杂度。比如说刚才那段函数，要查找的变量 x 正好是数组的第末个元素或者不在数组中存在 ，查找函数就会把数组都遍历一遍，这种情况下对应的时间复杂度就是**最坏情况时间复杂度**。

### 平均情况

- 但是，**最好情况时间复杂度**和**最坏情况时间复杂度**对应的都是极端情况下的代码复杂度，发生的概率其实并不大。
- 为了更好地表示平均情况下的复杂度，引入另一个概念：平均情况时间复杂度，简称为平均时间复杂度。
- 那如何分析平均时间复杂度呢，还是拿刚才那段查找函数来说：
  - 要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。然后把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值。
  - ![1553154595774](F:\OneDrive\JS\assets\1553154595774.png) 
  - 根据上章所说，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，把这个公式简化之后，得到的**平均时间复杂度**就是 O(n)。
- 但是上面计算的过程中，没有考虑到概率的问题，因为出现在每个位置的概率是不一样的，所以得重新计算，如下分析：
  - 要查找的变量 x，要么在数组里，要么就不在数组里。简单标记这两种情况下的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。那我们把每种情况发生的概率都考虑进去，计算表达式就变成了：
  - ![1553154639207](F:\OneDrive\JS\assets\1553154639207.png) 
  - 最后的结果也叫做概率中的**加权平均值**，那最后此段函数的**平均时间复杂度**就为 O(n)。
- 这么看，**平均时间复杂度**是不是好麻烦，还需要概率计算。实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度**有量级的差距**，我们才会使用这三种复杂度表示法来区分。

### 均摊情况

- ```js
  {
    var arr = new Array(n); // n 代表任意数字
    var ind = 0;
    function add(num) {
      if (ind === arr.length) {
        var sum = 0;
        for (var i = 0; i < arr.length; i++) {
          sum += arr[i];
        }
        arr[0] = sum;
        ind = 1;
      }
      arr[ind] = num;
      ind++;
    }
  }
  ```

- `add` 函数就是实现一个往数组中添加数据的功能。先定义一个任意长度的空数组，然后给数组添加数据。当达到数组长度后，也就是`ind === array.length`时，用 `for` 循环遍历数组求和，将求和之后的 `sum` 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空的话，则直接将数据添加到数组中。

- 来分析下此函数的时间复杂度：

  - 最理想的情况下，数组中有剩余位置，我们只需要将数据添加到数组下标为 `ind` 的位置就可以了，所以**最好情况时间复杂度**为 O(1)。 最糟糕的情况下，数组中没有剩余位置，我们需要先做一次数组的遍历求和，然后再添加数据，所以**最坏情况时间复杂度**为 O(n)。

- 接下来分析需要计算的 **平均时间复杂度**：

  - 由于数组的长度是 n，根据数据添加的位置的不同，可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种特殊的情况，就是在数组没有空闲空间时添加一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。
  - $\frac{n+n}{n+1}$
  - 所以根据大 O 表示法，**平均时间复杂度**就为 O(1)。

- 其实 `add` 函数的平均复杂度不需要这么复杂，接下来我们看看 `find` 函数和`add`函数的区别：

  - `find` 函数在极端情况下，时间复杂度才为 O(1)。但 `add` 函数在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，时间复杂度才比较高，为 O(n)。
  - 对于 `add` 函数来说，O(1) 时间复杂度的添加和 O(n) 时间复杂度的添加，出现的频率是非常有规律的，而且有一定的前后顺序，一般都是一个 O(n) 添加之后，紧跟着 n-1 个 O(1) 的添加操作，循环往复。

- 所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。

- 针对这种特殊的情况，我们引入了一种更加简单的分析方法：**摊还分析法**。通过摊还分析得到的时间复杂度，叫 **均摊时间复杂度**。

- 那如何使用摊还分析法来分析算法的**均摊时间复杂度**呢？

  - 还是看 `add` 函数。每一次 O(n) 的添加操作，都会跟着 n-1 次 O(1) 的添加操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是**均摊分析**的大致方法。

- 一般情况总结为：

  - 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用**均摊时间复杂度分析**的场合，一般**均摊时间复杂度**就等于**最好情况时间复杂度**。

### 生活举例

- 今天你准备去老王家拜访下，可惜老王的爱人叫他去打个酱油，她告诉你说她限时 n 分钟给他去买。
- 那么你想着以他家到楼下小卖部来回最多一分钟，那么 “最好的情况”就是你只用等他一分钟。
- 那么也有可能遇到突发情况，比如说电梯没电了，或者路上摔了一跤，天知道他去干了什么，用了 n 分钟。没办法，老婆有令，n 分钟限时，那这就是“最坏的情况”。
- 那“平均时间复杂度” 就是他有可能是第 1,2,3,...,n 中的某个分钟回来，那平均就是 1+2+3+...n/n，把 所有可能出现的情况的时间复杂度 相加除以情况数 。
- “均摊时间复杂度”的话就是把花时间多的分给花时间少的，得到一个中间值。假如 n 是 10 分钟，那么 9 分钟分 4 分钟到 1 分钟那，8 分 3 给 2...，那均摊下来就是 5 分钟。

### 四种复杂度

- 同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。
- 代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。

# 排序算法

+ ```js
  function ArrayList(){ 
   
    var array = []; //{1} 
   
    this.insert = function(item){ //{2} 
      array.push(item); 
    }; 
   
    this.toString= function(){ //{3} 
      return array.join(); 
    }; 
  } 
  ```

+ 注意ArrayList类并没有任何方法来移除数据或插入数据到特定位置。我们刻意保持简单是为了能够专注于排序和搜索算法。所有的排序和搜索算法会添加至这个类中。 

## 冒泡排序

### 基本实现

- 比较**相邻**的元素。如果第一个比第二个大，就交换他们两个。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。 

  ```js
   this.bubbleSort = function(){ 
    var length = array.length;           //{1} 
    for (var i=0; i<length; i++){        //{2} 
      for (var j=0; j<length-1; j++ ){ //{3} 
        if (array[j] > array[j+1]){  //{4} 
          swap(array, j, j+1);      //{5} 
        } 
      } 
    } 
  };
  ```

+ 外循环（行{2}）会从数组的第一位迭代至最后一位，它控制了在数组中经过多少轮排序（应该是数组中每项都经过一轮，轮数和数组长度一致）。
+ 然后，内循环将从第一位迭代至倒数第二位，内循环实际上进行当前项和下一项的比较（行{4}）。如果这两项顺序不对（当前项比下一项大），则交换它们（行{5}），意思是位置为j+1的值将会被换置到位置j处

+ 现在我们得声明swap函数（一个私有函数，只能用在ArrayList类的内部代码中）： 

  ```js
  var swap = function(array, index1, index2){ 
    var aux = array[index1]; 
    array[index1] = array[index2]; 
    array[index2] = aux; 
  }; 
  ```

+ 我们使用下列代码来测试

  ```js
  function createNonSortedArray(size){ //{6} 
    var array = new ArrayList(); 
    for (var i = size; i> 0; i--){ 
      array.insert(i); 
    } 
    return array; 
  } 
  
  var array = createNonSortedArray(5); //{7} 
  console.log(array.toString());       //{8} 
  array.bubbleSort();                  //{9} 
  console.log(array.toString());       //{10} 
  ```

+ 下面这个示意图展示了冒泡排序的工作过程： 

  ![1554720485478](F:\OneDrive\JS\assets\1554720485478.png)

+ 该示意图中每一小段表示外循环的一轮（行{2}），而相邻两项的比较则是在内循环中进行的（行{3}）。 

+ 注意当算法执行外循环的第二轮的时候，数字4和5已经是正确排序的了。尽管如此，在后续比较中，它们还一直在进行着比较，即使这是不必要的。因此，我们可以稍稍改进一下冒泡排序算法。

### 优化实现

+ 如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较（行{1}）。 

  > 第一轮执行后，最大的数一定到达正确的位置，且不再改变
  >
  > 第二轮执行后，第二大的数一定到达正确的位置，且不再改变

  ```js
  this.modifiedBubbleSort = function(){ 
    var length = array.length; 
    for (var i=0; i<length; i++){ 
      for (var j=0; j<length-1-i; j++ ){ //{1} 
        if (array[j] > array[j+1]){ 
          swap(j, j+1); 
        } 
      } 
    } 
  }; 
  ```

+ 下面这个示意图展示了改进后的冒泡排序算法是如何执行的： 

  ![1554720947859](F:\OneDrive\JS\assets\1554720947859.png)

  > 注意已经在正确位置上的数字没有被比较。即便我们做了这个小改变，改进了一下冒泡排序算法，但我们还是不推荐该算法，它的复杂度是O(n^2)。 

+ 进一步优化，如果在一轮内循环中，没有发生过交换，说明数组已经是有序的，就可以直接退出了

- ```js
  this.modifiedBubbleSort = function(){ 
    var length = array.length; 
    var flag
    for (var i=0; i<length; i++){ 
      flag = true // 初始化标识
      for (var j=0; j<length-1-i; j++ ){ //{1} 
        if (array[j] > array[j+1]){ 
          swap(array,j, j+1); 
          flag = false // 发生了交换，更改标识
          console.log(array.toString())
        } 
      } 
      if(flag){
        // 本轮没有进行过交换，说明数组已经有序
        return
      }
    } 
  }; 
  ```

### 复杂度分析

+ 最好情形：正序，仅需 n - 1 次比较
+ 最坏情形：反序，需要平方级的比较和平方级的交换
+ https://blog.csdn.net/hansionz/article/details/80822494

## 选择排序

- 选择排序算法是一种**原址比较排序**算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。 
- 基本思路：不断从剩余数组中选出最小的数，然后移到前面

### 基本实现

+ ```js
  this.selectionSort = function(){ 
    var length = array.length,            //{1} 
      indexMin; 
    for (var i=0; i<length-1; i++){       //{2} 
      indexMin = i;                     //{3} 
      for (var j=i; j<length; j++){     //{4} 
        if(array[indexMin]>array[j]){ //{5} 
          indexMin = j;             //{6} 
        } 
      } 
      if (i !== indexMin){              //{7} 
        swap(array,i, indexMin);  
      } 
    } 
  };
  ```

+ 外循环（行{2}）迭代数组，并控制迭代轮次（数组的第n个值——下一个最小值）。

+ 我们**假设**本迭代轮次的第一个值为数组最小值（行{3}）。

+ 然后，从**当前i的值开始至数组结束**（行{4}），我们比较是否位置j的值比当前最小值小（行{5}）；如果是，则改变最小值至新最小值（行{6}）。

  > 每一轮迭代范围都在缩小

+ 当内循环结束（行{4}），将得出数组第n小的值。

+ 最后，如果该最小值和原最小值不同（行{7}），则交换其值。 

+ 下面的示意图展示了选择排序算法，此例基于之前代码中所用的数组。 

  ![1554722109017](F:\OneDrive\JS\assets\1554722109017.png)

+ 数组底部的箭头指示出当前迭代轮寻找最小值的**数组范围**（内循环{4}），示意图中的每一步则表示外循环。 

### 复杂度分析

+ O(n^2)。需要约 N^2 / 2 次比较，与最多 N - 1 次交换
+ 运行时间与输入无关，给定 N 的情况下，无论何种输入所需时间均相等
+ 数据交换量最小

## 插入排序

+ 插入排序**每次排一个数组项**，以此方式构建最后的排序数组。

+ 假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。 

  ```js
  this.insertionSort = function(){ 
    var length = array.length,            //{1} 
        j, temp; 
    for (var i=1; i<length; i++){         //{2} 
      j = i;                            //{3}
      // 待比较的值 待插入的值
      temp = array[i];                  //{4} 
      
      while (j>0 && array[j-1] > temp){ //{5} 
        // array[i]原本的值不用理会，就是待比较的值
        // 只需要在已排位的数组里找到temp的位置即可
        array[j] = array[j-1];        //{6} 
        j--; 
      } 
      // 如果前面一位的值比待排位的值小，说明此时的j值是正确的,插入到[j]
      // 或者j=0，此时插入到[0]
      array[j] = temp;                  //{7} 
    } 
  }; 
  ```

+ 照例，算法的第一行用来声明代码中使用的变量（行{1}）。

+ 接着，迭代数组来给第i项找到正确的位置（行{2}）。

  > 注意，算法是从第二个位置（索引1）而不是0位置开始的（我们认为第一项已排序了）。

+ 然后，用i的值来初始化一个辅助变量（行{3}）并将其值亦存储于一临时变量中（行{4}），**便于之后将其插入到正确的位置上。**

+ 下一步是要找到正确的位置来插入项目。只要变量j比0大（因为数组的第一个索引是0——没有负值的索引）并且数组中前面的值比**待比较**的值大（行{5}），我们就把这个值移到当前位置上（行{6}）并减小j。最终，该项目能插入到正确的位置上。 

+ 下面的示意图展示了一个插入排序的实例： 

  ![1554722628123](F:\OneDrive\JS\assets\1554722628123.png)

+ 举个例子，假定待排序数组是[3, 5, 1, 4, 2]。这些值将被插入排序算法按照下面形容的步骤进行排序。 

+ (1) 3已被排序，所以我们从数组第二个值5开始。3比5小，所以5待在原位（数组的第二位）。3和5排序完毕。 

+ (2) 下一个待排序和插到正确位置上去的值是1（目前在数组的第三位）。5比1大，所以5被移至第三位去了。我们得分析1是否应该被插入到第二位——1比3大吗？不，所以3被移到第二位去了。接着，我们得证明1应该插入到数组的第一位上。因为0是第一个位置且没有负数位，所以1必须被插入到第一位。1、3、5三个数字已经排序。 

+ (3)  4应该在当前位置（索引3）还是要移动到索引较低的位置上呢？4比5小，所以5移动到索引3位置上去。那么应该把4插到索引2的位置上去吗？4要比3大，所以4插入到数组的位置3上。 

+ (4)  下一个待插入的数字是2（数组的位置4）。5比2大，所以5移动至索引4。4比2大，所以4也得移动（位置3）。3也比2大，所以3还得移动。1比2小，所以2插入到数组的第二位置上。至此，数组已排序完成。 

  > 此表中的问好，非常的关键，实际上表明了并没有真正的发生交换，而是仍在寻找合适的插入位置
  >
  > 3 ？5 4 2 → 3 5 5 4 2
  >
  > 从代码可知，之所以这么做，是因为temp的位置还未确定，此时交换就结果而言是多余的
  >
  > 这是 **插入排序** 插入二字的精髓

### 复杂度分析

+ 排序小型数组时，此算法比选择排序和冒泡排序性能要好。 

## 归并排序 

+ 归并排序是第一个可以被实际使用的排序算法。你在本书中学到的前三个排序算法性能不好，但归并排序性能不错，其复杂度为O(nlog^n)。 

  > JavaScript的Array类定义了一个sort函数（Array.prototype.sort）用以排序JavaScript数组（我们不必自己实现这个算法）。ECMAScript没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla  Firefox使用归并排序作为Array.prototype.sort的实现，而Chrome使用了一个快速排序（下面我们会学习的）的变体。 

+ 归并排序是一种**分治算法**。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。 

+ 由于是分治法，归并排序也是递归的： 

  ```js
  this.mergeSort = function(){ 
    array = mergeSortRec(array); 
  }; 
  ```

+ 像之前的章节一样，每当要实现一个递归函数，我们都会实现一个实际被执行的辅助函数。对归并排序我们也会这么做。我们将声明mergeSort方法以供随后使用，而mergeSort方法将会调用mergeSortRec，该函数是一个递归函数：

  ```js
  var mergeSortRec = function(array){ 
    var length = array.length; 
    if(length === 1) {      //{1} 
      return array;       //{2} 
    } 
    var mid = Math.floor(length / 2),     //{3} 
      left = array.slice(0, mid),       //{4} 
      right = array.slice(mid, length); //{5} 
   
    return merge(mergeSortRec(left), mergeSortRec(right)); //{6} 
  }; 
  ```

+ 归并排序将一个大数组转化为多个小数组直到只有一个项。由于算法是递归的，我们需要一个停止条件，在这里此条件是判断数组的长度是否为1（行{1}）。如果是，则直接返回这个长度为1的**数组**（行{2}），因为它已排序了。 

+  如果数组长度比1大，那么我们得将其分成小数组。为此，首先得找到数组的**中间位**（行{3}），找到后我们将数组分成两个小数组，分别叫作left（行{4}）和right（行{5}）。left数组由索引0至中间索引的元素组成，而right数组由中间索引至原始数组最后一个位置的元素组成。

+ 下面的步骤是调用merge函数（行{6}），它负责**合并和排序小数组来产生大数组**，直到回到原始数组并已排序完成。为了不断将原始数组分成小数组，我们得再次对left数组和right数组递归调用mergeSortRec，并同时作为参数传递给merge函数。 

  ```js
  var merge = function(left, right){ 
    var result = [], // {7} 
        il = 0,  
        ir = 0; 
    while(il < left.length && ir < right.length) { // {8} 
      if(left[il] < right[ir]) { 
        result.push(left[il++]);  // {9} 
      } else{ 
        result.push(right[ir++]); // {10} 
      } 
    } 
  
    while (il < left.length){     // {11} 
      result.push(left[il++]); 
    } 
  
    while (ir < right.length){    // {12} 
      result.push(right[ir++]); 
    } 
  
    return result; // {13} 
  }; 
  
  ```

+ merge函数接受两个数组作为参数，并将它们归并至一个大数组。排序发生在归并过程中。首先，需要声明归并过程要创建的新数组以及用来迭代两个数组（left和right数组）所需的两个变量（行{7}）。

+ 迭代两个数组的过程中（行{8}），我们比较来自left数组的项是否比来自right数组的项小。

  + 如果是，将该项从left数组添加至归并结果数组，并递增迭代数组的控制变量（行{9}）；
  + 否则，从right数组添加项并递增相应的迭代数组的控制变量（行{10}）。 

+ 接下来，将left数组或者right数组所有剩余的项添加到归并数组中（行{11}和行{12}）。最后，将归并数组作为结果返回（行{13}）。 

  > 如果left和right的长度不一致，或者left全部都比right小，只会有一个数组仍有剩余，所以把剩余的推入即可
  >
  > 第一个while循环结束后，仍有剩余的数组的最小项都会比合并数组的最大项大

+ 如果执行mergeSort函数，下图是具体的执行过程： 

  ![1554730216945](F:\OneDrive\JS\assets\1554730216945.png)

+ 可以看到，算法首先将原始数组分割直至只有一个元素的子数组，然后开始归并。归并过程也会完成排序，直至原始数组完全合并并完成排序。 

## 快速排序

- 快速排序也许是最常用的排序算法了。它的复杂度为O(nlog^n)，且它的性能通常比其他的复杂度为O(nlog^n)的排序算法要好。和归并排序一样，快速排序也使用**分治的方法**，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）。 

- 以下是递归算法的原理：

  1. 首先，从数组中选择中间一项作为**主元**。 
  2. 创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到**左指针超过了右指针**。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作**划分操作**。 
  3. 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。 

- 让我们开始快速排序的实现吧： 

  ```js
  this.quickSort = function(){ 
    quick(array,  0, array.length - 1); 
  }; 
  ```

- 就像归并算法那样，开始我们声明一个主方法来调用递归函数，传递待排序数组，以及索引0及其最末的位置作为参数。 

  ```js
  var quick = function(array, left, right){ 
   
    var index; //{1} 
   
    if (array.length > 1) { //{2} 
   
      index = partition(array, left, right); //{3} 
   
      if (left < index - 1) {                //{4} 
        quick(array, left, index - 1);     //{5} 
      } 
   
      if (index < right) {  //{6} 
        quick(array, index, right);        //{7} 
      } 
    } 
  }; 
  ```

- 首先声明index（行{1}），该变量能帮助我们将子数组分离为较小值数组和较大值数组，这样，我们就能再次递归的调用quick函数了。partition函数返回值将赋值给index（行{3}）。 

  > 得到的index，即是主元的索引

- 如果数组的长度比1大（因为只有一个元素的数组必然是已排序了的（行{2}），我们将对给定子数组执行partition操作（第一次调用是针对整个数组）以得到index（行{3}）。

- 如果子数组存在较小值的元素（行{4}），则对该数组重复这个过程（行{5}）。同理，对存在较大值得子数组也是如此，如果存在子数组存在较大值，我们也将重复快速排序过程（行{7}）。 

### 划分过程 

+ 第一件要做的事情是选择主元（pivot），有好几种方式。最简单的一种是选择数组的第一项（最左项）。然而，研究表明对于几乎已排序的数组，这不是一个好的选择，它将导致该算法的最差表现。另外一种方式是随机选择一个数组项或是选择中间项。 

+ 现在，让我们看看划分过程： 

  ```js
  var partition = function(array, left, right) { 
   
    var pivot = array[Math.floor((right + left) / 2)], //{8} 
      i = left,                                      //{9} 
      j = right;                                     //{10} 
   
    while (i <= j) {                //{11} 
      while (array[i] < pivot) {  //{12} 
        i++; 
      } 
      while (array[j] > pivot) {  //{13} 
        j--; 
      } 
      if (i <= j) { //{14} 
        swap(array, i, j); //{15} 
        i++; 
        j--; 
      } 
    } 
    return i; //{16} 
  }; 
  ```

+ 在本实现中，我们选择中间项作为主元（行{8}）。我们初始化两个指针：left（低——行{9}），初始化为数组第一个元素；right（高——行{10}），初始化为数组最后一个元素。

+ 只要left和right指针没有相互交错（行{11}），就执行划分操作。

  + 首先，移动**left指针**直到找到一个元素比主元**大**（行{12}）。
  + 对**right指针**，我们做同样的事情，移动right指针直到我们找到一个元素比主元**小**。  

+ 当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大（行{14}），意思是左项比右项大（值比较）。我们交换它们，然后移动两个指针，并重复此过程（从行{11}再次开始）。 

+ 在划分操作结束后，返回**左指针的索引**，用来在行{3}处创建子数组。 

### 快速排序实战

+ 让我来一步步地看一个快速排序的实际例子： 

  ![1554732528622](F:\OneDrive\JS\assets\1554732528622.png)

+ 给定数组[3, 5, 1, 6, 4, 7, 2]，前面的示意图展示了划分操作的第一次执行。 

+ 下面的示意图展示了对有较小值的子数组执行的划分操作（注意7和6不包含在子数组之内）： 

  ![1554732680302](F:\OneDrive\JS\assets\1554732680302.png)

+ 接着，我们继续创建子数组，请看下图，但是这次操作是针对上图中有较大值的子数组（有1的那个较小子数组不用再划分了，因为它仅含有一个项）。 

  ![1554732734644](F:\OneDrive\JS\assets\1554732734644.png)

+ 子数组（[2, 3, 5, 4]）中的较小子数组（[2, 3]）继续进行划分（算法代码中的行{5}）： 

  ![1554732753183](F:\OneDrive\JS\assets\1554732753183.png)

+ 然后子数组（[2, 3, 5, 4]）中的较大子数组（[5, 4]）也继续进行划分（算法中的行{7}），示意图如下：

  ![1554732826043](F:\OneDrive\JS\assets\1554732826043.png)

+  最终，较大子数组[6, 7]也会进行划分（partition）操作，快速排序算法的操作执行完成。 

## 堆排序

- 堆排序也是一种很高效的算法，因其**把数组当作二叉树来排序**而得名。这个算法会根据以下信息，把数组当作二叉树来管理。 

  - 索引0是树的根节点； 
  - 除根节点外，任意节点N的父节点是N/2； 
  - 节点L的左子节点是2\*L； 
  - 节点R的右子节点是2\*R+1

- 举例来说，可以将数组[3, 5, 1, 6, 4, 7, 2]想象成下面的树：

  ![1554775529131](F:\OneDrive\JS\assets\1554775529131.png)

- 堆排序算法实现如下： 

  ```js
  this.heapSort = function() { 
    var heapSize = array.length; 
    buildHeap(array); //{1} 
   
    while (heapSize > 1) { 
      heapSize--; 
      swap(array, 0, heapSize); //{2} 
      heapify(array, heapSize, 0); //{3} 
    } 
  }; 
  ```

- 



































# 搜索算法

## 二分查找算法

+ 二分搜索算法的原理和猜数字游戏类似，就是那个有人说"我正想着一个1到100的数字"的游戏。我们每回应一个数字，那个人就会说这个数字是高了、低了还是对了。

+ 这个算法要求被搜索的数据结构已排序，以下是该算法遵循的步骤：

  - 选择数组的中间值
  - 如果选中值是待搜索值，算法执行完毕（值找到了）
  - 如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找
  - 如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找

+ 代码实例：

  ```js
  Array.prototype.binarySearch = function(item) {
      this.quickSort()
      let low = 0
      let mid = null
      let element = null
      let high = this.length - 1
      while (low <= high){
          mid = Math.floor((low + high) / 2)
          element = this[mid]
          if (element < item) {
              low = mid + 1
          } else if (element > item) {
              high = mid - 1
          } else {
              return mid
          }
      }
      return -1
  }复制代码
  ```

+ 图展示了二分搜索算法的执行过程：

  ![img](F:\OneDrive\JS\assets\968d79444c32475772c0b0d1859a6334)

+ 我们实现的BinarySearchTree类有一个search方法，和这个二分搜索完全一样，只不过它是针对树数据结构的。

### 实例

+ ```js
  var searchInsert = function(nums, target) {
    let left = 0
    let right = nums.length-1 //3
    let mid = 0
    let out = 0
    while(left<=right){ // 注意是等于
        mid = Math.floor((left+right)/2) // 1 2 3
        if(nums[mid]==target) return mid
        if(nums[mid]<target){
            left = mid+1
        }else{
            right = mid-1
        }
    }
    return left
  };
  ```

+ 因为没有负数索引，而索引可是大于长度，所以返回left，代表应该插入的位置，其实返回right也可以，只是最小的需要插入到-1

# 递归算法

### 分治算法

+ 最小栈
+ 队列实现栈
+ 归并排序

