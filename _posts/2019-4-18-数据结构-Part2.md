---
layout: post
#标题配置
title:  数据结构-Part2
#时间配置
date:   2019-4-18 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note base
---

* content
{:toc}





# 树

- 到目前为止，本书介绍了一些顺序数据结构，介绍的第一个非顺序数据结构是散列表。在本章，我们将要学习另一种**非顺序数据结构——树**，它对于存储需要**快速查找**的数据非常有用。 

## 概述

- 树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构图，如下图所示： 

  ![1554600282423](F:\OneDrive\JS\assets\1554600282423.png)

- 一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点：

  ![1554600352555](F:\OneDrive\JS\assets\1554600352555.png)

- 位于树顶部的节点叫作**根节点（11）**。它没有父节点。

- 树中的每个元素都叫作节点，节点分为内部节点和外部节点。

  - **至少有一个子节点的节点称为内部节点**（7、5、9、15、13和20是内部节点）。
  - **没有子元素的节点称为外部节点或叶节点**（3、6、8、10、12、14、18和25是叶节点）。 

- 一个节点可以有祖先和后代。

  - 一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。
  - 一个节点的后代包括子节点、孙子节点、曾孙节点等。
  - 例如，节点5的祖先有节点7和节点11，后代有节点3和节点6。 

- 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上图中树的一棵子树。 

- 节点的一个属性是深度，节点的深度取决于**自身**的祖先节点的数量。比如，节点3有3个祖先节点（5、7和11），它的深度为3。 

- 树的高度取决于**所有节点**深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它的子节点在第1层，以此类推。上图中的树的高度为3（最大高度已在图中表示——第3层）。 

### 二叉树和二叉搜索树 

- 二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。 
- 二叉搜索树（BST）是二叉树的一种，但是它只允许你在**左侧节点存储（比父节点）小的值**，在**右侧节点存储（比父节点）大（或者等于）的值**。上一节的图中就展现了一棵二叉搜索树。
- **对于每一棵树（子树），根节点就是这些数据的中位数**

## 二叉搜索树的实现

### Binary Search Tree 类

- ```js
  function BinarySearchTree() { 
   
    var Node = function(key){ //{1} 
      this.key = key; 
      this.left = null; 
      this.right = null; 
    }; 
   
    var root = null; //{2} 
  } 
  ```

- 下图展现了二叉搜索树数据结构的组织方式： 

  ![1554602235414](F:\OneDrive\JS\assets\1554602235414.png)

- 和链表一样，将通过**指针**来表示节点之间的关系（术语称其为边）。

- 在双向链表中，每个节点包含两个指针，一个指向下一个节点，另一个指向上一个节点。对于树，使用同样的方式（也使用两个指针）。但是，一个指向左侧子节点，另一个指向右侧子节点。

- 因此，将声明一个Node类来表示树中的每个节点（行{1}）。值得注意的一个小细节是，不同于在之前的章节中将**节点本身**称作节点或项，我们将会称其为键。**键是树相关的术语中对节点的称呼**。 

  > 链表一个节点包括：数据和指针
  >
  > 二叉树一个节点包括：左指针 键 右指针

- 我们将会遵循和LinkedList类中相同的模式（第5章），这表示也将声明一个变量以控制此数据结构的第一个节点。在树中，它不再是头节点，而是**根元素**（行{2}）。 

### 基本操作

- insert(key)：向树中插入一个新的键。 
- search(key)：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回
  false。 
- inOrderTraverse：通过**中序遍历**方式遍历所有节点。 
- preOrderTraverse：通过**先序遍历**方式遍历所有节点。 
- postOrderTraverse：通过**后序遍历**方式遍历所有节点。 
- min：返回树中最小的值/键。 
- max：返回树中最大的值/键。 
- remove(key)：从树中移除某个键。 

### insert()

- 下面的代码是用来向树插入一个新键的算法的第一部分： 

  ```js
  this.insert = function(key){ 
   
    var newNode = new Node(key); //{1} 
   
    if (root === null){ //{2} 
      root = newNode; 
    } else { 
      insertNode(root,newNode); //{3} 
    } 
  }; 
  ```

- 要向树中插入一个新的节点（或项），要经历三个步骤：

- 第一步是创建用来表示新节点的Node类实例（行{1}）。只需要向构造函数传递我们想用来插入树的节点值，它的左指针和右指针的值会由构造函数自动设置为null。  

- 第二步要验证这个插入操作是否为一种特殊情况。这个特殊情况就是我们要插入的节点是树的第一个节点（行{2}）。如果是，就将根节点指向新节点。 

- 第三步是将节点加在非根节点的其他位置。这种情况下，需要一个私有的**辅助函数**（行{3}），函数定义如下：

  ```js
  var insertNode = function(node, newNode){ 
    if (newNode.key < node.key){ //{4} 
      if (node.left === null){   //{5} 
        node.left = newNode;   //{6} 
      } else { 
        insertNode(node.left, newNode) //{7} 
      } 
    } else { 
      if (node.right === null){  //{8} 
        node.right = newNode;  //{9} 
      } else { 
        insertNode(node.right, newNode); //{10} 
      } 
    } 
  }
  ```

- 如果树非空，需要找到插入新节点的位置。因此，在调用insertNode方法时要通过参数传入**树的根节点和要插入的节点。** 

  > 正如链表必须从头部开始遍历，树必须要从根节点开始递归

- 如果新节点的键小于当前节点的键（现在，当前节点就是根节点）（行{4}）那么需要检查当前节点的左侧子节点。

  - 如果它没有左侧子节点（行{5}），就在那里插入新的节点。
  - 如果有左侧子节点，需要通过递归调用insertNode方法（行{7}）继续找到树的下一层。
  - 下次将要比较的节点将会是当前节点的左侧子节点。 

- 如果节点的键比当前节点的键大，那么需要检查当前节点的左侧子节点。

  - 如果当前节点没有右侧子节点（行{8}），就在那里插入新的节点（行{9}）。
  - 如果有右侧子节点，同样需要递归调用insertNode方法
  - 但是要用来和新节点比较的节点将会是右侧子节点。 

**示例**

- 让我们通过一个例子来更好地理解这个过程。 

  ```js
  var tree = new BinarySearchTree(); 
  tree.insert(11); 
  ```

- 首先插入第一个节点，这种情况下，树中有一个单独的节点，根指针将会指向它。源代码的行{2}将会执行。 

- 接着输入：

  ```js
  tree.insert(7); 
  tree.insert(15); 
  tree.insert(5); 
  tree.insert(3); 
  tree.insert(9); 
  tree.insert(8); 
  tree.insert(10); 
  tree.insert(13); 
  tree.insert(12); 
  tree.insert(14); 
  tree.insert(20); 
  tree.insert(18); 
  tree.insert(25); 
  ```

- 会创建如下结构：

  ![1554603298906](F:\OneDrive\JS\assets\1554603298906.png)

- 现在我们插入一个键值为6的节点：`tree.insert(6)`

  1. 树不是空的，行{3}的代码将会执行。insertNode方法将会被调用（root, key[6]）
  2. 算法将会检测行{4}（key[6] < root[11]为真），并继续检测行{5}（node.left[7]不是null），然后将到达行{7}并调用insertNode（node.left[7], key[6]）
  3. 将再次进入insertNode方法内部，但是使用了不同的参数。它会再次检测行{4}（key[6] < node[7]为真），然后再检测行{5}（node.left[5]不是null），接着到达行{7}，调用insertNode（node.left[5], key[6]）。 
  4. 将再一次进入insertNode方法内部。它会再次检测行{4}（key[6] < node[5]为假），然后到达行{8}（node.right是null——节点5没有任何右侧的子节点），然后将会执行行{9}，在节点5的右侧子节点位置插入键6。
  5. 然后，方法调用会依次出栈，代码执行过程结束。

  ![1554603493487](F:\OneDrive\JS\assets\1554603493487.png) 

## 树的遍历

- 遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。但是我们应该怎么去做呢？
- 应该从树的顶端还是底端开始呢？从左开始还是从右开始呢？
- 访问树的所有节点有三种方式：中序、先序和后序。 

### 中序遍历

- 中序遍历是一种以**上行顺序**访问BST所有节点的遍历方式，也就是以从**最小到最大**的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作。我们来看它的实现： 

  ```js
  this.inOrderTraverse = function(callback){ 
    inOrderTraverseNode(root, callback); //{1} 
  }; 
  ```

- inOrderTraverse方法接收一个回调函数作为参数。回调函数用来定义我们**对遍历到的每个节点进行的操作**

  > 这也叫作访问者模式，要了解更多关于访问者模式的信息，请参考http://en.wikipedia.org/wiki/Visitor_pattern）。

- 由于我们在BST中最常实现的算法是递归，这里使用了一个私有的辅助函数，来接收一个节点和对应的回调函数作为参数（行{1}）。 

  ```js
  var inOrderTraverseNode = function (node, callback) { 
    if (node !== null) { //{2} 
      inOrderTraverseNode(node.left, callback);  //{3} 
      callback(node.key);                        //{4} 
      inOrderTraverseNode(node.right, callback); //{5} 
    } 
  }; 
  
  ```

- 要通过中序遍历的方法遍历一棵树，首先要检查以参数形式传入的节点是否为null（这就是停止递归继续执行的判断条件——行{2}——递归算法的基本条件）。 

  > 同样的从根节点开始递归

- 然后，递归调用相同的函数来访问左侧子节点（行{3}）。接着对这个节点进行一些操作（callback），然后再访问右侧子节点（行{5}）。 

- 我们试着在之前展示的树上执行下面的方法：

  ```js
  function printNode(value){ //{6} 
    console.log(value); 
  } 
  tree.inOrderTraverse(printNode); //{7} 
  ```

- 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25  （每个数字将会输出在不同的行）

- 下图展示了访问的路径：

  ![1554605385643](F:\OneDrive\JS\assets\1554605385643.png)

### 先序遍历

- 先序遍历是以**优先于后代节点**的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档。 

- ```js
  this.preOrderTraverse = function(callback){ 
      preOrderTraverseNode(root, callback); 
  }; 
  ```

  ```js
  var preOrderTraverseNode = function (node, callback) { 
    if (node !== null) { 
      callback(node.key); //{1} 
      preOrderTraverseNode(node.left, callback); //{2} 
      preOrderTraverseNode(node.right, callback); //{3} 
    } 
  };
  ```

- 先序遍历和中序遍历的不同点是，先序遍历会先访问节点本身（行{1}），然后再访问它的左侧子节点（行{2}），最后是右侧子节点（行{3}），而中序遍历的执行顺序是：{2}、{1}和{3}。 

- 下面的图描绘了preOrderTraverse方法的访问路径： 

  ![1554605791244](F:\OneDrive\JS\assets\1554605791244.png)

### 后序遍历 

- 后序遍历则是**先访问节点的后代节点，再访问节点本身**。后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。 

  ```js
  this.postOrderTraverse = function(callback){ 
    postOrderTraverseNode(root, callback); 
  }; 
  ```

  ```js
   var postOrderTraverseNode = function (node, callback) { 
    if (node !== null) { 
      postOrderTraverseNode(node.left, callback);  //{1} 
      postOrderTraverseNode(node.right, callback); //{2} 
      callback(node.key);                          //{3} 
    } 
  };
  ```

- 这个例子中，后序遍历会先访问左侧子节点（行{1}），然后是右侧子节点（行{2}），最后是父节点本身（行{3}）。 

- 你会发现，中序、先序和后序遍历的实现方式是很相似的，唯一不同的是行{1}、{2}和{3}的执行顺序。 

- 下面的图描绘了postOrderTraverse方法的访问路径： 

  ![1554605962009](F:\OneDrive\JS\assets\1554605962009.png)

### 总结

- 中序遍历，根节点，在中间出现
- 先序遍历，根节点，最先出现
- 后序遍历，根节点，最后出现

## 搜索树中的值

- 在树中，有三种经常执行的搜索类型： 
  - 搜索最小值 
  - 搜索最大值 
  - 搜索特定的值 

### 搜索最小值和最大值

- 我们使用下面的树作为示例： 

  ![1554606164872](F:\OneDrive\JS\assets\1554606164872.png) 

- 如果你看一眼树最后一层最左侧的节点，会发现它的值为3，这是这棵树中最小的键。

- 如果你再看一眼树最右端的节点（同样是树的最后一层），会发现它的值为25，这是这棵树中最大的键

- 这种特点在我们实现搜索树节点的最小值和最大值的方法时能给予我们很大的帮助。

#### 搜索最小值

- 首先，我们来看寻找树的最小键的方法： 

  ```js
  this.min = function() { 
    return minNode(root); //{1} 
  }; 
  ```

  ```js
  var minNode = function (node) { 
    if (node){ 
      while (node && node.left !== null) { //{2} 
        node = node.left;                //{3} 
      } 
   		// 跳出while循环，到底最底层、最左处的节点
      return node.key; 
    } 
    return null;  //{4} 
  }; 
  ```

- minNode方法允许我们**从树中任意一个节点开始寻找最小的键**。我们可以使用它来找到一棵树或它的子树中最小的键。因此，我们在调用minNode方法的时候传入树的根节点（行{1}），因为我们想要找到整棵树的最小键。 

#### 搜索最大值

- ```js
  this.max = function() { 
    return maxNode(root); 
  }; 
   
  var maxNode = function (node) { 
    if (node){ 
      while (node && node.right !== null) { //{5} 
        node = node.right; 
      } 
   
      return node.key; 
    } 
    return null; 
  }; 
  ```

- 要找到最大的键，我们要沿着树的右边进行遍历（行{5}）直到找到最右端的节点。 

- 因此，对于寻找最小值，总是沿着树的左边；而对于寻找最大值，总是沿着树的右边。 

### 搜索特定值

- 在之前的章节中，我们同样实现了find、search或get方法来查找数据结构中的一个特定的值（和之前章节中实现的has方法相似）。我们将同样在BST中实现搜索的方法，来看它的实现： 

  ```js
  this.search = function(key){ 
    return searchNode(root, key); //{1} 
  }; 
  ```

  ```js
  var searchNode = function(node, key){ 
   
    if (node === null){ //{2} 
      return false; 
    } 
    if (key < node.key){ //{3} 
      return searchNode(node.left, key);  //{4} 
   
    } else if (key > node.key){  //{5} 
      return searchNode(node.right, key); //{6} 
   
    } else { 
      return true; //{7} 
    } 
  };
  ```

- 我们要做的第一件事，是声明search方法。和BST中声明的其他方法的模式相同，我们将会使用一个辅助函数 searchNode

- searchNode方法可以用来寻找一棵树或它的任意子树中的一个特定的值。这也是为什么在行{1}中调用它的时候传入树的根节点作为参数。 

- 在开始算法之前，先要验证作为参数传入的node是否合法（不是null）。如果是null的话，说明要找的键没有找到，返回false。 

- 如果传入的节点不是null，需要继续验证。

  - 如果要找的键比当前的节点小（行{3}），那么继续在左侧的子树上搜索（行{4}）
  - 如果要找的键比当前的节点大，那么就从右侧子节点开始继续搜索（行{6}）
  - 否则就说明要找的键和当前节点的键相等，就返回true来表示找到了这个键（行{7}）

## remove()

- ```js
  this.remove = function(key){ root = removeNode(root, key); //{1} }; 
  ```

- 这个方法接收要移除的键并且它调用了removeNode方法，传入root和要移除的键作为参数（行{1}）。我要提醒大家的一件非常重要的事情是，**root被赋值为removeNode方法的返回值**。我们稍后会明白其中的原因。

- removeNode方法的复杂之处在于我们要处理不同的运行场景，当然也包括它同样是通过递归来实现的。 

- 我们来看removeNode方法的实现： 

  ```js
  var removeNode = function(node, key){ 
  
    if (node === null){ //{2} 
      return null; 
    } 
    if (key < node.key){ //{3} 
      node.left = removeNode(node.left, key); //{4} 
      return node; //{5} 
  
    } else if (key > node.key){ //{6} 
      node.right = removeNode(node.right, key); //{7} 
      return node; //{8} 
  
    } else { //键等于node.key 
  
      //第一种情况——一个叶节点 
      if (node.left === null && node.right === null){ //{9} 
        node = null; //{10} 
        return node; //{11} 
      } 
  
      //第二种情况——一个只有一个子节点的节点 
      if (node.left === null){ //{12} 
        node = node.right; //{13} 
        return node; //{14} 
  
      } else if (node.right === null){ //{15} 
        node = node.left; //{16} 
        return node; //{17} 
      } 
  
      //第三种情况——一个有两个子节点的节点 
      var aux = findMinNode(node.right); //{18} 
      node.key = aux.key; //{19} 
      node.right = removeNode(node.right, aux.key); //{20} 
      return node; //{21} 
    } 
  };
  ```

- 我们来看行{2}，如果正在检测的节点是null，那么说明键不存在于树中，所以返回null。 

- 然后，我们要做的第一件事，就是在树中找到要移除的节点。因此，

  - 如果要找的键比当前节点的值小（行{3}），就沿着树的左边找到下一个节点（行{4}）。
  - 如果要找的键比当前节点的值大（行{6}），那么就沿着树的右边找到下一个节点（行{7}）。 

- 如果我们找到了要找的键（键和node.key相等），就需要处理三种不同的情况。 

- findMinNode方法如下： 

  ```js
  var findMinNode = function(node){ 
    while (node && node.left !== null) { 
      node = node.left; 
    } 
    return node; 
  }; 
  ```

**(1) 移除一个叶节点**

- 第一种情况是该节点是一个没有左侧或右侧子节点的叶节点——行{9}。在这种情况下，我们要做的就是给这个节点赋予null值来移除它（行{9}）。但是当学习了链表的实现之后，我们知道仅仅赋一个null值是不够的，还需要处理指针。在这里，这个节点没有任何子节点，但是它有一个父节点，**需要通过返回null来将对应的父节点指针赋予null值（行{11}）。** 

- 现在节点的值已经是null了，父节点指向它的指针也会接收到这个值，这也是我们要在函数中返回节点的值的原因。**父节点总是会接收到函数的返回值。**另一种可行的办法是将父节点和节点本身都作为参数传入方法内部。 

- 如果回头来看方法的第一行代码，会发现我们在行{4}和行{7}更新了节点左右指针的值，同样也在行{5}和行{8}返回了更新后的节点。 

- 下图展现了移除一个叶节点的过程

  ![1554617676771](F:\OneDrive\JS\assets\1554617676771.png)

**(2) 移除有一个左侧或右侧子节点的节点** 

- 现在我们来看第二种情况，移除有一个左侧子节点或右侧子节点的节点。这种情况下，需要跳过这个节点，直接**将父节点指向它的指针指向子节点**。 

- 如果这个节点没有左侧子节点（行{12}），也就是说它有一个右侧子节点。那我们把**父节点**对它的引用改为对它右侧子节点的引用（行{13}）**并返回更新后的节点（行{14}）。**

- 如果这个节点没有右侧子节点，也是一样——把**父节点**对它的引用改为对它左侧子节点的引用（行{16}）**并返回更新后的值（行{17}）。** 

- 下图展现了移除只有一个左侧子节点或右侧子节点的节点的过程：

  ![1554617885924](F:\OneDrive\JS\assets\1554617885924.png)

**(3) 移除有两个子节点的节点** 

- 现在是第三种情况，也是最复杂的情况，那就是要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。 

  1. 当找到了需要移除的节点后，需要找到它**右边子树中最小的节点**（它的继承者——行{18}）。 
  2. 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们改变了这个节点的键，也就是说它被移除了。 
  3. 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。 
  4. 最后，向它的父节点返回更新后节点的引用（行{21}）。 

- findMinNode方法的实现和min方法的实现方式是一样的。唯一不同之处在于，在min方法中只返回键，而在findMinNode中返回了节点。 

- 下图展现了移除有两个子节点的节点的过程： 

  ![1554618074255](F:\OneDrive\JS\assets\1554618074255.png)

## 自平衡树

- BST存在一个问题：取决于你添加的节点数，树的一条边可能会非常深；也就是说，树的一条分支会有很多层，而其他的分支却只有几层，如下图所示： 
- 这会在需要在某条边上添加、移除和搜索某个节点时引起一些性能问题。为了解决这个问题，有一种树叫作Adelson-Velskii-Landi树（AVL树）。AVL树是一种自平衡二叉搜索树，意思是**任何一个节点左右两侧子树的高度之差最多为1。**也就是说这种树会在添加或移除节点时尽量试着成为一棵完全树。 
- AVL树是一种自平衡树。添加或移除节点时，AVL树会尝试自平衡。任意一个节点（不论深度）的左子树和右子树高度最多相差1。添加或移除节点时，AVL树会尽可能尝试转换为完全树。 

### 在AVL树插入节点

- 在AVL树中插入或移除节点和BST完全相同。然而，AVL树的不同之处在于我们需要**检验它的平衡因子**，如果有需要，则将其逻辑应用于树的自平衡。 

  ```js
  var insertNode = function(node, element) { 
    if (node === null) { 
      node = new Node(element); 
    } else if (element < node.key) { 
      node.left = insertNode(node.left, element); 
   
      if (node.left !== null) { 
        // 确认是否需要平衡 {1} 
      } 
    } else if (element > node.key) { 
      node.right = insertNode(node.right, element); 
   
      if (node.right !== null) { 
        // 确认是否需要平衡 {2} 
      } 
    } 
    return node; 
  }; 
  ```

**计算平衡因子**

- 在AVL树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）的差值，该值 **（hr－hl）**应为0、1或-1。如果结果不是这三个值之一，则需要平衡该AVL树。这就是平衡因子的概念。 

- 下图举例说明了一些树的**平衡因子**（所有的树都是平衡的）： 

  ![1554618444522](F:\OneDrive\JS\assets\1554618444522.png)

- 计算**节点高度**的代码如下： 

  ```js
  var heightNode = function(node) { 
    if (node === null) { 
      return -1; 
    } else { 
      return Math.max(heightNode(node.left), heightNode(node.right)) + 1; 
    } 
  }; 
  ```

- **平衡因子：右节点高度 - 左节点高度，而不是 右平衡因子 - 左平衡因子**

- 因此，向左子树插入新节点时，需要计算其高度；如果高度差大于1（即不为-1、0和1之一），就需要平衡左子树。代码如下：

  ```js
   // 替换insertNode方法的行{1} 
  if ((heightNode(node.left) - heightNode(node.right)) > 1) { 
    // 旋转 {3} 
  } 
  ```

- 向右子树插入新节点时，应用同样的逻辑，代码如下： 

  ```js
  // 替换insertNode方法的行{2} 
  if ((heightNode(node.right) - heightNode(node.left)) > 1) { 
    // 旋转 {4} 
  } 
  ```

### AVL旋转

- 向AVL树插入节点时，可以执行单旋转或双旋转两种平衡操作，分别对应四种场景。 
  右右（RR）：向左的单旋转 
  左左（LL）：向右的单旋转 
  左右（LR）：向右的双旋转 
  右左（RL）：向左的双旋转 

右右（RR）：向左的单旋转 

- ![1554620603297](F:\OneDrive\JS\assets\1554620603297.png)

- 假设向AVL树插入节点90，这会造成树失衡（节点50-Y高度为-2），因此需要恢复树的平衡。下面是我们执行的操作： 

- 与平衡操作相关的节点有三个（X、Y、Z）

- 将节点X置于节点Y（平衡因子为-2）所在的位置（行{1}）； 节点X的右子树保持不变； 
  将节点Y的右子节点置为节点X的左子节点Z（行{2}）； 
  将节点X的左子节点置为节点Y（行{3}）。 

  ```js
  var rotationRR = function(node) { 
    var tmp = node.right;  // {1} 
    node.right = tmp.left; // {2} 
    tmp.left = node;       // {3} 
    return tmp; 
  }; 
  ```

#### 左左（LL）：向右的单旋转 

- ![1554635266775](F:\OneDrive\JS\assets\1554635266775.png)

- 假设向AVL树插入节点5，这会造成树失衡（节点50-Y平衡因子为+2），需要恢复树的平衡。下面是我们执行的操作： 

- 与平衡操作相关的节点有三个（X、Y、Z）

- 将节点X置于节点Y（平衡因子为+2）所在的位置（行{1}）； 节点X的左子树保持不变； 

- 将节点Y的左子节点置为节点X的右子节点Z（行{2}）； 

- 将节点X的右子节点置为节点Y（行{3}）

  ```js
  var rotationLL = function(node) { 
    var tmp = node.left;   // {1} 
    node.left = tmp.right; // {2} 
    tmp.right = node;      // {3} 
    return tmp; 
  }; 
  ```

#### 左右（LR）：向右的双旋转

- ![1554635387919](F:\OneDrive\JS\assets\1554635387919.png)

- 假设向AVL树插入节点35，这会造成树失衡（节点50-Y平衡因子为+2），需要恢复树的平衡。下面是我们执行的操作： 

- 将节点X置于节点Y（平衡因子为+2）所在的位置； 

- 将节点Y的左子节点置为节点X的右子节点； 

- 将节点Z的右子节点置为节点X的左子节点； 

- 将节点X的右子节点置为节点Y； 

- 将节点X的左子节点置为节点Z。 

- 基本上，就是先做一次RR旋转，再做一次LL旋转。 

  ```js
  var rotationLR = function(node) { 
    node.left = rotationRR(node.left); 
    return rotationLL(node); 
  }; 
  ```

#### 右左（RL）：向左的双旋转

- ![1554635648688](F:\OneDrive\JS\assets\1554635648688.png)

- 设向AVL树插入节点75，这会造成树失衡（节点70 Y高度为2），需要恢复树的平衡。下面是我们执行的操作： 

- 将节点X置于节点Y（平衡因子为2）所在的位置； 

- 将节点Z的左子节点置为节点X的右子节点； 

- 将节点Y的右子节点置为节点X的左子节点； 

- 将节点X的左子节点置为节点Y； 

- 将节点X的右子节点置为节点Z。 

- 基本上，就是先做一次LL旋转，再做一次RR旋转。 

  ```js
  var rotationRL = function(node) { 
    node.right = rotationLL(node.right); 
    return rotationRR(node); 
  }; 
  ```

### 完成insertNode方法

- 向左子树插入新节点，且节点的值小于其左子节点时，应进行LL旋转。否则，进行LR旋转。该过程的代码如下： 

  ```js
  // 替换insertNode方法的行{1} 
  if ((heightNode(node.left) - heightNode(node.right)) > 1){ 
    // 旋转 {3} 
    if (element < node.left.key){ 
      node = rotationLL(node); 
    } else { 
      node = rotationLR(node); 
    } 
  } 
  ```

- 向右子树插入新节点，且节点的值大于其右子节点时，应进行RR旋转。否则，进行RL旋转。该过程的代码如下： 

  ```js
  // 替换insertNode方法的行{2} 
  if ((heightNode(node.right) - heightNode(node.left)) > 1){ 
    // 旋转 {4} 
    if (element > node.right.key){ 
      node = rotationRR(node); 
    } else { 
      node = rotationRL(node); 
    } 
  }
  ```

## 红黑树

- 尽管AVL树是自平衡的，其插入或移除节点的性能并不总是最好的。更好的选择是红黑树。 
- 红黑树可以高效有序地遍历其节点（http://goo.gl/OxED8K）。本书不打算讲解红黑树，但也提供了它的源代码。 

## 哈夫曼树

## 常问的树面试问题

- 找到一个二叉树的高度
- 找到一个二叉搜索树中第 k 个最大值
- 找到距离根部“k”个距离的节点
- 找到一个二叉树中给定节点的祖先（ancestors）

# 图

## 概述

- 图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为任何二元关系都可以用图来表示。 

- 任何社交网络，例如Facebook、Twitter和Google plus，都可以用图来表示。 

- 图就是一组节点，以网络的形式互相连接。节点也被称为顶点（vertices）。一对（x,y）就叫做一个边，表示顶点 x 和顶点 y 相连。一个边可能包含权重/成本，显示从顶点 x 到 y 所需的成本。

- 我们还可以使用图来表示道路、航班以及通信状态，如下图所示： 

  ![1554636075580](F:\OneDrive\JS\assets\1554636075580.png)

- 一个图G = (V, E)由以下元素组成：

  - V：一组顶点 
  - E：一组边，连接V中的顶点 

- 下图表示一个图： 

  ![1554636133312](F:\OneDrive\JS\assets\1554636133312.png)

- 由一条边连接在一起的顶点称为**相邻顶点**。比如，A和B是相邻的，A和D是相邻的，A和C是相邻的，A和E不是相邻的。 

- 一个顶点的**度**是其相邻顶点的数量。比如：

  - A和其他三个顶点相连接，因此，A的度为3；
  - E和其他两个顶点相连，因此，E的度为2。 

- **路径**是顶点v1,  v2,…,vk的一个**连续序列**，其中vi和vi+1是相邻的。以上一示意图中的图为例，其中包含路径A B E I和A C D G。 

- 简单路径要求**不包含重复**的顶点。举个例子，A D G是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点）

- **环**也是一个简单路径，称为**简单闭路径**，比如A D C A（最后一个顶点重新回到A）

- 如果图中不存在环，则称该图是**无环的**。如果图中每两个顶点间都存在路径，则该图是**连通的**。 

## 有向图和无向图 

- 图可以是无向的（边没有方向）或是有向的（有向图）。如下图所示，有向图的边有一个方向： 

  ![1554681804658](F:\OneDrive\JS\assets\1554681804658.png)

- 如果图中每两个顶点间在**双向**上都存在路径，则该图是**强连通**的。例如，C和D是强连通的，
  而A和B不是强连通的。 

- 图还可以是未加权的（目前为止我们看到的图都是未加权的）或是**加权**的。如下图所示，加权图的边被赋予了权值： 

  ![1554681885050](F:\OneDrive\JS\assets\1554681885050.png)

- 我们可以使用图来解决计算机科学世界中的很多问题，比如搜索图中的一个特定顶点或搜索一条特定边，寻找图中的一条路径（从一个顶点到另一个顶点），寻找两个顶点之间的最短路径，以及环检测。

## 图的表示

- 从数据结构的角度来说，我们有多种方式来表示图。在所有的表示法中，不存在绝对正确的方式。图的正确表示法取决于待解决的问题和图的类型。

### 邻接矩阵

- 图最常见的实现是邻接矩阵。每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为j的节点相邻，则`array[i][j] === 1，否则array[i][j] === 0`，如下图所示：

  ![1554682126164](F:\OneDrive\JS\assets\1554682126164.png)

- 不是**强连通**的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。例如，找给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，我们也不得不迭代一整行。邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会改变，而2维数组不太灵活。 

### 邻接表 

- 我们也可以使用一种叫作邻接表的**动态数据结构**来表示图。邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。下面的示意图展示了邻接表数据结构。 

  ![1554682276338](F:\OneDrive\JS\assets\1554682276338.png)

- 尽管邻接表可能对大多数问题来说都是更好的选择，但以上两种表示法都很有用，且它们有着不同的性质（例如，要找出顶点v和w是否相邻，使用邻接矩阵会比较快）。在本书的示例中，我们将会使用邻接表表示法。 

### 关联矩阵 

- 我们还可以用关联矩阵来表示图。在关联矩阵中，**矩阵的行表示顶点，列表示边**。如下图所示，我们使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则`array[v][e] === 1；否则，array[v][e] === 0`。 

  ![1554682398659](F:\OneDrive\JS\assets\1554682398659.png)

- 关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。

## 图的实现

### Graph类骨架

- ```js
  function Graph() { 
    var vertices = []; //{1} 
    var adjList = new Dictionary(); //{2} 
  } 
  ```

- 我们使用一个数组来存储图中所有顶点的名字（行{1}），以及一个字典（在第7章中已经实现）来存储**邻接表**（行{2}）。字典将会使用顶点的名字作为键，邻接顶点列表作为值。vertices数组和adjList字典两者都是我们Graph类的私有属性。 

### addVertex()

- ```js
  this.addVertex = function(v){ 
    vertices.push(v); //{3} 
    adjList.set(v, []); //{4} 
  }; 
  ```

- 这个方法接受顶点v作为参数。我们将该顶点添加到顶点列表中（行{3}），并且在邻接表中，设置顶点v作为键对应的字典值为一个空数组（行{4}）

### addEdge()

- ```js
  this.addEdge = function(v, w){ 
    adjList.get(v).push(w); //{5} 
    adjList.get(w).push(v); //{6} 
  };
  ```

- 这个方法接受两个顶点作为参数。首先，通过将w加入到v的邻接表中，我们添加了一条自顶点v到顶点w的边。如果你想实现一个有向图，则行{5}就足够了。由于本章中大多数的例子都是基于无向图的，我们需要添加一条自w向v的边（行{6}）。 

### toString()

- ```js
  this.toString = function(){ 
    var s = ''; 
    for (var i=0; i<vertices.length; i++){ //{10} 
      s += vertices[i] + ' -> '; 
      var neighbors = adjList.get(vertices[i]); //{11} 
      for (var j=0; j<neighbors.length; j++){ //{12} 
        s += neighbors[j] + ' '; 
      } 
      s += '\n'; //{13} 
    } 
    return s;  
  }; 
  ```

- 我们为邻接表表示法构建了一个字符串。首先，迭代vertices数组列表（行{10}），将顶点的名字加入字符串中。接着，取得该顶点的邻接表（行{11}），同样也迭代该邻接表（行{12}），将相邻顶点加入我们的字符串。邻接表迭代完成后，给我们的字符串添加一个换行符（行{13}），这样就可以在控制台看到一个漂亮的输出了。运行如下代码：

  ```js
  var graph = new Graph(); 
  var myVertices = ['A','B','C','D','E','F','G','H','I']; //{7} 
  for (var i=0; i<myVertices.length; i++){ //{8} 
    graph.addVertex(myVertices[i]); 
  } 
  
  graph.addEdge('A', 'B'); //{9} 
  graph.addEdge('A', 'C'); 
  graph.addEdge('A', 'D'); 
  graph.addEdge('C', 'D'); 
  graph.addEdge('C', 'G'); 
  graph.addEdge('D', 'G'); 
  graph.addEdge('D', 'H'); 
  graph.addEdge('B', 'E'); 
  graph.addEdge('B', 'F'); 
  graph.addEdge('E', 'I'); 
  
  graph.toString()
  ```

- ![1554685310014](F:\OneDrive\JS\assets\1554685310014.png)

## 图的遍历

- 和树数据结构类似，我们可以访问图的所有节点。有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search，BFS）和深度优先搜索（Depth-First Search，DFS）。
- 图遍历可以用来**寻找**特定的**顶点**或寻找两个顶点之间的**路径**，检查图是否连通，检查图是否含有环等。
- 图遍历算法的思想是必须**追踪每个第一次访问的节点**，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出**第一个被访问的顶点**。 
- 完全探索一个顶点要求我们查看该顶点的**每一条边**。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进**待访问顶点列表**中。
- 为了保证算法的效率，务必**访问每个顶点至多两次**。连通图中每条边和顶点都会被访问到。 
- 广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是**待访问顶点列表的数据结构**。 

|   算   法    | 数据结构 | 描   述                                                      |
| :----------: | :------: | ------------------------------------------------------------ |
| 广度优先搜索 |   队列   | 通过将顶点存入队列中，最先入队列的顶点先被探索               |
| 深度优先搜索 |    栈    | 通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 |

- 当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态。 
  - 白色：表示该顶点还没有被访问。 
  - 灰色：表示该顶点被访问过，但并未被探索过。 
  - 黑色：表示该顶点被访问过且被完全探索过。 
  - 这就是之前提到的务必访问每个顶点最多两次的原因。 

### 广度优先搜索

- 广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点，如下图所示： 

  ![1554685757535](F:\OneDrive\JS\assets\1554685757535.png)

- 以下是从顶点v开始的广度优先搜索算法所遵循的步骤：

  1. 创建一个队列Q。 
  2. 将v标注为被发现的（灰色），并将v入队列Q。 
  3. 如果Q非空，则运行以下步骤： 
     1. 将u从Q中出队列； 
     2. 将标注u为被发现的（灰色）； 
     3. 将u所有未被访问过的邻点（白色）入队列； 
     4. 将u标注为已被探索的（黑色）。 

- ```js
  this.bfs = function(v, callback){ 
   
    var color = initializeColor(),  //{2} 
    queue = new Queue();        //{3} 
    queue.enqueue(v);               //{4} 
    // 如果队列非空
    while (!queue.isEmpty()){       //{5}
      // 从队列弹出一个顶点
      var u = queue.dequeue(),   //{6} 
      // 获取该顶点的邻接表
      neighbors = adjList.get(u); //{7} 
      color[u] = 'grey';                      // {8} 
      for (var i=0; i<neighbors.length; i++){ // {9} 
        var w = neighbors[i];               // {10} 
        if (color[w] === 'white'){          // {11} 
          color[w] = 'grey';              // {12} 
          queue.enqueue(w);               // {13} 
        } 
      } 
      color[u] = 'black'; // {14} 
      if (callback) {     // {15} 
        callback(u); 
      } 
    } 
  }; 
  ```

  ```js
  var initializeColor = function(){ 
    var color = []; 
    for (var i=0; i<vertices.length; i++){ 
      color[vertices[i]] = 'white'; //{1} 
    } 
    return color; 
  }; 
  ```

- 广度优先搜索和深度优先搜索都需要标注被访问过的顶点。为此，我们将使用一个辅助数组color。由于当算法开始执行时，所有的顶点颜色都是白色（行{1}），所以我们可以创建一个辅助函数initializeColor，为这两个算法执行此初始化操作。

- 我们要做的第一件事情是用initializeColor函数来将color数组初始化为white（行{2}）。

- 我们还需要声明和创建一个Queue实例（行{3}），它将会存储待访问和待探索的顶点。 

- 照着本章开头解释过的步骤，bfs方法接受一个顶点作为算法的**起始点**。起始顶点是必要的，我们将此顶点入队列（行{4}）。 

- 如果队列非空（行{5}），我们将通过出队列（行{6}）操作从队列中移除一个顶点，并取得一个包含其所有邻点的邻接表（行{7}）。该顶点将被标注为grey（行{8}），表示我们发现了它（但还未完成对其的探索）。 

- 对于u（行{9}）的每个邻点，我们取得其值（该顶点的名字——行{10}），如果它还未被访问过（颜色为white——行{11}），则将其标注为我们已经发现了它（颜色设置为grey——行{12}），并将这个顶点加入队列中（行{13}），这样当其从队列中出列的时候，我们可以完成对其的探索。 

- 当完成探索该顶点和其相邻顶点后，我们将该顶点标注为已探索过的（颜色设置为black——行{14}）。

- 我们实现的这个bfs方法也接受一个回调（我们在第8章中遍历树时使用了一个相似的方法）。这个参数是可选的，如果我们传递了回调函数（行{15}），会用到它。 



- ```js
  function printNode(value){ //{16} 
    console.log('Visited vertex: ' + value); //{17} 
  } 
  graph.bfs(myVertices[0], printNode); //{18} 
  ```

- 首先，我们声明了一个回调函数（行{16}），它仅仅在浏览器控制台上输出已经被完全探索过的顶点的名字。接着，我们会调用bfs方法，给它传递第一个顶点（A——从本章开头声明的myVertices数组）和回调函数。当我们执行这段代码时，该算法会在浏览器控制台输出下示的结果： 

  ![1554686712896](F:\OneDrive\JS\assets\1554686712896.png)

#### 使用BFS寻找最短路径

- 到目前为止，我们只展示了BFS算法的工作原理。我们可以用该算法做更多事情，而不只是输出被访问顶点的顺序。例如，考虑如何来解决下面这个问题。 

- 给定一个图G和源顶点v，找出对每个顶点u，u和v之间最短路径的距离（以边的数量计）。

- 对于给定顶点v，广度优先算法会访问所有与其距离为1的顶点，接着是距离为2的顶点，以此类推。所以，可以用广度优先算法来解这个问题。我们可以修改bfs方法以返回给我们一些信息：

  - 从v到u的距离d[u]； 
  - 前溯点pred[u]，用来推导出从v到其他每个顶点u的最短路径。 

- 让我们来看看改进过的广度优先方法的实现： 

  ```js
  this.BFS = function(v){  
  
    var color = initializeColor(), 
        queue = new Queue(), 
        d = [],    //{1} 
        pred = []; //{2} 
    queue.enqueue(v); 
  
    for (var i=0; i<vertices.length; i++){ //{3} 
      // 初始化每个顶点到源点的距离为0
      d[vertices[i]] = 0;                //{4} 
      // 前溯点为null
      pred[vertices[i]] = null;          //{5} 
    } 
  
    while (!queue.isEmpty()){ 
      var u = queue.dequeue(), 
          neighbors = adjList.get(u); 
      color[u] = 'grey'; 
      for (i=0; i<neighbors.length; i++){ 
        var w = neighbors[i]; 
        if (color[w] === 'white'){ 
          color[w] = 'grey'; 
          d[w] = d[u] + 1;           //{6} 
          pred[w] = u;               //{7} 
          queue.enqueue(w); 
        } 
      } 
      color[u] = 'black'; 
    } 
    return { //{8} 
      distances: d, 
      predecessors: pred 
    }; 
  }; 
  ```

- 初始化每个顶点到源点的距离为0（行{4}），用null来初始化数组pred。 

- 当我们发现顶点u的邻点w时，则设置w的前溯点值为u（行{7}）。我们还通过给d[u]加1来设置v和w之间的距离（u是w的前溯点，d[u]的值已经有了）。 

- 方法最后返回了一个包含d和pred的对象（行{8}）。 

  ```js
  var shortestPathA = graph.BFS(myVertices[0]); 
  console.log(shortestPathA); 
  ```

  ![1554698147689](F:\OneDrive\JS\assets\1554698147689.png)

- 通过前溯点数组，我们可以用下面这段代码来构建从顶点A到其他顶点的路径： 

  ```js
  var fromVertex = myVertices[0]; //{9} 
  for (var i=1; i<myVertices.length; i++){ //{10} 
    var toVertex = myVertices[i], //{11}   
        path = new Stack();       //{12} 
    // 其他顶点
    for (var v=toVertex; v!== fromVertex;v=shortestPathA.predecessors[v]) { //{13} 
      // 把当前点推入栈
      path.push(v);                          //{14} 
      // 取得当前点到源顶点(A)的前溯点，并赋值为当前点
      // v=shortestPathA.predecessors[v]
    } 
    // 循环结束，栈中保存了除了源顶点(A)外的顶点
    // 添加源顶点，得到完整路径
    path.push(fromVertex);        //{15} 
    // 格式化输出
    var s = path.pop();           //{16} 
    while (!path.isEmpty()){      //{17} 
      s += ' - ' + path.pop();  //{18} 
    } 
    console.log(s); //{19} 
  } 
  ```

- 我们用顶点A作为源顶点（行{9}）。对于每个其他顶点（除了顶点A——行{10}），我们会计算顶点A到它的路径。我们从顶点数组得到toVertex（行{11}），然后会创建一个栈来存储路径值（行{12}）。 

- 接着，我们追溯toVertex到fromVertex的路径（行{13}）。变量v被赋值为其前溯点的值，这样我们能够反向追溯这条路径。将变量v添加到栈中（行{14}）。最后，源顶点也会被添加到栈中，以得到完整路径。 

- 这之后，我们创建了一个s字符串，并将源顶点赋值给它（它是最后一个加入栈中的，所以它是第一个被弹出的项 ——行{16}）。当栈是非空的，我们就从栈中移出一个项并将其拼接到字符串s的后面（行{18}）。最后（行{19}）在控制台上输出路径。 

  ![1554699059738](F:\OneDrive\JS\assets\1554699059738.png)

#### 深入学习最短路径算法

+ 本章中的图不是加权图。如果要计算加权图中的最短路径（例如，城市A和城市B之间的最短路径——GPS和Google Maps中用到的算法），广度优先搜索**未必合适**。 
+ 举些例子，Dijkstra算法解决了**单源最短路径**问题。
+ Bellman-Ford算法解决了边**权值为负的单源最短路径问题**。
+ A*搜索算法解决了求**仅一对顶点间的最短路径**问题，它用**经验法则**来加速搜索过程。
+ Floyd-Warshall算法解决了求**所有顶点对间的最短路径**这一问题。 

### 深度优先搜索

+ 深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点，如下图所示： 

  ![1554699221000](F:\OneDrive\JS\assets\1554699221000.png)

+ 深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点v未访问，则访问该顶点v。 

+ 要访问顶点v，照如下步骤做：

  + 标注v为被发现的（灰色）。
  + 对于v的所有未访问的邻点w，访问顶点w，标注v为已被探索的（黑色）。 

+ 如你所见，深度优先搜索的步骤是**递归**的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）。 

+ 让我们来实现一下深度优先算法： 

  ```js
  this.dfs = function(callback){ 
    var color = initializeColor(); //{1} 
  
    for (var i=0; i<vertices.length; i++){ //{2} 
      if (color[vertices[i]] === 'white'){ //{3} 
        dfsVisit(vertices[i], color, callback); //{4} 
      } 
    } 
  }; 
  
  var dfsVisit = function(u, color, callback){ 
    color[u] = 'grey'; //{5} 
    if (callback) {    //{6} 
      callback(u); 
    } 
    var neighbors = adjList.get(u);         //{7} 
    for (var i=0; i<neighbors.length; i++){ //{8} 
      var w = neighbors[i];               //{9} 
      if (color[w] === 'white'){          //{10} 
        dfsVisit(w, color, callback);   //{11} 
      } 
    } 
    color[u] = 'black'; //{12} 
  };
  ```

+ 首先，我们创建颜色数组（行{1}），并用值white为图中的每个顶点对其做初始化，广度优先搜索也这么做的。

+ 接着，对于图实例中每一个未被访问过的顶点（行{2}和{3}），我们调用私有的递归函数dfsVisit，传递的参数为顶点、颜色数组以及回调函数（行{4}）。 

+ 当访问u顶点时，我们标注其为被发现的（grey——行{5}）。如果有callback函数的话（行{6}），则执行该函数输出已访问过的顶点。

+ 接下来一步是取得包含顶点u所有邻点的列表（行{7}）。对于顶点u的每一个未被访问过（颜色为white——行{10}和行{8}）的邻点w（行{9}），我们将调用dfsVisit函数，传递w和其他参数（行{11}——添加顶点w入调用栈，这样接下来就能访问它）。

+ 最后，在该顶点和邻点按深度访问之后，我们回退，意思是该顶点已被完全探索，并将其标注为black（行{12}）。

+ 执行过程如下图所示：

  ![1554705028085](F:\OneDrive\JS\assets\1554705028085.png)

+ 在我们示例所用的图中，行{4}只会被执行一次，因为所有其他的顶点都有路径到第一个调用dfsVisit函数的顶点（顶点A）

  > 只要路径是连通的，就可以递归访问全部顶点
  >
  > 如果是有向图？

#### 探索深度优先算法

- 对于给定的图G，我们希望深度优先搜索算法遍历图G的所有节点，构建“森林”（有**根树**的一个集合）以及一组**源顶点**（根），并输出两个数组：发现时间和完成探索时间。我们可以修改dfs方法来返回给我们一些信息： 
  - 顶点u的发现时间d[u]； 
    当顶点u被标注为黑色时，u的完成探索时间f[u]； 
    顶点u的前溯点p[u]。 

- 让我们来看看改进了的DFS方法的实现：

  ```js
  var time = 0; //{1} 
  this.DFS = function(){ 
    var color = initializeColor(), //{2} 
    d = [], 
    f = [], 
    p = []; 
    time = 0; 
   
    for (var i=0; i<vertices.length; i++){ //{3} 
      f[vertices[i]] = 0; 
      d[vertices[i]] = 0; 
      p[vertices[i]] = null; 
    } 
    for (i=0; i<vertices.length; i++){ 
      if (color[vertices[i]] === 'white'){ 
        DFSVisit(vertices[i], color, d, f, p); 
      } 
    } 
    return {           //{4} 
      discovery: d, 
      finished: f, 
      predecessors: p 
    }; 
  }; 
   
  var DFSVisit = function(u, color, d, f, p){ 
    console.log('discovered ' + u); 
    color[u] = 'grey'; 
    d[u] = ++time; //{5} 
    var neighbors = adjList.get(u); 
    for (var i=0; i<neighbors.length; i++){ 
      var w = neighbors[i]; 
      if (color[w] === 'white'){ 
        p[w] = u;                        // {6} 
        DFSVisit(w,color, d, f, p); 
      } 
    } 
    color[u] = 'black'; 
    f[u] = ++time;      //{7}  
    console.log('explored ' + u); 
  }; 
  ```

- 我们需要一个变量来要追踪发现时间和完成探索时间（行{1}）。时间变量不能被作为参数传递，因为非对象的变量不能作为引用传递给其他JavaScript方法（将变量作为引用传递的意思是如果该变量在其他方法内部被修改，新值会在原始变量中反映出来）。

- 接下来，我们声明数组d、f和p（行{2}）。我们需要为图的每一个顶点来初始化这些数组（行{3}）。在这个方法结尾处返回这些值（行{4}），之后我们要用到它们。 

- 当一个顶点第一次被发现时，我们追踪其发现时间（行{5}）。当它是由引自顶点u的边而被发现的，我们追踪它的前溯点（行{6}）。最后，当这个顶点被完全探索后，我们追踪其完成时间（行{7}）。

- 深度优先算法背后的思想是什么？边是从最近发现的顶点u处被向外探索的。只有连接到未发现的顶点的边被探索了。当u所有的边都被探索了，该算法回退到u被发现的地方去探索其他的边。这个过程持续到我们发现了所有从原始顶点能够触及的顶点。如果还留有任何其他未被发现的顶点，我们对新源顶点重复这个过程。重复该算法，直到图中所有的顶点都被探索了。 

- 对于改进过的深度优先搜索，有两点需要我们注意： 

  - 时间（time）变量值的范围只可能在图顶点数量的一倍到两倍之间； 
  - 对于所有的顶点u，d[u]<f[u]（意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了）。 

- 在这两个假设下，我们有如下的规则： 

  - $1 ≤ d [u] < f [u] ≤ 2|V| $

- 如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间： 

  ![1554706085966](F:\OneDrive\JS\assets\1554706085966.png)

- 但我们能用这些新信息来做什么呢？来看下一节。 

#### 拓扑排序——使用深度优先搜索 

- 给定下图，假定每个顶点都是一个我们需要去执行的任务： 

  ![1554707425491](F:\OneDrive\JS\assets\1554707425491.png)

  > 这是一个**有向图**，意味着任务的执行是有顺序的。例如，任务F不能在任务A之前执行。注意这个图没有环，意味着这是一个无环图。所以，我们可以说该图是一个有向无环图（DAG）。

- 当我们需要编排一些任务或步骤的执行顺序时，这称为拓扑排序（topological sorting，英文亦写作topsort或是toposort）。在日常生活中，这个问题在不同情形下都会出现。例如，当我们开始学习一门计算机科学课程，在学习某些知识之前得按顺序完成一些知识储备（你不可以在上算法I前先上算法II）。当我们在开发一个项目时，需要按顺序执行一些步骤，例如，首先我们得从客户那里得到需求，接着开发客户要求的东西，最后交付项目。你不能先交付项目再去收集需求。 

- **拓扑排序只能应用于DAG。**那么，如何使用深度优先搜索来实现拓扑排序呢？让我们在本节开头的示意图上执行一下深度优先搜索。

  ```js
  graph = new Graph(); 
  myVertices = ['A','B','C','D','E','F']; 
  for (i=0; i<myVertices.length; i++){ 
    graph.addVertex(myVertices[i]); 
  } 
  graph.addEdge('A', 'C'); 
  graph.addEdge('A', 'D'); 
  graph.addEdge('B', 'D'); 
  graph.addEdge('B', 'E'); 
  graph.addEdge('C', 'F'); 
  graph.addEdge('F', 'E'); 
  var result = graph.DFS(); 
  ```

- 这段代码将创建图，添加边，执行改进版本的深度优先搜索算法，并将结果保存到result变量。下图展示了深度优先搜索算法执行后，该图的发现和完成时间。 

  ![1554707995953](F:\OneDrive\JS\assets\1554707995953.png)

- 现在要做的仅仅是**以倒序来排序完成时间数组**，这便得出了该图的拓扑排序： **B - A - D - C - F - E** 

- 注意之前的拓扑排序结果仅是多种可能性之一。如果我们稍微修改一下算法，就会有不同的结果，比如下面这个结果也是众多其他可能性中的一个： **A - B - C - D - F - E** 

## 最短路径算法

- 设想你要从街道地图上的A点，通过可能的最短路径到达B点。举例来说，从洛杉矶的圣莫尼卡大道到好莱坞大道，如下图所示：

  ![1554708978071](F:\OneDrive\JS\assets\1554708978071.png)

-  这种问题在生活中非常常见，我们（特别是生活在大城市的人们）会求助于苹果地图、谷歌地图、Waze等应用程序。当然，我们也有其他的考虑，如时间或路况，但根本的问题仍然是：A到B的最短路径是什么？ 

- 我们可以用图来解决这个问题，相应的算法被称为最短路径。本节我们将介绍两种非常著名
  的算法，即Dijkstra算法和Floyd-Warshall算法。 

### Dijkstra 算法 

- Dijkstra算法是一种计算从**单个源**到所有其他源的最短路径的**贪心算法**（你可以在第11章了解到更多关于贪心算法的内容），这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。

- ![1554709052620](F:\OneDrive\JS\assets\1554709052620.png)

- 我们来看看如何找到顶点A和其余顶点之间的最短路径。但首先，我们需要声明表示上图的**邻接矩阵**，如下所示：

  ```js
  var graph = [[0, 2, 4, 0, 0, 0], 
               [0, 0, 1, 4, 2, 0], 
               [0, 0, 0, 0, 3, 0], 
               [0, 0, 0, 0, 0, 2], 
               [0, 0, 0, 3, 0, 2], 
               [0, 0, 0, 0, 0, 0]]; 
  ```

- 现在，通过下面的代码来看看Dijkstra算法是如何工作的：

  ```js
  this.dijkstra = function(src) { 
    var dist = [], visited = [], 
        length = this.graph.length; 
  
    for (var i = 0; i < length; i++) { //{1} 
      dist[i] = INF; 
      visited[i] = false; 
    } 
    dist[src] = 0; //{2} 
  
    for (var i = 0; i < length-1; i++) { //{3} 
      var u = minDistance(dist, visited); //{4} 
      visited[u] = true; //{5} 
  
      for (var v = 0; v < length; v++) { 
        if (!visited[v] && 
            this.graph[u][v] != 0 && dist[u] != INF && 
            dist[u] + this.graph[u][v] < dist[v]) { //{6} 
          dist[v] = dist[u] + this.graph[u][v]; //{7} 
        } 
      } 
    } 
    return dist; //{8} 
  }; 
  ```

- 行{1}：首先，把所有的距离（dist）初始化为无限大（JavaScript最大的数INF = Number. 
  MAX_SAFE_INTEGER），将visited[]初始化为false。 

- 行{2}：然后，把**源顶点**到**自己的**距离设为0。 

- 行{3}：接下来，要找出到其余顶点的最短路径。 

- 行{4}：为此，我们需要从尚未处理的顶点中选出**距离最近**的顶点。 

- 行{5}：把选出的顶点标为visited，以免重复计算。 

- 行{6}：如果找到更短的路径，则更新最短路径的值（行{7}）。 

- 行{8}：处理完所有顶点后，返回从源顶点（src）到图中其他顶点最短路径的结果。

- 要计算顶点间的minDistance，就要搜索dist数组中的最小值，返回它在数组中的索引：

  ```js
  var minDistance = function(dist, visited) { 
    var min = INF, minIndex = -1; 
   
    for (var v = 0; v < dist.length; v++) { 
      if (visited[v] == false && dist[v] <= min) { 
        min = dist[v]; 
        minIndex = v; 
      } 
    } 
    return minIndex; 
  }; 
  ```

- 对本节开始的图执行以上算法，会得到如下输出：

  ![1554709499849](F:\OneDrive\JS\assets\1554709499849.png)

## 最小生成树

## 常问的图面试问题：

- 实现广度优先搜索和深度优先搜索
- 检查一个图是否为树
- 计算一张图中的边的数量
- 找到两个顶点之间的最短路径



# 字典树

- 字典树，也叫“前缀树”，是一种树形结构，在解决字符串相关问题中非常高效。其提供非常快速的检索功能，常用于搜索字典中的单词，为搜索引擎提供自动搜索建议，甚至能用于IP路由选择。
- 下面展示了“top”“thus”和“their”这三个词是如何存储在字典树中的：
- <img src="F:/OneDrive/JS/assets/v2-618ae28f32762aef4d23b0c2b18dbbf2_hd.jpg" width='500px' /> 
- 这些单词以从上到下的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“their”的末尾

**常见的字典树面试问题：**

- 计算字典树中的总字数
- 打印存储在字典树中的所有单词
- 使用字典树对数组的元素进行排序
- 使用字典树从字典中形成单词
- 构建一个T9字典


# 堆

- 堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。