---
layout: post
#标题配置
title:  Javascript Note
#时间配置
date:   2019-3-16 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note front-end
---

* content
{:toc}





# 1. 强制类型转换
## 转换为String类型
-	方式一：
    *	调用被转换数据类型的toString()方法
    *	该方法不会影响到原变量，它会将转换的结果返回，基本数据类型的``toString()``全都被重写了
    *	注意：null和undefined这两个值没有toString()方法，如果使用这种方法会报错
-	方式二：
    *	调用String()函数，并将被转换的函数作为参数传递给函数
    *	注意：String()是大写的
    *	用String()函数做强制类型转换时，对于Number和Boolean 其实是调用的toString();对于Null和Undefined则是直接转换为字符串
-	方式三：(最常用)
    *	用+号连接含有一个以上字符串的多个变量
    *	var c = 123;
    *	c = c + “” //加一个空字符串
    *	console.log(“c = ”+ c); //表述清晰，经常使用
## 转换为Number类型
- 方式一：
    *	使用Number()函数
    *	字符串仅是数字的转换成数字，非数字显示NaN
    *	空字符串转换为0，字符串仅含空格转换为0
    *	布尔值转换为0/1
    *	Null为0
    *	Undefined 为 NaN
- 方式二：
    *	parseInt()，把一个字符串转换为整数
    *	适用于字符串含有非数字 如：a = 80px
    *	提取一个字符串中有效的整数内容，然后转换为Number
    *	从左往右读取
    ```javascript
    parseInt(123a567)  //123
    parseInt(123.456)  //123   //用于取整是舍去型
    ```
    *	如果传入的是非String，先将其转换为String，在调用parseInt() //转换用的是String()方法
    *	parseFloat()，把一个字符串转换为浮点数
    *	类似于parseInt()
    ```javascript
    parseInt(123.456.789)  //123.456
    ```
- 方式三：
    *	用+  - * / 等运算符的特性，把非Number转换成Number。调用的是Number()
    *	当值为String的时候只能用 - * /
    ```javascript
    d = “123”
    d = d – 0
    d = d * 1
    d = d / 1
    typeof d // Number
    ```
    *	当值为非Number 非String 可以用 + - * /
    ```javascript
    d = true
    d = true + 0
    typeof d // Number
    ```
- 方式四：
    * 运用 正负号 调用Number()
    ```javascript
    a = true
    a = + a //1  typeof a → Number
    a = - a //-1  typeof a → Number
    a = 1 + + “2” + 3  //6
    ```
## 非十进制数字

- 16进制数字以0x开头
```javascript
0x10  //16
0xCafe //51966 ，因为都是16进制的数字
```
- 8进制数以0开头

```javascript
070 //56
```

- 2进制以0b开头，但是不是所有浏览器都兼容
  - 对于070这样的字符串，调用``parseInt()``方法，有的浏览器会解析为70，有的是56，如：IE8

```javascript
parseInt(a,10); //十进制 70
parseInt(a,8); //8进制 56
```

## 转换为布尔值
- 调用Boolean()函数

  - Number转变为布尔值
       - 0和NaN→false
         - 其他数字→true
         - 负数也是true
  - 字符串转变为布尔值
       - 除了空字符串，其余都为true
  - Null → false
  - Undefined → false
  - Object → true

- 运用！非

  - 对非Boolean，会转换为布尔值再取反
  - 可以利用这个特点转换为布尔值
  - 类型转换调用的是Boolean()函数

```javascript
b = !!b

b = !!! typeof undefined
// typeof返回的是字符串，无法通过!判断true or false只能只用===
```

# 2. 运算符

- 运算符也叫操作符：

- 通过运算对一个或者多个值进行运算，**并获取运算结果**
  - 比如：``typeof``就是运算符（而不是函数），可以获得一个值的类型。它会将该值的类型以**字符串**的形式返回。 

```javascript
typeof null //Object
typeof a  //number 
typeof typeof a  //string
delete
```

## 算数运算符
- 对于非Number的值进行运算时，都会转换为Number然后运算

- 比如：``true → 1 false → 0 NaN → 0 Undefined → NaN``

- 任何值和``NaN``计算，都得``NaN``

- **只有 + 运算符 会有拼串操作**， 其他的会把字符串也转换Number

### +加号

  - 对两个值进行加法运算，并将结果返回
  - 如果对两个字符串进行加法运算，则会做拼串操作

    ![1546491428535](F:\OneDrive\JS\纲略合集\assets\1546491428535.png)

  - 分号不可以换行，利用加号的特性对长字符串进行排版
  - 任何的值和字符串做运算，都会先转换为字符串再做拼串操作**//底层使用String()**

```javascript
c = 1 + 2 + “3” // c = 33
c = “1”+ 2 + 3 // c = 123
```

### -减号

- 对两个值进行减法运算，并将结果返回

### /除号
  - 对两个值进行除法运算，并将结果返回

### *乘号

- 对两个值进行乘法运算，并将结果返回

### % 取模(取余数)

- 对两个值进行模除运算，并将结果返回

## 一元运算符

- 只需要一个操作数的运算符。比如：``typeof``

### +正号 – 负号

- 正号不会对数字产生任何影响

- 负号对数字进行符号取反

```javascript
a = true
a = + a //1  typeof a → Number
a = - a //-1  typeof a → Number
```

- 对于非Number值会先转换为Number 再运算

### 自增++

- i ++ 先返回i 再自增，等于原值（自增前的值）

```javascript
var i =20
i = i ++ 
// i 的原值不变  
//i变成了21 又被赋予了 i ++ 的值 即 20
```

- ++ i 先自增再返回 i ，等于新值（原值+1）
- 无论是++ i 还是 i ++ ，i 的值都会马上+1，区别只是两个运算符返回的值不同

```javascript
var c = 10
c++
console.log(c++) //11
var d = 20
console.log(++d) //21
console.log(++d)//22
var e = 20
result = e++ + ++e + e //20 + 22 + 22
```

- 利用自增实现循环，i++，i = i%5 //实现0-4 i不断循环

## 逻辑运算符

### ! 非

  - 对布尔值进行取反，并返回结果
  - 对非Boolean，会转换为布尔值再取反

  - 可以利用这个特点转换为布尔值

  - b = !!b; 两次取反转换为布尔值

  - 调用的是Boolean()函数

### && 与

- 对两侧进行与运算，并返回结果
  - 男女真心相爱 true && true
  - 不是真心相爱 false && true

- JS的与是短路的与，如果第一值为false则不会看第二值，表现为：

  - 如果第一个值为false，则返回第一个值

  - 如果第一个值为true，则返回第二个值

```javas
 true && alert(“”) //alert()会执行
1 && 2 // 2 
```

### || 或

- 对两侧进行或运算，并返回结果

- 或是亲情
  - false || true 父母不爱我，但是我爱着父母，还会住在

- 或也是短路的或，如果第一个值是true则不会检查第二个值，表现为：

  - 第一个值为true，返回第一个值

  - 第一个值为false，返回第二个值
```javascript
false || alert()  //会执行
1 || 2 // 1
```

### && ||  面对非Boolean的情况

- 先转换为Boolean，再运算，并且返回**原值**，而不是true false

- 与运算，都是true，返回第二个值

- 或运算，都是false，返回第二个值

## 赋值运算符

### =赋值号

- += 

```javascript
a += 5 // a = a+5

var str = "hello"; 
str += "world"
```

- 加号和等中间不能有空格

- -=

- *=

- /=

- %=

### 关系运算符

- 关系运算符用来比较两个值之间的大小关系的

  - \> 

  - \>=

  - < 

  - <=       

- 关系运算符的规则和数学中一致，用来比较两个值之间的关系，
  - 如果关系成立则返回true，关系不成立则返回false。

  - 如果比较的两个值是**非数值**，会将其转换为Number然后再比较。
    - 一个非Number非String 和 一个 String

    - 所以 任何值 和 NaN比较都是 false

- 如果比较的两个值**都是字符串**，此时会比较字符串的Unicode编码，而不会转换为Number。

```javascript
console.log(“11” < “5”); //true 先拿1和5比
console.log(“11” < +“5”)； //这样就可以了
console.log(“abc” < “b”) //a和b比，比完就ok
console.log("abc" > "ab"); //true
```
- 如果两位一样，就比较下一位

- 应用：人名按字母排序 比较中文没有意义

### UTF-8万国码

- 字符串中使用转移字符\u输出，16进制位

```javascript
console.log(“\u0031”) //1
```

- 在HTML页面中：&#编码；

- 10进制位

## 相等运算符

### ==

- 如果相等会返回true

- 会自动转换类型，转换的情况不一定，一般情况下会转换为Number 

```javascript
console.log(1 == 1); //true
console.log(“1” == 1); //true
console.log(“1” ==  true); //true
console.log(null==  0); //false
```

- undefined 衍生自 null，所以==判断会返回true

- NaN不和任何值相等，包括他本身，
  - 可以通过isNaN()函数判断是否是NaN

### ！=

- 如果不相等返回true

- 会自动转换类型，转换的情况不一定，一般情况下会转换为Number

### ===

- 全等运算符，用于判断是否全等

- 不同的是：不会做自动的类型转换，即类型不同直接返回false

```javascript
console.log(“1” === 1); //false
console.log( null === undefined); //false 因为null undefined 是两个类型
```

### ！==

- 不全等，用于判断两个值是否不全等

- 不会做自动的类型转换，即类型不同直接返回true

## 条件运算符
- 条件运算符在执行时，首先对条件表达式进行求值，如果该值为true，则执行语句1，并返回执行结果，如果为false则执行语句2 ，并返回执行结果

```javascript
条件表达式?语句1:语句2  //语句结束的分号可加可不加
true?语句1:语句2； //语句2
var max = a>b?a:b;
max = max>c?max:c;
var max = a>b?(a>c?a:c):(b>c?:b:c); //这种写法不推荐使用，可读性不好，性能没有区别，记得加括号
```

- 如果条件表达式是非布尔值，会先转换为布尔值

- 条件运算符?和：是**一对运算符**,不能分开单独使用

- 条件运算符的结合方向是自右至左，保证最外层只有一个条件运算符

```javascript
a>b?a:c>d?c:d 
//应理解为 
a>b?a:(c>d?c:d)
```

- 因为条件运算符的优先级较低，所以一定要加上括号防止出现bug 

### 运算符的优先级

- ,运算符

- 使用，可以分割多个语句，一般在声明多个变量的时候使用

- 多用括号，可以减少背诵

- **单目加减** 优先级 高于乘除，**因为是代表正负**

![1546493837873](F:\OneDrive\JS\纲略合集\assets\1546493837873.png)

# 3. 流程控制语句

## 条件判断语句

```javascript
if语句
if(条件表达式)
	{语句...}
else
	{语句...}
```

- 定义域要覆盖满，大于100，小于0都是不合法的

- else{}嵌套if else，也有 else if {} 语句。差别在于代码段的分配

- 多个数从大到小输出

- 每个数比较，else到最后自己alert分支排序

- 条件判断，一定要注意不要写成 = 赋值号

## 条件分支语句

```javascript
switch语句
switch(条件表达式){
case 表达式：语句；
	break； //case后的都会执行，所以需要break
default：语句；
	break；
}
```

```javascript
/*
对于成绩大于60分的，输出“合格”。低于60分的，输出“不合格”
6x/10 = 6.x
7x/10 = 7.x
*/
var score = 75;
//方法一：
switch(parseInt(score/10)){
  case 10:
  case 9:
  case 8:
  case 7:
  case 6:
    console.log("合格")
    break
  default:
    console.log("不合格")
    break
}
//方法二：
switch(true){
  case score >= 60:
    console.log("合格")
    break
  default:
    console.log("不合格")
    break
}
```

- 因为switch是判断条件表达式和case表达式的**值是否相等**，进而选择
  - 使用严格运算符 `===`
- 第二种方法更常用，多个表达式，只有一个是正确的，直接设置条件表达式为true，，但是其他语言不会这样写的样子

## 循环语句

- 循环的三要素：初始化变量、循环判断语句、变量更新语句- 

### while语句

```javascript
while(条件表达式){
	语句//循环体
}  
```

- while语句在执行时，会先对条件表达式进行求值判断，

- 如果判断结果为false，则终止循环

- 如果判断结果为true，则执行循环体循环体执行完毕，继续对条件表达式进行求值判断，依此类推

```javascript
while (true){
	i++;
	if(i=10){
	break;
	}
} //直接进入循环体，就相当于do while  
```

### do while 语句

```javascript
do{语句...}
while(条件表达式);
```

- 会先执行do后的循环体，然后在对条件表达式进行判断，如果判断判断结果为false，则终止循环。

- 如果判断结果为true，则继续执行循环体，依此类推

- 和while的区别：
  - while：先判断后执行

  - do...while: 先执行后判断
  - do...while可以确保循环体至少执行一次。

### for语句

- for语句专门提供了位置用于放置三要素

```javascript
for(1.初始化表达式；2.条件表达式；4.更新表达式；){3.语句}
```

- 初始化表达式，可以进行定义，赋值瘦身

- 执行流程：
  - 首先执行①初始化表达式，初始化一个变量，

  - 然后对②条件表达式进行求值判断，如果为false则终止循环

  - 如果判断结果为true，则执行③循环体

  - 循环体执行完毕，执行④更新表达式，对变量进行更新。

  - 更新表达式执行完毕重复②

- for循环三个语句都可以省略
  - 如果条件表达式不写，则判断为true

- 嵌套的for循环，要注意初始化变量

- i—也是存在的 不要太惯性思维， 5-i

### break和continue关键字

- break

- 可以立即跳出最内层循环或switch语句
  - 可以创建一个label，来表示当前循环，即可做到跳出相应循环
  - label（可以是任意）：循环语句
  - break label；
  - 不可以单独用于if
- continue
- 可以跳过余下内容，马上执行下一次循环
- 同样作用于内层循环

```js
var i, j;
loop2:
for (i = 0; i < 3; i++) {      //The first for statement is labeled "loop1"
   loop2:
   for (j = 0; j < 3; j++) {   //The second for statement is labeled "loop2"
      if (i == 1 && j == 1) {
         continue loop2;
      }
      console.log("i = " + i + ", j = " + j);
   }
}

// Output is:
//   "i = 0, j = 0"
//   "i = 0, j = 1"
//   "i = 0, j = 2"
//   "i = 1, j = 0"
//   "i = 2, j = 0"
//   "i = 2, j = 1"
//   "i = 2, j = 2"
// Notice how it skips both "i = 1, j = 1" and "i = 1, j = 2"

var i, j;
loop1:
for (i = 0; i < 3; i++) {      //The first for statement is labeled "loop1"
   loop2:
   for (j = 0; j < 3; j++) {   //The second for statement is labeled "loop2"
      if (i == 1 && j == 1) {
         break loop1;
      }
      console.log("i = " + i + ", j = " + j);
   }
}
// Output is:
//   "i = 0, j = 0"
//   "i = 0, j = 1"
//   "i = 0, j = 2"
//   "i = 1, j = 0"
// Notice the difference with the previous continue example
```

# 4. 对象

- 对象是JS中的引用数据类型

- 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性

- 使用typeof检查一个对象时，会返回object
  - 数据类型Object是大写的，但是返回的是小写

## 对象的分类

- 内建对象

  - 由ES标准中定义的对象，在任何的ES实现中都可以直接使用
    - 比如：Math. String() Number() Boolean()

- 宿主对象

  - 由JS的运行环境提供的对象，主要是指由浏览器提供的对象

  - 比如： BOM DOM console.log document.write

- 自定义对象

  - 由开发人员自己创建的对象

## 创建对象

- 方式一：
  - var obj = new Object()  ;
  - 运用new关键词调用函数Object()创建对象
  - 这里Object()被称为构造函数constructor，构造函数是专门用来创建对象的

- 方式二：

```javascript
var obj = {
  属性名:属性值,
  属性名:属性值,
	属性名:属性值,
	属性名(变量名):{名值对} //对象的值可以是对象
	方法名:function(){    }
}； //赋值语句，分号结尾
```

- 属性名可以加引号，使用特殊属性名时一定要加
- 名值对

## 向对象中添加属性

- 语法：

```javascript
对象.属性名 = 属性值；
对象[“属性名”] = 属性值；
```

- 对象的属性名没有任何要求，不需要遵守标识符的规范，但是还是应该尽量去遵守

- 用字面量创建更加灵活，能以数字为属性名，能传递变量调用相应的属性

```javascript
obj[“123”] = “一二三”；
var n = “123”;
console.log(obj[n]); //注意n没有双引号，因为"123"
```

  - 属性值可以任意数据类型

```javascript
obj.name = "庞劲"; //typeof string
obj.age = 18; // typeof number
obj.b = true;// typeof boolean
obj.obj2
```

- console.log(obj);会输出对象的所有属性 //Object { name=“孙悟空”，age=18,b=true }

## 读取对象中的属性

- 语法：

```javascript
对象.属性名
对象["属性名"] //有引号
```

- 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined

## 修改对象的属性值

- 语法：

```javascript
对象.属性名=新值；
对象["属性名"] = 新值;
```

## 删除对象的属性值

- 语法：

```javascript
delete 对象.属性名;
delete 对象["属性名"];
```

## in运算符

- 语法："属性名" in 对象

- 如果在对象或其原型链中含有该属性，则返回true

- 如果没有则返回false

## 枚举对象中的属性

- 使用for…in 语句 

```javascript
for(var 变量 in 对象){}

for(var n in obj){
console.log(n); //打印属性名
console.log(obj.n); //错误，obj里并没有属性n
console.log(obj[n]);//正确，向obj动态传递了属性名，可以打印属性值
}
```

- for…in语句，对象中有几个属性，循环体就会执行几次

- 每次执行时， 会把一个属性的名字赋值给声明的变量

## 变量基本数据类型和引用类型

- 基本数据类型的数据，变量是直接保存的它的值

- 变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。

- 基本数据类型：

  - a = b;
  - 把a的值复制了一份给b

  - 在栈内存中保存了变量（名）和值

- 引用数据类型，变量保存的对象的引用（堆内存地址、通过指针）
- 如果多个变量指向的是同一个对象，此时修改一个变量的属性**（其实是对象的属性）**，会影响其他的变量。因为他们的指针是相同的，指向同一个对内存地址

- 但是直接修改变量的值**（给变量赋其他值）**，不会影响其他变量的引用

- 只有创建新的对象才会在**堆内存**中开辟新的空间，一旦**new**了一个新对象，**就没有办法人为的删除他**，只能切断所有指针，让其变成垃圾对象被回收

```javascript
obj2 = obj //并没有构建函数，而是把obj的指针复制给obj2
```

- 比较两个变量时

  - 对于基本数据类型，比较的就是值，

  - 对于引用数据类型比较的是地址，地址相同才相同

```javascript
var c=10,d=10 ; // c==d true
var obj3 = new Object();
var obj4 = new Object(); //两者属性、方法完全一致， obj3 == obj4 false 像是两个双胞胎
```

| 变量              | 值                                            |
| ----------------- | --------------------------------------------- |
| a                 | 123                                           |
| b (b = a)         | 123 （把a的值复制下来）                       |
| obj               | 0x123 （堆内存的地址，保存着obj的属性和方法） |
| obj2 (obj2 = obj) | 0x123（把obj的值复制下来，有了相同的指针）    |

- 49集

# 5. 函数

- 函数也是一个**对象**，也具有普通对象的功能
- 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码

- 使用typeof检查一个函数时会返回**function** //与普通Object不同

## 函数的声明
- 通过关键字function
- 直接声明
```javascript
function 函数名([形参1,形参2...形参N]){
	语句...
} //不用分号结尾
```
- 通过关键字function
- 使用函数表达式
```javascript
var 函数名 = function([形参1,形参2...形参N]){
	语句…
}；//实质：把匿名函数复制给一个变量，所以赋值语句分号结尾
```
- 通过构造函数Function()
- var fun = new Function(**语句**);

## 函数调用

- 语法：函数对象([实参1,实参2...实参N]);
  - fun() sum() alert() Number() parseInt()

- 当我们调用函数时，函数中封装的代码会按照编写的顺序执行

## 形参和实参

- 形参：形式参数
  - 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开定义形参就相当于在函数内声明了对应的变量但是并不赋值，形参会在调用时才赋值。

- 实参：实际参数
  - 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,
  - 调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。
    - 如果实参的数量大于形参，多余实参将不会赋值
    - 如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined

## 函数的返回值

- 返回值，就是函数执行的结果。使用return 来设置函数的返回值。

- 语法：return 值
  - 该值就会成为函数的返回值，可以通过一个变量来接收返回值

- return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出，不光是退出循环

- return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。

- 当需要传递的参数太多的时候，可以考虑封装到一个对象中

- 如果return后不跟值，或者是不写return则函数默认返回undefined。

```javascript
function(sayHello);// function 函数对象
function(sayHello()); // function()调用函数,相当于使用函数的返回值

function fun3(){
  function fun4(){
    alert(“我是fun4”);
    }
  return fun4;
}
a = fun3()
a() //fun3()() → fun4()
(functoin(a,b){
	alert(“我是一个匿名函数”);
console.log(a);
console.log(b);
})(a,b)； 
//匿名函数用()包着，表示是一个整体，相当于省略了var的部分，然后在一个()立即调用，就可以创造一个一次性的立即执行的函数而不同特地开辟内存空间去保存它
```

## 方法

- 可以将一个函数设置为一个对象的属性，当一个对象的属性是一个函数时我们称这个函数是该对象的方法。

- 对象.方法名();

- 函数名();

### call()和apply()

- 这两个方法都是函数对象的方法需要通过函数对象来调用

- 通过两个方法可以直接调用函数（执行函数），并且可以通过第一个实参来指定函数中this
  - 本质：让该临时函数成为实参的方法

```javascript
fun(){alert(this);}//window
fun(obj){alert(this);}//obj
```

- 这两个方法，让函数可以在更多的场合应用this

```javascript
obj.sayName.call(obj2);//obj2
//call()方法可以将实参在对象之后一起传递
fun.call(obj,2,2);
//不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递
fun.apply(obj,[2,3]);
```

### arguments

- arguments和this类似，都是函数中的隐含的参数

- arguments是一个**类数组对象**，它用来封装函数执行过程中的实参
- 不是数组，但是具有下标索引和length属性，没有foreach方法

```javascript
arguments instanceof Array //false
Array.isArray(arguments); //false
```

- arguments.length; //可以用来获取**实参**的数量（长度），不受形参的影响

- 也可以用其他方法，来操作实参，所以即使不定义形参，也可以通过arguments来使用实参

### callee

- arguments中有一个属性callee表示当前执行的函数对象

- arguments.callee == fun;//true

# 6. 作用域

- 作用域简单来说就是一个变量的作用范围。

## 全局作用域

- 接在script标签中编写的代码都运行在全局作用域中

- 生命周期：全局作用域在打开页面时创建，在页面关闭时销毁。

- 全局作用域中有一个全局对象window，window对象由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口。

- 在全局作用域中创建的变量都会作为window对象的属性保存，在全局作用域中创建的函数都会作为window对象的方法保存

```javascript
console.log(window.b); //b未定义，找一个属性未定义会返回undefined
console.log(b);//一个变量未定义，则会报错
```

- 在全局作用域中创建的变量和函数可以在页面的任意位置访问。在函数作用域中也可以访问到全局作用域的变量。

- 我们创建的函数，其实就是window的方法，所以函数和方法没有本质的区别，就是名字不同而已

- 尽量不要在全局中创建变量

## 函数作用域

- 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。

- 生命周期：函数作用域在函数执行时创建，在函数执行结束时销毁。

- 在函数作用域中创建的变量，不能在全局中访问。

- 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，如果找到了则使用，找不到则继续向上找，一直会

```javascript
var e=20;
function fun(){
	alert(e);
} //20;
function fun2(e){
	alert(e);  //形参相当于在函数内部var e；如果不传递参数就直接找到了e
}//undefined 
```

## 变量的声明提前

- 在**全局作用域中**，使用var关键字声明的变量会在所有的代码执行之前被声明，**但是不会赋值**。

- 所以我们可以在变量声明前使用变量。但是**不使用var**关键字声明的变量不会被声明提前。

- 在**函数作用域中**，也具有该特性，使用var关键字声明的变量会在**函数**所有的代码执行前被声明，

- 如果没有使用var关键字声明变量，则变量会变成全局变量

```javascript
a = 123； //不用var关键字，相当于是window.a
```

- 所以在函数中不使用var 给已存在的变量赋值，会影响到全局变量的值

```javascript
//eg1
c=10；
function fun(){
	c=20;  //(window.)c=20;
}
fun();
console.log(c); //c=20
//eg2
c=10；
function fun(){
	var c=20;  //全局中的c不受影响
}
fun();
console.log(c); //c=10
```

## 函数的声明提前

- 在**全局作用域中**，使用**函数声明**创建的函数``function fun(){}``,会在所有的代码执行之前被创建，也就是我们**可以在函数声明前去调用函数。**
- 但是使用函数表达式``var fun = function(){}``创建的函数没有该特性

- var 关键字，其实是variety，就是变量的意思，和function是类似的

- 提前使用函数也是没问题的，因为整个函数都被创建好了，不光是声明了函数

```javascript
fun();
function fun(){	};//没问题
```

- 在**函数作用域中**，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。

# 7. this

- 我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数，这个参数就是this

  - 还有一个就是arguments

- 使用this来引用对象，根据函数的**调用形式**不同，this的值也不同。 

  - 跟上下文其实没有关系，就是看谁在调用函数
  - 以**函数的形式**调用时，this是window ``//window.fun``

  - 以**方法的形式**调用时，this就是调用方法的对象
  - 使用call()和apply()调用时，this是传入的对象，相当于是把函数作为对象的临时方法，然后调用
  - 在**事件响应函数**中，给谁绑定函数，谁就是this
    - 虽然事件响应函数的回调函数也是匿名函数，但是如果使用了箭头函数，就会导致this变成window
    - 底层以方法的形式调用函数
    - 包括所有的**事件委托、回调函数**等
    - 但是：attachEvent()中的this，是window

- 但是jQuery中，调用delegate()和on()方法，this是传入的selector

- $(“#box1”);返回的值是**jQuery对象**，this是**dom元素对象**

- jQuery对象.each(function(this){}) 
  - 此时this是各个元素对象，因为隐式遍历 
  - 这个应该是特殊的，可以理解成为每一个DOM元素对象调用回调函数，所以是指向单个的DOM元素

- $(this)： 把普通的this传入$()，转化为jQuery对象，从而调用jQuery对象的方法，普通的this在jQuery函数中只是DOM对象，不是jQuery对象，所以只能调用DOM对象方法

- jQuery的链式调用过程中，$(this)始终是链式调用的父对象
  - 因为链式调用就是通过$(this)不断返回调用对象，进而链式
  - 如果是获得子孙之后对子孙调用函数，在函数内部的回调函数的this自然是子孙自己，其余的都是链式调用的父对象

- 以构造函数的形式调用时，this就是新创建的对象

- reference type 和 this 的关系

  - //与是不是方法没有关系，本质都是把函数的引用传递给了一个变量，然后某个对象读取了这个变量值（调用了this），这个对象就是this

  - 谁在引用某个函数，这个谁就是this

  - ```javascript
    var obj={
      fn2:function(){
        console.log(this) //obj
      }
    }
    obj.fn2()
    
    var obj={
      fn2:function(){
        return (function(){console.log(this)})() //window
      },
      age:18
    }
    obj.fn2()
    
    let bar = foo.baz;
    
    bar();       
    // 'this' 指向全局 window 对象，因为
    // 没有指定引用对象，把baz指向的函数的内存地址赋值给了bar，没有谁在调用这个函数
    ```

#### 原型链中的 `this`

对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么`this`指向的是调用这个方法的对象，就像该方法在对象上一样。

```js
var o = {
  f: function() { 
    return this.a + this.b; 
  }
};
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5
```

在这个例子中，对象`p`没有属于它自己的`f`属性，它的f属性继承自它的原型。虽然在对 `f` 的查找过程中，最终是在 `o` 中找到 `f` 属性的，这并没有关系；查找过程首先从 `p.f` 的引用开始，所以函数中的 `this` 指向`p`。也就是说，因为`f`是作为`p`的方法调用的，所以它的`this`指向了`p`。这是 JavaScript 的原型继承中的一个有趣的特性。

- bind()
- 定时器的this是window，因为最后再队列里把他取出来执行的是window

# 8. 工厂模式创建对象

```javascript
function creatPerson(name,age,gender){
	var obj = new Object();
	obj.name=name;
	obj.age=age;
	obj.gender=gender;
	obj.sayName=function(){
	alert(this.name);
};
}
var obj2= creatPerson(“猪八戒”,18,”男”)；
```

### 缺点

- 使用工厂方法创建的对象，使用的构造函数都是Object
- 所以，创建的对象都是Object类型，导致我们无法区分多种不同类型的对象
- 用的不多

# 9. 构造函数创建对象

- 一般构造函数首字母会大写（习惯）

- 构造函数是专门用来创建对象的函数

- 一个构造函数我们也可以称为一个类![img](file:///c:\temp\msohtmlclip1\01\clip_image002.jpg)
  - 使用工厂模式全都是Object类

- 通过一个构造函数创建的对象，我们称该对象是这个构造函数的实例

- 通过同一个构造函数创建的对象，我们称为一类对象

- 构造函数就是一个**普通的函数**，只是他的**调用方式不同**
  - 如果直接调用，它就是一个普通函数，返回函数的返回值
  - 如果使用new来调用，则它就是一个构造函数，**返回的是对象**

```javascript
function Person(){}
var per = new Person();
```

- 构造函数的执行流程：

1. 创建一个新的对象 //new 关键字，立即在堆内存创建一个对象
2. 将新建的对象设置为函数中this,可以使用this来引用新建的对象
3. 逐行执行函数中的代码
4. 将新建的对象作为返回值返回
   - 实质与new Object()相同
```javascript
function Person(){this.name=“孙悟空”;}
var per = new Person();  // per.name=”孙悟空”
```

- instanceof 用来检查一个对象是否是一个类的实例

```javascript
语法：对象 instanceof 构造函数
console.log(per instanceof Person); //true
```

- 如果该对象是构造函数的实例，则返回true，否则返回false

- **Object**是所有对象的祖先，所以任何对象和Objec做instanceof都会返回true

### 缺点

- 无论是工厂模式还是构造函数模式，在函数体内直接定义方法会为每一个对象都创建一个相同功能的方法，所以希望能够让这些对象共享同一个方法。

- 比如，让sayName()方法，在全局作用域中定义，再赋值到函数体内部

- ``per.sayName()==per2.sayName() //true``

- 但是在全局作用中定义方法，污染了全局作用域的命名空间，而且全局作用域中的方法名字很不安全，其他共同工作的程序猿也喜欢这个名字，引出原型概念，**工厂模式和构造函数方法都是弟弟**

# 10.原型模式创造对象

- 创建一个**函数**以后，解析器都会默认在函数中添加一个属性prototype //调用函数会传递this

- ``Mycalss.prototype == Person.prototype //false``

- 每个函数的原型对象是不一样的，为什么？
  - ![img](file:///c:\temp\msohtmlclip1\01\clip_image002.jpg)就是字面意义的不同
  - 两个不同的对象，对象的原型也不可能相同

- **prototype属性**指向的是一个对象，这个对象我们称为**原型对象**。

- 当函数作为**构造函数**使用，它所**创建的对象**中都会有一个**隐含的属性**指向该原型对象。
  - 这个隐含的属性可以通过``对象.__proto__``来访问
  - 隐式原型，指向构造函数的显示原型
  - 这个访问方法是浏览器提供的，有两个下划线

```javascript
var mc = new Myclass();
mc.__proto__ == Myclass.prototype; //true
```

- 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。我们可以将对象中共有的属性和方法统一添加到原型对象中，这样我们只需要添加一次，就可以使所有的对象都可以使用。

- 当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，如果在自身中找到了，则直接使用。如果没有找到，则去原型对象中寻找，如果找到了则使用，如果没有找到，则去原型的原型中寻找，依此类推。直到找到Object的原型为止，**Object的原型的原型**为null，如果依然没有找到则返回undefined

## 创建函数的正确方法

1. 需要传递参数的在构造函数传递

2. 对象共有的属性和方法统一添加到构造函数的对象中

3. 特定实例需要修改的属性和方法，直接在实例中修改

```javascript
function Person(name,age,gender){ //需要传递参数的在构造函数传递
this.name=name,
	this.age=age,
	this.gender=gender
}
Person.prototype.sayHello=function(){ //对象共有的属性和方法统一添加到构造函数的对象中
	alert(“你好，我是”+name);
}
var per = new Person(“孙悟空”,18,”男”)；
per.sayHello();
```

## hasOwnProperty()    

- 这个方法可以用来检查对象自身中是否含有某个属性，

- 语法：``对象.hasOwnProperty("属性名")``

- 因为 in 无法区分自身的属性和原型属性

- hasOwnProperty()是在原型对象的原型的方法，**即Object对象的方法**，但是原型的原型的原型是null，即Object对象的原型是null

```javascript
mc.__proto__== MyClass.prototype //true
mc. __proto__.__proto__== Object.prototype //true，是Object的原型，实例和构造函数共享原型
mc. __proto__.__proto__.__proto__==null //true
```

![1546501186480](F:\OneDrive\JS\纲略合集\assets\1546501186480.png)

# 11. 原型链

- 显式原型：prototype

- 隐式原型：``__proto__``

1. 显式原型和隐式原型是什么？

- 在js中万物皆对象，方法(Function)是对象，方法的原型（Function.prototype）是对象，对象具有属性``__proto__``称为**隐式原型**，对象的隐式原型**指向**构造该对象的**构造函数的显式原型**（prototype）。

- 方法(Function)是一个特殊的对象，除了和其他对象一样具有``__proto__``属性以外，它还有一个自己特有的原型属性(**prototype**)，这个属性是一个指针，指向**原型对象**。

- 原型对象也有一个属性叫**constructor**，这个属性包含一个指针，指向原**构造函数**。
  - 虽然原型对象也是**某个构造函数**的实例，但是因为它是原型对象，所有constructor被设计成指向实例**构造函数**

  - ```javascript
    function Foo(){}
    Foo.prototype instanceof Foo //false
    Foo.prototype.constructor === Foo //true
    //构造函数是Foo，但却不是Foo的实例
    ```

  - 原型对象，constructor和instanceof 不一致

  - 普通对象，constructor和instanceof 一致

  - 本质：new出来的对象，本身是没有constructor属性的，它的constructor需要到它的**原型链**去找。所以Foo.prototype**确实是Object的实例**，如果可以屏蔽本身的constructor属性，就会沿着原型链向上查找，

  - ```javascript
    function Foo(){}
    Foo.prototype.constructor === Object //false
    delete Foo.prototype.constructor
    Foo.prototype.constructor === Object //true
    ```

- 原型链沿着隐式原型``__proto__``

- 所有的对象都源于Object

- 函数的显示原型指向对象，默认是空Object**实例**对象（不包括Object构造函数，Object的prototype不是实例对象）

- 所有的函数源于Function构造函数

- 所有函数都是Function的实例（包括Function本身）

```javascript
function Foo() 
var Foo = new Functoin()
```

- 所有函数的隐式原型``__proto__``都是一样的，包括Function自己

```javascript
Function = new Function()
Function.__proto__=== Function.prototype
```

# 12. 垃圾回收

- 当一个对象没有任何变量或属性对它引用，此时我们将永远无法操作这个对象（堆内存），这种对象称为垃圾。

- 在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象进行销毁，我们**不需要也不能**进行垃圾回收操作。

- 我们需要做的是：将不再需要使用的对象设置为null即可

# 13.数组(Array）

- 数组也是一个对象，它和我们普通对象类似，不同的是：
  - 普通对象用名值对来储存数据，而数组通过数字来索引(index)、操作元素。
  - （属性和元素只是名字不同，其实是一样的）

- 索引：从0开始的整数

- 数组的存储性能比对象要好，所以在开放中经常用数组来存储一些数据

## 创建数组对象

```javascript
var arr = new Array(); //也可以将要添加的元素直接传递
var arr = []; 
typeof arr;//object
arr.name=array1; //也是可以的，但是不会影响length的值
```

## 向数组中添加元素

```javascript
数组[索引] = 值；//值可以是任何数据类型，当然也可是是对象
arr[0] = 10;
arr = [{name:””},{ name:””},{ name:””}]
arr = [function(){},function(){}]
//值为数组额，则二维数组，多维数组
```

## 读取数组中的元素

```javascript
console.log(arr[0]); //10
```

- 如果读取不存在的索引，不会报错，而是返回undefined
- 说明：索引和属性很类似

## 数组属性、方法

### 定义数组的长度

```javascript
var arr1 = [10]; // 只有一个元素10
var arr2 = new Array(10); //数组长度为10
```

- 区别在于，当向数组只传递一个数字的时候，字面量形式是单个元素，构造函数形式是数组长度

- 定义数组对的长度意义不大，因为限制数组长度在JS里没有多大意义

### length属性

- 设置或返回连续的数组中的长度（元素的个数）

- arr.length
  - 对于**非连续**的数组，会获取到最大的索引+1

```javascript
arr[10]=11; //arr.length = 11;
console.log(arr);//非连续数组，中间的内容会为空，以逗号链接
```

- 修改数组长度：``arr.length = newLength``
  - 如果修改后的length大于原长度，则多出的部分会空出来
  - 如果修改后的length小于原长度，则原数组中多出的元素会被删除

- 向数组的最后添加元素
  - 数组[数组.length] = 值; //length的值刚好是最大索引+1，可以做到给最后一位添加元素
  - 只能添加一个元素，不如push()

### push()

- 用来向数组的末尾添加一个或多个元素，**并返回数组新的长度**

- 语法：数组.push(元素1,元素2,元素N)

- 可以添加多个，比length属性方便

### pop()

- 用来删除数组的最后一个元素，并**返回被删除的元素**

### unshift()

- 向数组的**前边**添加一个或多个元素，并**返回数组的新的长度**

### shift()

- 删除数组的**前边**的一个元素，并**返回被删除的元素**

### slice()

- 可以从一个数组中截取指定的元素

- **该方法不会影响原数组**，而是将截取到的内容封装为一个新的数组并返回

- 因为索引从0开始，而且不包括结束位置，所以限制多少个就输入多少就行，比如截取前100个，保留的就是0-99.所以slice(0,100)

- **参数：**

1. 截取开始位置的索引（包括开始位置）

2. 截取结束位置的索引（**不包括结束位置**）

   - 第二个参数可以省略不写，如果不写则一直截取到最后
   - 参数可以传递一个负值，如果是负值，则从后往前数 //-1，倒数第一个

- 如果结束位置大于开始位置``arr.slice(2,0)``，则返回结果，空数组``[]``

### splice()

- 可以用来删除数组中指定元素，**并使用新的元素替换**

- 该方法会将删除的元素封装到新数组中返回

- 参数：

1. 删除开始位置的索引
2. 删除的个数
3. 第三个参数以后，都是替换的元素，这些元素将会插入到开始位置索引
   - 删除0个，增加一些，实现增
   - 删除多个，不增加，实现删
   - 删除N各，替换N个，实现改

### concat()

- 可以连接两个或多个数组，**它不会影响原数组**，而是新数组作为返回值返回

### join()

- 可以将一个数组转换为一个字符串，**不会影响原数组**

- 参数：
  - 需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素
  - 如果不指定连接符则默认使用,

### reverse()

- 可以用来反转一个数组，它会**对原数组产生影响**

### sort()

- 可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序，调用以后，会**直接修改原数组**。

- 可以自己指定排序的规则，需要一个回调函数作为参数：

```javascript
数组.sort(function(a,b){
//升序排列
//return a-b
//降序排列
return b-a
})
```

- 浏览器会传入数组的元素作为实参调用回调函数
  - 大于0的值，交换位置
  - 小于等于0，位置不变
  - 浏览器本身会根据**Unicode编码**的顺位来比较的出正负
  - 传入回调函数用于正常排序，是利用了正负位置会相应变化的特性
  - 这种在调用时改变已有方法**内部逻辑**的思想，可以用于所有的方法，只要确定了这个方法运行的本质即可

### indexOf()

### 遍历数组

- 遍历数组就是将数组中元素都获取到

- 一般情况我们都是使用for循环来遍历数组：

```javascript
for(var i=0 ; i<数组.length ; i++){//数组[i] }
//其实i就是index的缩写，这个i就是用来遍历数组的  
```

- 使用forEach()方法来遍历数组（不兼容IE8）

```javascript
数组.forEach(function(value , index , obj){ 

});
```

- forEach()方法需要一个回调函数作为参数，
  - 回调函数，我们仅负责创建，不用去调用

- 数组中有几个元素，回调函数就会被调用几次，每次调用时，都会将遍历到的信息以实参的形式传递进来我们可以定义形参来获取这些信息。

- 参数：

1. value:正在遍历的元素
2. index:正在遍历元素的索引
3. obj:被遍历对象

# 14.Date类型

- 日期的对象，在JS中通过Date对象来表示一个时间

## 创建对象（找对象）

- 创建一个当前的时间对象
  - ``var d = new Date();``

- 创建一个指定的时间对象
  - ``var d = new Date("月/日/年 时:分:秒");``
  - 日期之后 时间之前 有一个空格
  - 年写4位比较好

## 方法（搞对象）

### getDate()

- 当前日期对象是几日（1-31）

### setDate() 

+ 根据**本地时间**来指定一个日期对象的天数。

+ 接受一个整数，表示该月的第几天。

+ ```js
  var theBigDay = new Date(1962, 6, 7); // 1962-07-07
  theBigDay.setDate(24);  // 1962-07-24
  theBigDay.setDate(32);  // 1962-08-01
  ```

### getDay()

- 返回当前日期对象时周几（0-6）

- 0 周日

### getMonth()

- 返回当前日期对象的月份（0-11）

- 0 一月 1 二月

### getFullYear()

- 从 Date 对象以四位数字返回年份。

### getHours()

- 返回 Date 对象的小时 (0 ~ 23)。

### getMinutes()

- 返回 Date 对象的分钟 (0 ~ 59)。

### getSeconds()

- 返回 Date 对象的秒数 (0 ~ 59)。

### getMilliseconds()

- 返回 Date 对象的毫秒(0 ~ 999)。

### getTime()

- 返回当前日期对象的时间戳

- 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数

- 计算机底层保存时间都是以时间戳的形式保存的。

- 有时区问题，这是格林威治标准时间的1月1日，算上与中国的8小时时差，会返回负值

````javascript
var date = new Date(“1/1/1970 0:0:0”);
console.log(date);//-28800000
````

### Date.now()

- 可以获取当前代码执行时的时间戳

# 15.Math对象

- Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法 
  - 虽然是大写的，但是不是一个构造函数

- 我们可以直接使用它来进行数学运算相关的操作

### Math.**PI**

- 常量，圆周率

- 其他属性都是常量

### Math.abs()

- 绝对值运算

### Math.ceil()

- 天花板
- 向上取整

- 不为0一定变大

### Math.floor()

- 向下取整

### Math.round()

- 四舍五入取整

### Math.random()

- 生成一个0-1之间的随机数

- 生成一个x-y之间的随机数

```javascript
Math.round(Math.random()*(y-x)+x);
```

### Math.pow(x,y)

- 求x的y次幂

### Math.sqrt()

- 对一个数进行开方

### Math.max()

- 求多个数中最大值

### Math.min()

- 求多个数中的最小值

# 16.包装类

- 在JS中为我们提供了三个包装类：String() Boolean() Number()

- 这三个实际上都是构造函数

- 通过这三个包装类可以创建基本数据类型的对象  //基本对象

```javascript
var num = new Number(2);
var str = new String("hello");
var bool = new Boolean(true);
//作为构造函数使用，运用到转换类型时是普通的函数
```

- 但是在实际应用中千万不要这么干。

```javascript
var num = new Number(3);
var num2 = new Number(3);
num == num2; //flase ，对象比较内存地址
var num3 = 3;
num == num3l // true ,自动转换了类型，Object也可以转换
```

- 当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，操作完成以后再将这个临时对象进行销毁。

```javascript
var s=123
s=s.toString()
//不会报错，因为toString在Object的原型上，转换为Number()包装类之后，可以获取到
```

## 字符串的方法

- 通过临时转换成包装类来调用

- 在底层字符串是以字符数组的形式保存的

### length属性

- 获取字符串的长度

### charAt()

- 根据索引获取指定的字符

- 不如[]来得方便

```js
var str = "hello"
console.log(str[0]) //h
```

### charCodeAt()

- 根据索引获取指定的**字符编码**

### fromCharCode()

- 根据字符编码获取字符

### **indexOf()**

### **lastIndexOf()**

- 从一个字符串中**检索指定内容**

- 需要一个字符串作为参数，这个字符串就是要检索的内容
  - 如果找到该内容，则会返回其**第一次**出现的索引
  - 如果没有找到则返回-1。

- 可以指定一个第二个参数，来表示**开始查找的位置** //**配合遍历**

- indexOf()是从前向后找

- lastIndexOf()是从后向前找

### includes(), startsWith(), endsWith()

### slice()

- 可以从一个**字符串中**截取指定的内容，并将截取到内容返回，不会影响原变量
- 数组中也有类似的同名方法

- 参数：

1. 截取开始的位置（包括开始）

2. 截取结束的位置（不包括结束）

- 可以省略第二个参数，如果省略则一直截取到最后

- 可以传负数，如果是负数则从后往前数
- 如果结束位置大于开始位置``str.slice(2,0)``，则返回结果空串

**substr()**

- 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量

- 非标准少用

### substring()

- 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，

- substring()中如果第二个参数小于第一个，**自动调整位置**，会交换 //1,0 == 0,1

### toLowerCase()

- 将字符串转换为小写并返回

### toUpperCase()

- 将字符串转换为大写并返回

### split()

- 可以根据指定内容将**一个字符串拆分为一个数组**

- 需要一个**字符串**作为参数，将会根据字符串去拆分数组  //比如, ; |

- 可以接收一个**正则表达式**，此时会根据正则表达式去拆分数组
  - 即使不指定全局匹配也会全部拆分，比较勤奋的方法

### match()

- 可以将**字符串中和正则表达式匹配**的内容提取出来

- 参数：  正则表达式，可以根据该正则表达式将字符串中符合要求的内容提取出来，并且封装到一个数组中返回

### replace()  

- 可以将字符串中指定内容替换为新的内容

- 参数：

1. 被替换的内容，可以是一个**正则表达式**

2. 替换的新内容

### search()

- 可以根据**正则表达式**去字符串中查找指定的内容

- 只能查找**第一个**，设置全局也没用，最懒的方法

- 参数：正则表达式，将会根据该表达式查询内容
  - 将**第一个匹配**到的内容的**索引**返回
  - 如果没有匹配到任何内容，则返回-1

### trim()

- **去除字符串两段的空格**

# 17. 正则表达式

- 正则用来定义一些**字符串的规则**，程序可以根据这些规则来判断一个字符串是否符合规则，也可以将一个字符串中符合规则的内容提取出来。

## 创建正则表达式

```js
var reg = new RegExp("正则","匹配模式");
var reg = /正则表达式/匹配模式
```

- 匹配模式：
  - i:忽略大小写
  - g:全局匹配模式

- 设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求

## 正则语法

- ^ 表示开始

```js
^a //以a开头
```

- $ 表示结束

- 同时使用^a$，只能是字符串`”a”`

```js
^a|a$ //以a开头以a结尾
```

- | 或

- [] 或

- [^ ] 除了

- [a-z] 小写字母

- [A-Z] 大写字母

- [A-z] 任意字母

- [0-9] 任意数字

### 量词

- (){n} 正好n次

- (){m,n} m-n次

- \+   至少1次 {1,}

- ?   0次或1次 {0,1}

- \*   0次或多次 {0,}

- 手机号规则：以1开头；第二位3-9任意数字；三位以后任意9个数字

```js
/^1 [3-9][0-9]{9}$/
//相当于^1 {1}[3-9]{1} [0-9]{9}$，所以不用限定位置
```

### 转义字符

- \ 在正则表达式中使用\作为转义字符  

- \\. 表示.

- \\\ 表示\

- 使用构造模式的时候特别注意，因为字符串中\也是转移字符，所以要用\\\表示\，而字面量模式可以直接用\表示\转义字符

```js
reg = /\./  → reg = new RegExp(“\\.”)
reg = /\\/ → reg = new RegExp(“\\\\”)
```

- \\. 表示任意字符

- \w  相当于[A-z0-9_] 任意字母、数字、下划线  查找**单词字符** word

- \W  除了\[^A-z0-9_]

- \d   任意数字

- \D  除了数字

- \s   空格 space

- \S   除了空格

- \b   单词边界

```js
//查找child这个单词
reg = /\bchild\b/;
reg.test(children) //false
```

- 作为单词边界的可以是：空格 分号 ，除了单词字符都可以作为单词边界

- \B   除了单词边界

## 正则方法

### test()

- 可以用来检查一个字符串是否符合正则表达式

- 如果符合返回true，否则返回false

```js
//用户名检验
//去除前后不小心输入的空格
str = str.replace(/^\s*|\s*$/g,””);  //可以用空格增加可读性，ie不行
//为什么要g，因为前半段全部替换完，就停止了，加上g后半段全部替换完
```

```js
//电子邮件
//用户名：字母、数字，任意word 
//\w本身就是根据这些用户名的类似要求来制定的
//@
//网站域名 任意字母数字 . 任意字母 2-5位
/^\w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/
```

- 网上搜常用正则表达式



# 18. DOM

- Document Object Model

- 文档对象模型，通过DOM可以来任意来修改网页中各个内容
  - 文档：文档指的是网页，一个网页就是一个文档
  - 对象：对象指将网页中的每一个节点都转换为对象，转换完对象以后，就可以以一种纯面向对象的形式来操作网页了
  - 模型：模型用来表示节点和节点之间的关系，方便操作页面

### 节点（Node）

- 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点
- 虽然都是节点，但是节点的类型却是不同的
- 常用的节点
  - 文档节点 （Document），代表整个网页
  - 元素节点（Element），代表网页中的标签
    - 只有元素节点才有子节点!!
  - 属性节点（Attribute），代表标签中的属性

    - 属性节点表示标签后中的一个个属性，要注意，属性节点并非元素节点的子节点，而是元素节点的一部分
    - 元素节点.getAttributeNode(“属性名”)；
    - 但是我们一般不会使用属性节点，因为直接访问元素的属性更加方便快捷
  - 文本节点（Text），代表网页中的文本内容
- 节点的常用属性
- 节点.nodeType
- 节点.nodeValue
  - `Node.nodeValue `属性返回或设置当前节点的值。
  - 如果`nodeValue的值为null`,则对它赋值也不会有任何效果
  - `input.value`，本质：input的value属性，读取value属性的属性值，所以前提是有value属性的标签
- 节点.nodeName: 代表当前节点的名字. 只读属性.
  - 如果给定节点是一个文本节点, nodeName 属性将返回内容为 #text 的字符串

| Attr                  | 该属性的属性值     |
| --------------------- | ------------------ |
| CDATASection          | CDATA的文本内容    |
| Comment               | 注释的文本内容     |
| Document              | null               |
| DocumentFragment      | null               |
| DocumentType          | null               |
| Element               | null               |
| NamedNodeMap          | null               |
| EntityReference       | null               |
| Notation              | null               |
| ProcessingInstruction | 整个标签的文本内容 |
| Text                  | 文本节点的内容     |

## DOM操作

### DOM查询

- 在网页中浏览器已经为我们提供了**document对象**，它代表的是整个网页，它**是window对象的属性**，可以在页面中直接使用
  - 葫芦娃的爷爷，抓住了爷爷，节点自己就送上门了

- **document查询方法：**
- **document.getElementById("id属性值");**
  - 根据元素的id属性查询一个元素节点对象：
- **document.getElementsByName("name属性值");**
  - 根据元素的name属性值查询一组元素节点对象:
  - s → 伪数组
- **document.getElementsByTagName("标签名");**
  - 根据标签名来查询一组元素节点对象：
  - 获取表单项目的那个name
  - **不仅是document的方法，也是元素节点的方法**
  - 这个方法IE的支持度也差

- document.getElementsByClassName()
  - 根据元素的class属性值查询一组元素节点对象
  - 优点：动态获取，可以捕获DOM结构的改变
  - 缺点：结构不清晰，不如查询字符串方便
  - 这个方法不支持IE8及以下的浏览器

- **document.querySelector()**

  - 根据CSS选择器去页面中查询一个元素
  - 如果匹配到的元素有多个，则它会返回查询到的第一个元素
  - ie8以上支持，算是很不错了

- **document.querySelectorAll()**
  - 根据CSS选择器去页面中查询一组元素
  - 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个
  - 优点：结构清晰，可以使用查询字符串
  - 缺点：静态获取，无法捕获DOM结构的改变，且DOM结构改变后，伪数组内的元素无法修改样式
  - 解决：每次DOM节点改变之后，主动调用querySelector

- **document的其他属性和方法**

- document.all
  - 获取页面中的所有元素，类似于`document.getElementsByTagName("*")`

```js
var all = document.getElementsByTagName("*")
var ALL = document.all
  console.log(all)
  console.log(ALL)
  console.log(typeof all) //object
  console.log(typeof ALL) //underfine
```

- document.documentElement
  - 获取页面中html根元素

- document.body
  - 获取页面中的body元素


### 元素的属性

- 读取元素的属性：
  - 语法：元素.属性名

```js
ele.name  
ele.id  
ele.nodeValue //没有ele.value
ele.className //因为class是es的保留字
```

```
拓展：获取属性节点:
	1). **可以直接通过 cityNode.id 这样的方式来获取和设置属性节点的值
	
	2). **可以直接通过getAttribute/setAttribute/removeAttribute
				 这样的方式来获取和设置属性节点的值

	3). 通过元素节点的 getAttributeNode 方法来获取属性节点,
	         然后在通过 nodeValue 来读写属性值 
```

- 修改元素的属性
  - 语法：元素.属性名 = 属性值
- 元素节点的查询方法
  - 元素.getElementsByTagName()
  - 通过标签名查询当前元素的指定后代元素
- 元素.childNodes
  - 获取当前元素的所有子节点
  - 会获取到标签间的**空白的文本子节点**
  - 传入index可以获取相应的子节点
- 元素.children
  - 获取当前元素的所有**子元素**
  - 不会有空白文本节点，不是标准，但是所有浏览器都兼容，推荐使用，这些方法只有该方法会**忽略空格文本节点**
  - 传入index可以获取相应的子节点
- 元素.firstChild
  - 获取当前元素的第一个子节点
  - 相应的有firstElementChild方法，可以忽略空白文本节点，但是ie9 才支持，所以不推荐使用
- 元素.lastChild
  - 获取当前元素的最后一个子节点
- 元素.parentNode
  - 获取当前元素的父元素
- 元素.previousSibling
  - 获取当前元素的前一个兄弟节点
- 元素.nextSibling
  - 获取当前元素的后一个兄弟节点
- innerHTML和innerText
  - 两个属性作用类似，都可以获取到标签内部的内容
  - 不同是innerHTML会获取到html标签
  - 而innerText会自动去除标签
  - **这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性**
  - 如果使用这两个属性来设置标签内部的内容时，没有任何区别的
  - 对于自结束标签，比如<input/>，是没有办法获取到**值**的，这时innerHTML没有意义

```js
//读取标签内部的文本内容
//<li>你好</li>
元素.firstChild.nodeValue //文本节点“你好”的值
元素.innerHTML //li的innerHTML
```

## DOM修改HTML结构

- document.createElement()
  - 可以根据标签名创建一个元素节点对象

- document.createTextNode()
  - 可以根据文本内容创建一个文本节点对象

- 父节点.appendChild(子节点)
  - 向父节点中添加指定的子节点
  - innerHTML会整个重写，**会导致绑定的事件消失**

- 父节点.insertBefore(新节点,旧节点)
  - 将一个新的节点插入到旧节点的前边

- 父节点.replaceChild(新节点,旧节点)
  - 使用一个新的节点去替换旧节点

- 父节点.removeChild(子节点)
  - 删除指定的子节点
  - 推荐方式：子节点.parentNode.removeChild(子节点)

##   DOM修改HTML样式（CSS）

- 读取和修改内联样式

### 内联样式

- 使用**style属性**来操作元素的**内联样式**

- 读取内联样式
  - 语法：元素.style.样式名
  - 如果样式名中带有-，则需要将样式名修改为驼峰命名法将-去掉，然后-后的字母改大写
  - background-color --> backgroundColor

- 修改内联样式：

  - 语法：元素.style.样式名 = 样式值

  - 通过style修改的样式都是内联样式，由于内联样式的优先级比较高，所以我们通过JS来修改的样式，往往会立即生效，但是如果样式中设置了!important，则内联样式将不会生效。

### 当前样式

- 正常浏览器

- 使用``getComputedStyle()``方法，这个方法是``window对象``的方法，可以返回一个对象，这个对象中保存着当前元素生效样式

- 参数：

1. 要获取样式的元素

2. 可以传递一个伪元素，一般传null

- 例子：

```js
//获取元素的宽度
getComputedStyle(box , null)["width"];
//width当前值
```

- 通过该方法读取到样式都是只读的不能修改

- IE8

- 使用``currentStyle``属性

- 语法：元素.currentStyle.样式名

```js
box.currentStyle["width"] //[]字面量形式兼容性好
width:auto;
```

- 通过这个属性读取到的样式是只读的不能修改

- 只要判断有没有这个属性，即可实现兼容

- window.getComputedStyle 有的话返回，然后转换为true，没有的话undefined，转换为flase 。因为IE高版本两者都有，建议用gcs

## 其他的样式相关的属性（直接可读）

- 注意：以下样式都是只读的，且不会返回px，可计算

### 高宽

- clientHeight 元素的**可见高度**，指元素的内容区和内边距的高度
- clientWidth元素的**可见宽度**，指元素的内容区和内边距的宽度
  - gcs() cs返回的只是元素内容区高度
  - 因为没有css属性时描述内容区+内边距的，除非转换成了border-box
- offsetHeight整个元素的高度，包括内容区、内边距、边框

  - 进行偏移的时候移动的**可见整体**
- offfsetWidth整个元素的宽度，包括内容区、内边距、边框

```js
拖拽的最长距离：容器的clientWidth-子元素的offsetWidth
在容器的内部移动，子元素的边框不会被覆盖
```

```js
// 获取视口的尺寸
// document.documentElement.clientWidth并不是根标签的可视区域，就是视口的大小
// 只有根标签是特殊的，不会受到margin的影响
var w = document.documentElement.clientWidth;
//document.documentElement.offsetWidth，获取根标签的border-box，根标签没有特殊
var w2 = document.documentElement.offsetWidth;
console.log(w,w2);



/*
注意！！
	在ie10及ie10以下，根标签的clientWidth和offsetWidth
	统一被指定为视口的宽度
*/
```

- **offsetParent**当前元素的定位父元素；离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回html

  - ```markdown
    保证：html和body之间的margin被清除
    本身定位为fiexd，不管你父级有没有定位
    	火狐的offsetParent --> body
    	非火狐offsetParent --> null //此时offsetLeftTop还是参照于body
    非fiexd（包括本身不定位）
    	父级没有定位
    		offsetParent --> body
    	父级有定位（除了static都是开启了定位）
    		offsetParent --> 定位父级
    ie7以下，如果当前元素的祖先元素触发了haslayout，那么他就是offsetParent
    ```

  - **body的offsetparent：null，就算html、body的margin没有reset，也不影响，offsetLeftTop的值都是0**

- 区别parentNode和offsetParent

  - parentNode：直接父级

  - offsetParent：**类似于**css的包含块

- offsetLeft

- offsetTop
  - 当前元素和**offsetParent内边距边界**之间的偏移量
  - **没有开启定位的元素也有这两个属性**![1548075052912](F:\OneDrive\JS\纲略合集\assets\1548075052912.png) 
  - offsetLeft水平偏移量  offsetTop垂直偏移量

### 获取元素的绝对位置（到body）

**while循环**

- ```js
  function getPointAb(node){
    //while循环叠加offsetParent的offsetTop和offsetLeft
    var x =0;
    var y = 0;
    while(node){ //最终回循环到null，然后跳出循环
      x+=node.offsetLeft;
      y+=node.offsetTop;
  
      node = node.offsetParent;
    }
  
    return {x:x,y:y};
  }
  ```

- 首先html和body的margin要重置，因为循环最终只能去到body

- boder margin会影响这个函数的取值

  - ![1548123244295](F:\OneDrive\JS\纲略合集\assets\1548123244295.png) 
  - offsetLeftTop会直接无视border的值
  - 自己和父元素的**内边距**不会对offsetLeftTop造成影响，因为左上角始终不变，内容区被挤向右下方而已
  - ![1548124728065](F:\OneDrive\JS\纲略合集\assets\1548124728065.png) 
  - **自己的外边距、父元素的外边距**会影响offsetLeftTop的值，因为从内边距边界出发

### 滚动

- scrollHeight

- scrollWidth
  - 获取**元素滚动区域**的高度和宽度
  - 滚动区域由内容物决定，所以会有非整百之类的出现

- scrollTop

- scrollLeft
  - 获取元素垂直和水平滚动的距离
  - 而不是滚动条的物理滚动长度

- 判断滚动条是否滚动到底
  - 垂直滚动条
  - scrollHeight - scrollTop = clientHeight

  - 水平滚动
  - scrollWidth - scrollLeft = clientWidth

### 注意

- chrome认为浏览器的滚动条是body的

- 火狐等认为是html的（容不下body，所以是html的）

+ 360浏览器虽然是chrom内核但是却认为滚动条是html的

+ ```js
  const L = document.documentElement.scrollLeft||document.body.scrollLeft;
  const T = document.documentElement.scrollTop||document.body.scrollTop;
  ```

+ 

### 获取元素的相对位置（到视口）

**绝对位置减去元素滚动的距离**

- ```js
  function getPointRe(node){
    //while循环叠加offsetParent的offsetTop和offsetLeft
    var x =0;
    var y = 0;
    while(node){
      x+=node.offsetLeft;
      y+=node.offsetTop;
  
      node = node.offsetParent;
    }
  
    var L = document.documentElement.scrollLeft||document.body.scrollLeft;
    var T = document.documentElement.scrollTop||document.body.scrollTop;
  
    return {x:x-L,y:y-T};
  }
  ```

### **getBoundingClientRect**

- 一个元素四个角！的相对位置
- getBoundingClientRect + 滚动条滚动时元素滚动的距离→绝对位置

```js
/*
代表元素border-box的尺寸（可以使用offsetWH代替）
height
width

元素左上角的相对位置
left
top

元素右下角的相对位置
right
bottom
*/
window.onload=function(){
  var inner1 = document.querySelector("#inner1");
  var point = inner1.getBoundingClientRect();
  console.log(point);
}
```

### demo mac停靠栏

```js
var r = 320;
var imgNodes = document.querySelectorAll("#wrap > img");

document.onmousemove=function(ev){
  ev =  ev||event;
  for(var i=0;i<imgNodes.length;i++){
    var a = imgNodes[i].getBoundingClientRect().left + imgNodes[i].offsetWidth/2 - ev.clientX;
    var b = imgNodes[i].getBoundingClientRect().top + imgNodes[i].offsetHeight/2 - ev.clientY;
    var c = Math.sqrt(a*a+b*b);


    if(c>=r){
      c=r;
    }
    imgNodes[i].style.width =128 - c*0.2 +"px";
  }
}
```



# 19. DOM规范

- 正如W3C所定义的，DOM是独立于平台和语言的接口，该接口为程序和脚本提供了对文档的内容、结构和样式的动态获取和更新的功能。

- DOM的出现来自对动态页面的需求，先有DOM的实现（Netscape DOM0），再有各个厂商对DOM实现规范的需求，再有了W3C Activity Statement对于DOM发展的规范，然后才有了我们所说的“DOM”。

- DOM0：不是W3C规范。
  DOM1：开始是W3C规范。专注于HTML文档和XML文档。
  DOM2：对DOM1增加了样式表对象模型(DOM2)
  DOM3：对DOM2增加了内容模型 (DTD 、Schemas) 和文档验证。

### DOM0

- DOM0指的是Necscape3.0和IE3.0提供对于HTML文档功能，实现了包括元素(HTML Element)、表单(Form)、图像(Image)等的接口和方法。DOM0虽然年代久远，某些实现并不符合新的DOM理念，但为了向后兼容，很多现代浏览器仍然支持DOM0的某些方法和属性。即便某些方法的实现原理有所不同，但提供了可用性。
- DOM0出现后，各厂商意识到DOM的前景，纷纷向W3C建议DOM的规范化。于是出现了W3C DOM Activity Statement（DOM的活动清单）以及DOM1、DOM2、DOM3规范(Specification)

### DOM1

- DOM1 1.0版本发布于1998年10月1日，是第一个DOM规范。
- DOM1包含两部分:	
  - DOM1 Core：定义了DOM最基本的接口，包括**Document，Node，NodeList**等等。	
  - DOM1 THML：HTML文档是DOM的一种实现，该规范定义了基于DOM1 Core的HTML文档实现。

### DOM2

- DOM2规范在2000年11月13日发布，主要包含6个模块，相比于DOM1，DOM2更加丰富，更加完善，目前主流浏览器对DOM2有着良好的支持。
- DOM2 Core: 相比于DOM1 Core，DOM2丰富了Document，Node等接口的功能，	
- DOM2 View：View提供的是DOM的表现形式，同一个文档源(document source)，可能有不同的表现形式，DOM2 View引入了Abstract View和Document View接口。	
- DOM2 Event：DOM 事件处理系统规范，DOM1中并未对DOM的事件模型进行定义，在DOM2中规范事件模型(Event Model)主要有两个目的：
 1. 设计一套通用的事件系统，实现事件处理程序的注册和注销，描述事件的流动(Event Flow)，事件的上下文信息(Contextual Information )等；

 2. 提供一套规范子集兼容老版本浏览器DOM0的事件实现。

- DOM2 Style：程序和脚本动态地获取和更新DOM的样式，提供包括Style Sheet, Cascading Style Sheet, CSSRule, CSSStyleDeclaration, getComputedStyle接口。DOM2 Style的实现基于DOM2 Core和DOM2 View。
- DOM2 Traverse and Range：DOM2 Traverse是关于文档节点遍历的规范，包括Treewalker，NodeIterator和NodeFilter等
- DOM2 Range是关于DOM片段(Document Fragment)操作的规范，譬如DocumentFragment。
- DOM2 HTML：在DOM1 HTML的基础上结合DOM2 Core推出了一些新的接口和属性

### DOM3

- DOM3首次发布于2004年4月，主要包括Core、Load and Save、Validation、XPath、View and Formatting、Events和Abstract Schemas7个模块。目前主流浏览器对DOM3的支持比较有限

### DOM IDL

- interface description language

```c++
c++：
class 派生类名 : 继承方式  基类名
{
派生类的成员
};
继承方式：public、private和protected，默认处理是public。
```

- DOM IDL
  - DOM的接口定义语言
  - 定义了接口和结果，具体的实现由浏览器的厂商自己决定，但是结果必须符合规范，谁的方法性能更强，谁的浏览器就更好
- ![1546656431521](F:\OneDrive\JS\纲略合集\assets\1546656431521.png)
- 一直在疑惑，学得那么深的原型链，好像没啥用处，现在看来是整个JS实现的底层逻辑，每一个构造函数、对象上面的方法属性，都是通过原型链一步步构造起来的，虽然没有直接使用，其实一直在使用着原型链

# 20. 事件（Event）

- 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。

- 事件是不用驼峰的

- 我们可以为事件来绑定回调函数来响应事件。

## 事件的绑定

- 绑定事件的方式：

1. 可以在标签的事件属性中设置相应的JS代码

   - \<button onclick="js代码。。。">按钮\</button>

   - 结构行为耦合，不推荐使用
2. 可以通过为对象的指定事件属性设置回调函数的形式来处理事件
   - 只能绑定一个事件，后绑定的会覆盖前面的

```js
<button id="btn">按钮\</button>

<script>
var btn = document.getElementById("btn");
btn.onclick = function(){};
</script>
```

3. addEventListener()

- 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会**按照函数的绑定顺序执行**

- Dom2事件，Dom2标准定义的绑定方式

- 该方法不支持ie8

- 参数：

1. 事件触发的字符串，**不需要on**

2. 回调函数，当事件触发时，该函数会被调用

3. 是否在捕获阶段触发事件，需要一个布尔值，一般传false

```js
btn01.addEventListener(“click”,function(){},false);
```

4. attachEvent()

- 支持全部ie5-10，其他浏览器不支持
  - 非标准没有捕获阶段
  - 从ie6-10有捕获阶段
- 这个方法也可以同时为一个事件绑定多个处理函数，不同的是它是**后绑定先执行，执行顺序和addEventListener()相反**
  - 标准ie正序
  - 非标准倒序
- 如果顺序很重要的，写成一个，如果不重要的就用这个
- 参数：

1. 事件的字符串，**要on**

2. 回调函数

- **addEventListener()中的this，是绑定事件的对象**

- **attachEvent()中的this，是window**

- 兼容：需要统一两个方法this，传入的参数与是否调用

```js
function bind(){…obj.attachEvent(obj,function(){}}

function bind(obj, evname, fn) {
	if (obj.addEventListener) {//除ie低版本外都可以进入
		obj.addEventListener(evname, fn, false);
	} else {
		obj.attachEvent('on' + evname, function() {
			fn.call(obj);
		});
	}
}

bind(document, 'click', fn1); 
```

### DOM0和DOM2两种绑定方式的区别

- 冒泡与否：
  - DOM0：默认冒泡
  - attachEvent()：默认冒泡
  - addEventListener()：默认冒泡
    - 传入的第三个参数控制**是否捕获**
    - 默认是false，也就是默认不捕获→默认冒泡
    - 如果传入true，则捕获
    - 
- 取消冒泡的手段：
  - DOM0：event.cancelBubble = true
  - DOM2：event.stopPropagation()
- 绑定事件数量：
  - DOM0：一个，后绑定的会覆盖想绑定的
  - DOM2：多个
- 禁止**默认行为**的方法：
  - DOM0：return false
  - DOM2：使用`addEventListener()`方法绑定的函数，不能使用return false取消默认行为，需要使用`event.preventDefault()`
  - 通过event.cancelable查看默认行为是否可以被取消
  - 那attachEvent()呢？试试就知道了
- this
  - DOM0事件模型还涉及到直接写在html中的事件，因此不会传入event对象，同时，this指向的是window，不再是触发事件的dom对象。
  - **addEventListener()中的this，是绑定事件的对象**
  - **attachEvent()中的this，是window**

## 解除事件的绑定

- DOM0:想解除事件就相当简单了，只需要再注册一次事件，把值设成null
  - 原理就是最后注册的事件要覆盖之前的，最后一次注册事件设置成null，也就解除了事件绑定。
- - 
- DOM2:removeEventListener
  - 解除事件语法：btn.removeEventListener("事件名称", "事件回调", "捕获/冒泡");
- DOM2:detachEvent(ie)

## 单击响应函数

- 可以创建 单击响应函数的 统一函数

```javascript
function myClick(idStr,fun){
var btn = document.getElementById(“idStr”);
btn.oncClick = fun; //传入对应操作的回调函数
}
myClick(idStr,fun);
```

## 事件对象(event)

- 当响应函数（onclick等等）被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。

- 可以在响应函数中定义一个形参，来使用**事件对象**，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存 （不兼容火狐）

```js
元素.事件 = function(event){ event = event || window.event; };
元素.事件 = function(e){ e = e || event; };
```

- onmousemove 鼠标移动即时触发函数的条件
  - clientX 事件触发时鼠标的x坐标（始终相对于浏览器窗口0,0，滚动条滚下去了，那么就0,0就跟着变到下面）
  - 而div的left top是相对于最近**开启定位的父元素**
  - pageX，相对于**当前页面**，但是不兼容IE8

### MouseEvent接口

- 指用户与指针设备( 如鼠标 )交互时发生的事件。使用此接口的常见事件包括：`click`，`dblclick`，`mouseup`，`mousedown`。

- `MouseEvent.clientX`只读
  - 鼠标指针在点击元素（DOM）中的X坐标
  - 简写：`MouseEvent.X`

- `MouseEvent.clientY`只读
  - 鼠标指针在点击元素（DOM）中的Y坐标
  - 简写：`MouseEvent.Y`

- [`MouseEvent.offsetX`](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetX) 只读
  - 鼠标指针相对于目标节点内边位置的X坐标
- [`MouseEvent.offsetY`](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetY) 只读
  - 鼠标指针相对于目标节点内边位置的Y坐标
- [`MouseEvent.pageX`](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/pageX) 只读（IE9）
  - 鼠标指针相对于整个文档的X坐标；
- [`MouseEvent.pageY`](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/pageY) 只读（IE9）
  - 鼠标指针相对于整个文档的Y坐标；

## 事件的冒泡（Bubble）

- 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件（相同响应条件）也会触发。
  - 亲了小姑娘一口，被小姑娘打了，被小姑娘爸爸打了，被小姑娘爷爷打了

- 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消

- 可以将事件对象的cancelBubble设置为true，即可取消冒泡

```js
元素.事件 = function(event){
event = event || window.event;
event.cancelBubble = true;
};
```

## 事件的传播

- 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。所以ie的**attachEvent()**，没有true or false

- 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素

- W3C综合了两个公司的方案，将事件传播分成了三个阶段

1. 捕获阶段

- 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件

2. 目标阶段

- 事件捕获到目标元素，捕获结束开始在目标元素上触发事件

3. 冒泡阶段

- 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件

![1546564409847](F:\OneDrive\JS\纲略合集\assets\1546564409847.png)

- 如果希望在捕获阶段就触发事件，可以将**addEventListener()的第三个参数设置为true**，一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false

### 事件流

单击蓝色框后，开始事件捕获阶段：
​	从最外层的document对象（浏览器其实是从window对象开始的）向内捕获事件，路过红色框时，查看到红色框有事件，
​	但是红色框说：“我是在冒泡阶段执行，现在是捕获阶段，等你回来再说吧。”
​	接下来是黄色框：“我在捕获阶段执行，就是现在执行！在控制台输“黄色框”吧~~”
接下来到达目标阶段：
​	“DOM2级事件”规范要求捕获阶段不会涉及事件目标即我们点击的那个最具体的元素，
​	但IE9、Chrome等浏览器都会在捕获阶段触发事件对象上的事件。执行目标对象的事件函数，控制台输出“蓝色框”。
最后是冒泡阶段：
​	由目标对象向外传递，到达黄色框，黄色框说：“我在捕获阶段执行过了，你走吧...”
​	然后到达红色框，红色框说：“你终于回来了，现在就执行我的事件！”控制台输出“红色框”。
​	然后继续向外传播，直到到达document对象后停止。
其他：更改了元素绑定事件代码的顺序，执行顺序也和上面表现的一致。

## 事件的委派

- 希望只绑定一次事件，即可以应用到多个事件上，即使事件是后添加的

- 绑定给共同的祖先元素，点击后代可以冒泡至祖先，触发响应函数

```js
event.target 返回触发事件的对象
if(event.target.className == );
```

- class可以设置多个，空格隔开就行，用正则表达式来解决

- 图片必须绑定到闭标签当中，因为文档流是会遮挡的，点了小div，target是小div，冒泡到大div触发函数，传入的target还是小div的，无法符合case

- this 返回绑定事件的对象
  - 事件监听绑定在父元素上，事件也是发生在父元素身上，只是点击子元素也可以出发，因为有冒泡
  - 但是，当使用delegate()、on()等方法时，回调函数中的this，是event.target，即是发生事件 的子元素
  - 之所以会产生这种区别，是因为这两个方法，都传入了触发对象的选择器
  - on()情况和delegate()一模一样，因为on()方法是集合了delegate()、bind()、live()这三个方法之长处的最佳处理方案

## 文档的加载

- 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。

- 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载，此时将会无法正常获取到DOM对象，导致DOM操作失败。

**解决方式一：**

- 可以将js代码编写到body的下边

**解决方式二：**

- 将js代码编写到window.onload = function(){}中

- window.onload 对应的回调函数会在整个页面加载完毕以后才执行，所以可以确保代码执行时，DOM对象已经加载完毕了

  ```html
  <script>
  window.onload = function(){
  var btn = document.getElementById("btn");
  btn.onclick = function(){};
  };
  </script>
  ```

**解决方法三：**

- 定时器设延时为0
- 利用了事件队列的原理

## 常用的事件

- onclick
- onkeydown
- onkeyup
- onmousedown
- onmouseup
- onmousemove
- onmouseout
- onmouseover
- onblur 失去焦点

### **demo 拖拽**

### **滚轮事件**

- onmousewheel（DOM0）

- chrome、ie都支持，火狐不兼容该特性

- 火狐中可以使用：DOMMouseScroll，该事件需要通过addEventListenner()方法（DOM2）

```js
bind(box1,"DOMMouseScroll",box1.onmousewheel);
//把其他浏览器的函数作为回调函数传入火狐的函数中，视作普通函数对象进行调用
```

- event.wheelDelta

  - 向上滚是120；向下滚是-120，速度过快可能会出现240

  - 不用看大小，只看正负即可

  - 火狐不支持，火狐用的是event.detail
    - 向上滚-3，向下滚是3，速度过快可能会6
### 默认行为

- 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，

- 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为

- return false;

- 使用addEventListener()方法绑定的函数，不能使用return false取消默认行为，需要使用event.preventDefault();

### **键盘事件**

- onkeydown

  - 按键被按下

  - 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发

  - 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快

  - 这种设计是为了防止误操作的发生。

键盘移动div键盘仅负责方向即可，速度移动交给定时器

- onkeyup

  - 按键被松开

  - 键盘事件一般都会绑定给一些可以**获取到焦点**的对象或者是document
    - 比如：输入框，光标闪烁，获取焦点，点击外部，失去焦点

- event可以通过keyCode来获取按键的unicode编码，通过它可以判断哪个按键被按下 

- 除了keyCode，事件对象中还提供了几个属性
  - altKey

  - ctrlKey

  - shiftKey

- 这个三个用来判断alt ctrl 和 shift是否被按下，如果按下则返回true，否则返回false

- 因为判断是否同时按下，keyCode却只能对应一个值，所以提供了控制3按键的相关属性

- 在文本框中输入内容，属于onkeydown的默认行为如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中

```js
//使得文本框中只能输入字母
if(event.keyCode >= 48 && event.keyCode <= 57){return false;}
```

# 21. BOM

- 浏览器对象模型

- BOM可以使我们通过JS来操作浏览器, 在BOM中为我们提供了一组对象，用来完成对浏览器的操作

## BOM对象

- Window
  - 代表的是整个浏览器的窗口，同时window也是网页中的全局对象

  - window.onload = function(){};
  - //可以避免污染全局空间，这也是和$()的一个区别，不可以反复使用

- Navigator

  - 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器

- Location
  - 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面

- History

  - 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录

  - 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效

- Screen

  - 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息

  - 移动端用的多因为屏幕差别大

  - 这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用

## Navigator

- 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器

- 由于历史原因，Netscape网景公司，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了

- 一般我们只会使用userAgent来判断浏览器的信息，userAgent等价于浏览器
  - userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容

- 不同的浏览器会有不同的userAgent

### 火狐的userAgent

- Mozilla/5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0

  - Windows NT 6.1 就是win7

  - WOW64  64位操作系统

  - rv:50.0 版本50

  - Gecko 火狐专门的css渲染引擎

### Chrome的userAgent

- Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36

### IE8

- Mozilla/4.0 (compatible; **MSIE 8.0**; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)

### IE9

- Mozilla/5.0 (compatible; **MSIE 9.0**; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)

### IE10

- Mozilla/5.0 (compatible; **MSIE 10.0**; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)

### IE11

- Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko
  - 在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了
  - 如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息
  - 比如：ActiveXObject，但是由于用的太多，IE11把`!!window.ActiveXObject //fasle`
  - `“ActiveXObject“  in window //true`
  - ActiveXObject 兼容低版本IE的ajax请求

 ```js
if(/firefox/i.test(ua)){
  alert("你是火狐")
}else if (/chrome/i.test(ua)){
  alert("你是chrome")
}else if (/msie/i.test(ua)){
  alert("你是IE浏览器")
}else if ("ActiveXObject" in window){
  alert("IE11 funny")
}
 ```

## History

- 对象可以用来操作浏览器向前或向后翻页

- length
  - 属性，可以获取到当成访问的链接数量

- back()
  - 可以用来回退到上一个页面，作用和浏览器的回退按钮一样

- forward()

  - 可以跳转下一个页面，作用和浏览器的前进按钮一样

  - `history.forward();`

- go()

  - 可以用来跳转到指定的页面

  - 它需要一个整数作为参数

  - 1:表示向前跳转一个页面 相当于forward()

  - 2:表示向前跳转两个页面

  - -1:表示向后跳转一个页面

  - -2:表示向后跳转两个页面

  - `history.go(-2);`

## Location

- 该对象中封装了浏览器的地址栏的信息

- 如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）

- 如果直接将location属性修改为一个完整的路径，或相对路径则我们页面会自动跳转到该路径，并且会生成相应的历史记录

- assign()
  - 用来跳转到其他的页面，作用和直接修改location一样

- reload()

  - 用于重新加载当前页面，作用和刷新按钮一样

  - 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面

  - 相当于ctrl+f5

- replace()

  - 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面
  - 不会生成历史记录，不能使用回退按钮回退

- location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是 document 对象的属性；换句话说，window.location 和 document.location 引用的是同一个对象。

## window一些常用方法

- alert()
- confirm()
- prompt()
  - 返回的是用户输入的内容的 字符串形式

### 定时器

- JS的程序的执行速度是非常非常快的

- 如果希望一段程序，可以每间隔一段时间执行一次，可以使用定时调用

- setInterval()

### 定时调用

- 可以将一个函数，每隔一段时间执行一次

- 其实一个定时间执行的for循环 

- 参数：

1. 回调函数，该函数会每隔一段时间被调用一次

2. 每次调用间隔的时间，单位是毫秒

- 返回值：
  - 返回一个Number类型的数据

  - 这个数字用来作为定时器的唯一标识

- clearInterval()可以用来关闭一个定时器

  - 方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器

  - `clearInterval(timer)`

### 定时器的注意点

- 目前，我们每点击一次按钮，就会开启一个定时器，点击多次就会开启多个定时器，这就导致图片的切换速度过快，并且我们只能关闭最后一次开启的定时器
- 在开启定时器之前，需要将当前元素上的其他定时器关闭
- 第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。
- JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。
- setTimeout() 的第二个参数告诉 JavaScript 再过多长时间把当前任务添加到队列中(添加的过程是异步的)。
- 如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。

### 延时调用

```js
var timer = setTimeout(function(){console.log(num++);},3000);
```

- 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次
- 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次
- 延时调用和定时调用实际上是可以**互相代替**的，在开发中可以根据自己需要去选择，定时用的稍多
- clearTimeout(timer);

**参数**

+ **function**
+ **delay**
+ `param1, ..., paramN` ，附加参数，一旦定时器到期，它们会作为参数传递给`function`

## BOM规范

缺少事实上的规范导致 BOM 有很多问题，因为浏览器提供商会按照各自的想法随意去扩展它。W3C 为了把浏览器中，JavaScript 最基本的部分标准化，已经将 BOM 的主要方面纳入了 HTML5 的规范中。

### window对象
- BOM 的核心对象是 window，它表示浏览器的一个实例。在浏览器中，window 对象有双重角色，
- 它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 **Global 对象**。
- 这意味着在网页中定义的任何一个对象、变量和函数，都以 window 作为其 Global 对象，因此有权访问 isNaN()、isFinite()、parseInt()、parseFloat() 等方法。

### 全局变量与windows对象属性的差别
- 抛开全局变量会成为 window 对象的属性不谈，定义全局变量与在 window 对象上直接定义属性还是有一点差别：
- 全局变量不能通过 delete 运算符删除，而直接在 window 对象上的定义的属性可以

### window.open()/close方法

- open方法的四个参数：可以接收4个参数：要加载的URL、窗口目标、一个特性字符串、
  一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值，后两个参数有很大的兼容性问题

- close() 方法仅适用于通过 window.open() 打开的弹出窗口。对于浏览器的主窗口，如果没有得到用户的允许是不能关闭它的。

# 22. JSON

- JS中的对象只有JS自己认识，其他的语言都不认识

- JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互

- JSON：JavaScript Object Notation JS对象表示法

- JSON和JS对象的格式一样，只不过**JSON字符串**中的**属性名必须加双引号，本质是一个字符串，所以最外层整个再套一个引号**

- JSON分类：

1. 对象 {}

2. 数组 []

- JSON中允许的值：

1. 字符串

2. 数值

3. 布尔值

4. null

5. 对象

6. 数组

- 将JSON字符串转换为JS中的对象

- 在JS中，为我们提供了一个工具类，就叫JSON

- 这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON

### JSON.parse()

- 可以将以JSON字符串转换为js对象

- 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回

### JSON.stringify()

- 可以将一个JS对象转换为JSON字符串

- 需要一个js对象作为参数，会返回一个JSON字符串

- JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错

### eval()函数

- 可用于执行一段字符串形式的JS代码，并将执行结果返回。但是尽量不要用

`eval(“alert(“hello”);”);`

- 如果使用eval()函数传入的字符串含有大括号{}，函数会把{}当成一个代码块

- 如果不希望将其当成代码块解析，则需要在字符串前后通过**拼串的形式**各拼一个()

- var obj = eval("("+str+")");

- 需要兼容选择引用JSON2.js文件