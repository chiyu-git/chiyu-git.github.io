---
layout: post
#标题配置
title:  ES6 Note Part-1
#时间配置
date:   2019-3-18 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note front-end
---

* content
{:toc}



# 1. ES6简介

## 语法提案的批准流程

- 任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。

- 一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。
  - Stage 0 - Strawman（展示阶段）
  - Stage 1 - Proposal（征求意见阶段）
  - Stage 2 - Draft（草案阶段）
  - Stage 3 - Candidate（候选人阶段）
  - Stage 4 - Finished（定案阶段）

- 一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站[GitHub.com/tc39/ecma262](https://github.com/tc39/ecma262)查看。

## ECMAScript 的历史

- ES6 从开始制定到最后发布，整整用了 15 年。

- 前面提到，ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。

### 部署进度

- 各大浏览器的最新版本，对 ES6 的支持可以查看[kangax.github.io/compat-table/es6/](https://kangax.github.io/compat-table/es6/)。随着时间的推移，支持度已经越来越高了，超过 90%的 ES6 语法特性都实现了。

- Node 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node 已经实现的 ES6 特性。

```bash
// Linux & Mac
$ node --v8-options | grep harmony

// Windows
$ node --v8-options | findstr harmony
```

## Babel 转码器

- [Babel](https://babeljs.io/) 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。

```javascript
// 转码前
input.map(item => item + 1);

// 转码后
input.map(function (item) {
  return item + 1;
});
```

- 上面的原始代码用了**箭头函数**，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。
- 下面的命令在项目目录中，安装 Babel。

```bash
$ npm install --save-dev @babel/core
```

### 配置文件.babelrc

- Babel 的配置文件是`.babelrc`，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。

该文件用来设置转码规则和插件，基本格式如下。

```javascript
{
  "presets": [],
  "plugins": []
}
```

- `presets`字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。

```bash
# 最新转码规则
$ npm install --save-dev @babel/preset-env

# react 转码规则
$ npm install --save-dev @babel/preset-react
```

- 然后，将这些规则加入`.babelrc`。

```javascript
  {
    "presets": [
      "@babel/env",
      "@babel/preset-react"
    ],
    "plugins": []
  }
```

- 注意，以下所有 Babel 工具和模块的使用，都必须先写好`.babelrc`。

# 2. let命令和const命令

## let命令

- ES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。

```javascript
{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
```

- 上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。

```javascript
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
```

- 上面代码中，变量`i`是`let`声明的，当前的`i`只在本轮循环有效，所以每一次循环的`i`其实都是一个新的变量，所以最后输出的是`6`。你可能会问，如果每一轮循环的变量`i`都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量`i`时，就在上一轮循环的基础上进行计算。

- 另外，`for`循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

```javascript
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
```

- 上面代码正确运行，输出了 3 次`abc`。这表明函数内部的变量`i`与循环变量`i`不在同一个作用域，有各自单独的作用域。

### 不存在变量提升

- `var`命令会发生“变量提升”现象，即变量可以在声明之前使用，值为`undefined`。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。

为了纠正这种现象，`let`命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。

```javascript
// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
```

- 上面代码中，变量`foo`用`var`命令声明，会发生变量提升，即脚本开始运行时，变量`foo`已经存在了，但是没有值，所以会输出`undefined`。变量`bar`用`let`命令声明，不会发生变量提升。这表示在声明它之前，变量`bar`是不存在的，这时如果用到它，就会抛出一个错误。

### 暂时性死区

- 只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

```javascript
var tmp = 123;

if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
```

- 上面代码中，存在全局变量`tmp`，但是块级作用域内`let`又声明了一个局部变量`tmp`，导致后者绑定这个块级作用域，所以在`let`声明变量前，对`tmp`赋值会报错。

- ES6 明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

- 总之，在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

```javascript
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```

- “暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作。

```javascript
typeof x; // ReferenceError
let x;
```

- 作为比较，如果一个变量根本没有被声明，使用`typeof`反而不会报错。

```javascript
typeof undeclared_variable // "undefined"
```

- 所以，在没有`let`之前，`typeof`运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。

### 有些“死区”比较隐蔽

```javascript
function bar(x = y, y = 2) {
  return [x, y];
}

bar(); // 报错
```

- 上面代码中，调用`bar`函数之所以报错（某些实现可能不报错），是因为参数`x`默认值等于另一个参数`y`，而此时`y`还没有声明，属于“死区”。如果`y`的默认值是`x`，就不会报错，因为此时`x`已经声明了。

```javascript
function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]
```

- 另外，下面的代码也会报错，与`var`的行为不同。

```javascript
// 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined
```

- 上面代码报错，也是因为暂时性死区。使用`let`声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量`x`的声明语句还没有执行完成前，就去取`x`的值，导致报错”x 未定义“。

- ES6 规定暂时性死区和`let`、`const`语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。

- 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

### 不允许重复声明

- `let`不允许在相同作用域内，重复声明同一个变量。

```javascript
// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}
```

- 因此，不能在函数内部重新声明参数。

```javascript
function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}
```

## 块级作用域

### 为什么需要块级作用域？

- ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

- 第一种场景，内层变量可能会覆盖外层变量。

```javascript
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined
```

- 上面代码的原意是，`if`代码块的外部使用外层的`tmp`变量，内部使用内层的`tmp`变量。但是，函数`f`执行后，输出结果为`undefined`，原因在于变量提升，导致内层的`tmp`变量覆盖了外层的`tmp`变量。

- 第二种场景，用来计数的循环变量泄露为全局变量。

```javascript
var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
```

- 上面代码中，变量`i`只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。

### ES6 的块级作用域

块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。

```javascript
// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
```

### 块级作用域与函数声明

- 考虑到环境导致的行为差异太大，应该**避免**在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

## const 命令

### 基本用法

- `const`声明一个只读的常量。一旦声明，常量的值就不能改变。这意味着，`const`一旦声明变量，就必须立即初始化，不能留到以后赋值。

```javascript
const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
```

- 对于`const`来说，只声明不赋值，就会报错。

```javascript
const foo;
// SyntaxError: Missing initializer in const declaration
```

- `const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。

```javascript
if (true) {
  const MAX = 5;
}

MAX // Uncaught ReferenceError: MAX is not defined
```

- `const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

```javascript
if (true) {
  console.log(MAX); // ReferenceError
  const MAX = 5;
}
```

- `const`声明的常量，也与`let`一样不可重复声明。

```javascript
var message = "Hello!";
let age = 25;

// 以下两行都会报错
const message = "Goodbye!";
const age = 30;
```

### 本质

- `const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个**内存地址**所保存的**数据不得改动**。
- 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
- 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的**数据结构**是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

```javascript
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

- 上面代码中，常量`foo`储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把`foo`指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

```javascript
const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
```

- 上面代码中，常量`a`是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给`a`，就会报错。

### `Object.freeze`方法

- 如果真的想将对象冻结，应该使用`Object.freeze`方法。

```javascript
const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
```

- 上面代码中，常量`foo`指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。

- 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。

```javascript
var constantize = (obj) => {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) => {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};
```

### ES6 声明变量的六种方法

ES5 只有两种声明变量的方法：`var`命令和`function`命令。ES6 除了添加`let`和`const`命令，后面章节还会提到，另外两种声明变量的方法：`import`命令和`class`命令。所以，ES6 一共有 6 种声明变量的方法。

## 顶层对象的属性

- 顶层对象，在浏览器环境指的是`window`对象，在 Node 指的是`global`对象。ES5 之中，顶层对象的属性与全局变量是等价的。

```javascript
window.a = 1;
a // 1

a = 2;
window.a // 2
```

- 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题
  - 首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；
  - 其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；
  - 最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，`window`对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。

- ES6 为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

```javascript
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
```

- 上面代码中，全局变量`a`由`var`命令声明，所以它是顶层对象的属性；全局变量`b`由`let`命令声明，所以它不是顶层对象的属性，返回`undefined`。

## global 对象

- 很难找到一种方法，可以在所有情况下，都取到顶层对象。现在有一个提案，在语言标准的层面，引入`global`作为顶层对象。也就是说，在所有环境下，`global`都是存在的，都可以从它拿到顶层对象。

# 3. 变量的解构赋值

## 数组的解构赋值

### 基本用法

- ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

```javascript
let [a, b, c] = [1, 2, 3];
```

- 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。

```javascript
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```

- 如果解构不成功，变量的值就等于`undefined`。

```javascript
let [foo] = [];
let [bar, foo] = [1];
```

### 不完全解构

- 即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。

```javascript
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```

### 不可遍历结构

- 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。

```javascript
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

- 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。

- 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。

```javascript
function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
```

### 默认值

- 解构赋值允许指定默认值。

```javascript
let [foo = true] = [];
foo // true

let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```

- 注意，ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，只有当一个数组成员**严格等于**`undefined`，默认值才会生效。

```javascript
let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
```

- 上面代码中，如果一个数组成员是`null`，默认值就不会生效，因为`null`不严格等于`undefined`。

- 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
- 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

## 对象的解构赋值

- 解构不仅可以用于数组，还可以用于对象。

```javascript
let { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
```

- 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

- 如果变量名与属性名不一致，必须写成下面这样。

```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```

- 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。

```javascript
let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
```

- 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。**真正被赋值的是后者，而不是前者。**

```javascript
let { foo: baz } = { foo: "aaa", bar: "bbb" };
baz // "aaa"
foo // error: foo is not defined
```

- 上面代码中，`foo`是**匹配的模式**，`baz`才是变量。真正被赋值的是变量`baz`，而不是模式`foo`。

### 嵌套结构的解构

与数组一样，解构也可以用于嵌套结构的对象。

```javascript
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p: [x, { y }] } = obj;
x // "Hello"
y // "World"
```

- 注意，这时`p`是**模式**，不是变量，因此不会被赋值。如果`p`也要作为变量赋值，可以写成下面这样。

```javascript
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p, p: [x, { y }] } = obj;
x // "Hello"
y // "World"
p // ["Hello", {y: "World"}]
```

### 类似的

- 对象的解构也可以指定默认值。
- 默认值生效的条件是，对象的属性值严格等于`undefined`。
- 如果解构失败，变量的值等于`undefined`。

### 注意

- 如果要将一个已经声明的变量用于解构赋值，必须非常小心。

```javascript
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
```

- 上面代码的写法会报错，因为 JavaScript 引擎会将`{x}`理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。

```javascript
// 正确的写法
let x;
({x} = {x: 1});
```

- 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。

### 运用

- 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。

```javascript
let { log, sin, cos } = Math;
```

- 上面代码将`Math`对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。

- 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。

```javascript
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
```

- 上面代码对数组进行对象解构。数组`arr`的`0`键对应的值是`1`，`[arr.length - 1]`就是`2`键，对应的值是`3`。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。

## 字符串的解构赋值

- 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。

```javascript
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

- 类似数组的对象都有一个`length`属性，因此还可以对这个属性解构赋值。

```javascript
let {length : len} = 'hello';
len // 5
```

## 数值、布尔值、null、undefined解构赋值

- 解构赋值时，如果等号右边是数值和布尔值，则会先**转为对象**。

```javascript
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
```

- 上面代码中，数值和布尔值的包装对象都有`toString`属性，因此变量`s`都能取到值。

- 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。

```javascript
let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
```

## 函数参数的解构赋值

- 函数的**参数**也可以使用解构赋值。

```javascript
function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
```

- 上面代码中，函数`add`的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量`x`和`y`。对于函数内部的代码来说，它们能感受到的参数就是`x`和`y`。

- 下面是另一个例子。

```javascript
[[1, 2], [3, 4]].map(([a, b]) => a + b);
// [ 3, 7 ]
```

- 函数参数的解构也可以**使用默认值**。

```javascript
function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
```

- 上面代码中，函数`move`的参数是一个对象，通过对这个对象进行解构，得到变量`x`和`y`的值。如果解构失败，`x`和`y`等于默认值。

**注意**

- 下面的写法会得到不一样的结果。

```javascript
function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
```

- 上面代码是为函数`move`的参数指定默认值，而不是为变量`x`和`y`指定默认值，所以会得到与前一种写法不同的结果。

- `undefined`就会触发函数参数的默认值。

```javascript
[1, undefined, 3].map((x = 'yes') => x);
// [ 1, 'yes', 3 ]
```

## 用途

- 变量的解构赋值用途很多。

### **交换变量的值**

```javascript
let x = 1;
let y = 2;

[x, y] = [y, x];

// 临时变量
var _ref = [y, x];
x = _ref[0];
y = _ref[1];
```

- 上面代码交换变量`x`和`y`的值，这样的写法不仅简洁，而且易读，语义非常清晰。

### **从函数返回多个值**

- 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。

```javascript
// 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();

// 临时变量
var _example = example(),
    foo = _example.foo,
    bar = _example.bar;
```

### **函数参数的定义**

- 解构赋值可以方便地将一组参数与变量名对应起来。

```javascript
// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
                       
function f(_ref) {
  var x = _ref.x,
      y = _ref.y,
      z = _ref.z;
}
f({ z: 3, y: 2, x: 1 });
```

### **提取 JSON 数据**

- 解构赋值对提取 JSON 对象中的数据，尤其有用。

```javascript
let jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, "OK", [867, 5309]
```

- 上面代码可以快速提取 JSON 数据的值。

### **函数参数的默认值**

```javascript
jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
```

- 指定参数的默认值，就避免了在函数体内部再写`var foo = config.foo || 'default foo';`这样的语句。

### **遍历 Map 结构**

- 任何部署了 Iterator 接口的对象，都可以用`for...of`循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。

```javascript
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}
// first is hello
// second is world
```

- 如果只想获取键名，或者只想获取键值，可以写成下面这样。

```javascript
// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
```

### **输入模块的指定方法**

- 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。

```javascript
const { SourceMapConsumer, SourceNode } = require("source-map");
```

# 4. 字符串的扩展

### 字符的 Unicode 表示法

### codePointAt()

### String.fromCharCode()

### 字符串的遍历器接口

## includes(), startsWith(), endsWith()

### **indexOf()**

### **lastIndexOf()**

- 从一个字符串中**检索指定内容**
- 需要一个字符串作为参数，这个字符串就是要检索的内容
  - 如果找到该内容，则会返回其**第一次**出现的索引
  - 如果没有找到则返回-1。
- 可以指定一个第二个参数，来表示**开始查找的位置** //**配合遍历**
- indexOf()是从前向后找
- lastIndexOf()是从后向前找

### ES6 新增

- **includes()**：返回布尔值，表示是否找到了参数字符串。
- **startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。
- **endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。

```javascript
let s = 'Hello world!';

s.startsWith('Hello') // true
s.endsWith('!') // true
s.includes('o') // true
```

- 这三个方法都支持第二个参数，表示开始搜索的位置。

```javascript
let s = 'Hello world!';

s.startsWith('world', 6) // true
s.endsWith('Hello', 5) // true
s.includes('Hello', 6) // false
```

- 上面代码表示，使用第二个参数`n`时，`endsWith`的行为与其他两个方法有所不同。它针对前`n`个字符，而其他两个方法针对从第`n`个位置直到字符串结束。

## repeat()

- `repeat`方法返回一个新字符串，表示将原字符串重复`n`次。

```javascript
'x'.repeat(3) // "xxx"
'hello'.repeat(2) // "hellohello"
'na'.repeat(0) // ""
```

- 参数如果是**小数**，会被取整。

```javascript
'na'.repeat(2.9) // "nana"
```

- 如果`repeat`的参数是负数或者**`Infinity`**，会报错。

```javascript
'na'.repeat(Infinity)
// RangeError
'na'.repeat(-1)
// RangeError
```

- 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于`-0`，`repeat`视同为 0。

```javascript
'na'.repeat(-0.9) // ""
```

- 参数`NaN`等同于 0。

```javascript
'na'.repeat(NaN) // ""
```

- 如果`repeat`的参数是字符串，则会先转换成数字。

```javascript
'na'.repeat('na') // ""
'na'.repeat('3') // "nanana"
```

### padStart()，padEnd()

### matchAll()

## 模板字符串

- 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。

```javascript
// 普通字符串
`In JavaScript '\n' is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
let name = "Bob", time = "today";
`Hello ${name}, how are you ${time}?`
```

- 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。比如`<ul>`标签前面会有一个换行。如果你不想要这个换行，可以使用`trim`方法消除它。

```javascript
$('#list').html(`
<ul>
  <li>first</li>
  <li>second</li>
</ul>
`.trim());
```

- 模板字符串中嵌入变量，需要将变量名写在`${}`之中。
- 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。
- 模板字符串之中还能调用函数。

```javascript
function fn() {
  return "Hello World";
}

`foo ${fn()} bar`
// foo Hello World bar
```

- 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的`toString`方法。

- 如果模板字符串中的变量没有声明，将报错。

```javascript
// 变量place没有声明
let msg = `Hello, ${place}`;
// 报错
```

- 由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。

```javascript
`Hello ${'World'}`
// "Hello World"
```

- 模板字符串甚至还能嵌套。

```javascript
const tmpl = addrs => `
  <table>
  ${addrs.map(addr => `
    <tr><td>${addr.first}</td></tr>
    <tr><td>${addr.last}</td></tr>
  `).join('')}
  </table>
`;
```

- 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。

```javascript
const data = [
    { first: '<Jane>', last: 'Bond' },
    { first: 'Lars', last: '<Croft>' },
];

console.log(tmpl(data));
// <table>
//
//   <tr><td><Jane></td></tr>
//   <tr><td>Bond</td></tr>
//
//   <tr><td>Lars</td></tr>
//   <tr><td><Croft></td></tr>
//
// </table>
```

# 5. 正则的扩展

### RegExp 构造函数

- 在 ES5 中，`RegExp`构造函数的参数有两种情况。

- 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。

```javascript
var regex = new RegExp('xyz', 'i');
// 等价于
var regex = /xyz/i;
```

- 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。

```javascript
var regex = new RegExp(/xyz/i);
// 等价于
var regex = /xyz/i;
```

- 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。

```javascript
var regex = new RegExp(/xyz/, 'i');
// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another
```

- ES6 改变了这种行为。如果`RegExp`构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。

```javascript
new RegExp(/abc/ig, 'i').flags
// "i"
```

- 上面代码中，原有正则对象的修饰符是`ig`，它会被第二个参数`i`覆盖。

### 字符串的正则方法

字符串对象共有 4 个方法，可以使用正则表达式：`match()`、`replace()`、`search()`和`split()`。

ES6 将这 4 个方法，在语言内部全部调用`RegExp`的实例方法，从而做到所有与正则相关的方法，全都定义在`RegExp`对象上。

- `String.prototype.match` 调用 `RegExp.prototype[Symbol.match]`
- `String.prototype.replace` 调用 `RegExp.prototype[Symbol.replace]`
- `String.prototype.search` 调用 `RegExp.prototype[Symbol.search]`
- `String.prototype.split` 调用 `RegExp.prototype[Symbol.split]`

### u 修饰符

### y修饰符

### RegExp.prototype.flags 属性

ES6 为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。

```javascript
// ES5 的 source 属性
// 返回正则表达式的正文
/abc/ig.source
// "abc"

// ES6 的 flags 属性
// 返回正则表达式的修饰符
/abc/ig.flags
// 'gi'
```

### 后行断言

# 6. 数值的扩展

### 二进制和八进制表示法

- ES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。

```javascript
0b111110111 === 503 // true
0o767 === 503 // true
```

- 从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示。

```javascript
// 非严格模式
(function(){
  console.log(0o11 === 011);
})() // true

// 严格模式
(function(){
  'use strict';
  console.log(0o11 === 011);
})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.
```

- 如果要将`0b`和`0o`前缀的字符串数值转为十进制，要使用`Number`方法。

```javascript
Number('0b111')  // 7
Number('0o10')  // 8
```

### Number.isFinite(), Number.isNaN()

- ES6 在`Number`对象上，新提供了`Number.isFinite()`和`Number.isNaN()`两个方法。

- `Number.isFinite()`用来检查一个数值是否为有限的（finite），即不是`Infinity`。

```javascript
Number.isFinite(15); // true
Number.isFinite(0.8); // true
Number.isFinite(NaN); // false
Number.isFinite(Infinity); // false
Number.isFinite(-Infinity); // false
Number.isFinite('foo'); // false
Number.isFinite('15'); // false
Number.isFinite(true); // false
```

- 注意，如果参数类型不是数值，`Number.isFinite`一律返回`false`。

- `Number.isNaN()`用来检查一个值是否为`NaN`。

```javascript
Number.isNaN(NaN) // true
Number.isNaN(15) // false
Number.isNaN('15') // false
Number.isNaN(true) // false
Number.isNaN(9/NaN) // true
Number.isNaN('true' / 0) // true
Number.isNaN('true' / 'true') // true
```

- 如果参数类型不是`NaN`，`Number.isNaN`一律返回`false`。

- 它们与传统的全局方法`isFinite()`和`isNaN()`的区别在于，传统方法先调用`Number()`将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，`Number.isFinite()`对于非数值一律返回`false`, `Number.isNaN()`只有对于`NaN`才返回`true`，非`NaN`一律返回`false`。

```javascript
isFinite(25) // true
isFinite("25") // true
Number.isFinite(25) // true
Number.isFinite("25") // false

isNaN(NaN) // true
isNaN("NaN") // true
Number.isNaN(NaN) // true
Number.isNaN("NaN") // false
Number.isNaN(1) // false
```

### Number.isInteger()

- `Number.isInteger()`用来判断一个数值是否为整数。

```javascript
Number.isInteger(25) // true
Number.isInteger(25.1) // false
```

- JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。

```javascript
Number.isInteger(25) // true
Number.isInteger(25.0) // true
```

- 如果参数不是数值，`Number.isInteger`返回`false`。

```javascript
Number.isInteger() // false
Number.isInteger(null) // false
Number.isInteger('15') // false
Number.isInteger(true) // false
```

- 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，`Number.isInteger`可能会误判。

```javascript
Number.isInteger(3.0000000000000002) // true
```

- 上面代码中，`Number.isInteger`的参数明明不是整数，但是会返回`true`。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个`2`被丢弃了。

- 类似的情况还有，如果一个数值的绝对值小于`Number.MIN_VALUE`（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，`Number.isInteger`也会误判。

```javascript
Number.isInteger(5E-324) // false
Number.isInteger(5E-325) // true
```

- 上面代码中，`5E-325`由于值太小，会被自动转为0，因此返回`true`。

- 总之，如果对数据精度的要求较高，不建议使用`Number.isInteger()`判断一个数值是否为整数。

### Number.parseInt(), Number.parseFloat()

- ES6 将全局方法`parseInt()`和`parseFloat()`，移植到`Number`对象上面，行为完全保持不变。

```javascript
// ES5的写法
parseInt('12.34') // 12
parseFloat('123.45#') // 123.45

// ES6的写法
Number.parseInt('12.34') // 12
Number.parseFloat('123.45#') // 123.45
```

- 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。

```javascript
Number.parseInt === parseInt // true
Number.parseFloat === parseFloat // true
```

### Number.EPSILON

### 安全整数和 Number.isSafeInteger()

## Math 对象的扩展

- ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。

### Math.trunc()

- `Math.trunc`方法用于去除一个数的小数部分，返回整数部分。

```javascript
Math.trunc(4.1) // 4
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4
Math.trunc(-4.9) // -4
Math.trunc(-0.1234) // -0
```

- 对于非数值，`Math.trunc`内部使用`Number`方法将其先转为数值。

```javascript
Math.trunc('123.456') // 123
Math.trunc(true) //1
Math.trunc(false) // 0
Math.trunc(null) // 0
```

- 对于空值和无法截取整数的值，返回`NaN`。

```javascript
Math.trunc(NaN);      // NaN
Math.trunc('foo');    // NaN
Math.trunc();         // NaN
Math.trunc(undefined) // NaN
```

- 对于没有部署这个方法的环境，可以用下面的代码模拟。

```javascript
Math.trunc = Math.trunc || function(x) {
  return x < 0 ? Math.ceil(x) : Math.floor(x);
};
```

### Math.sign()

- `Math.sign`方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。

### Math.cbrt()

- `Math.cbrt`方法用于计算一个数的立方根。

### 指数运算符

- ES2016 新增了一个指数运算符（`**`）。

```javascript
2 ** 2 // 4
2 ** 3 // 8
```

- 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。

```javascript
// 相当于 2 ** (3 ** 2)
2 ** 3 ** 2
// 512
```

- 上面代码中，首先计算的是第二个指数运算符，而不是第一个。

- 指数运算符可以与等号结合，形成一个新的赋值运算符（`**=`）。

```javascript
let a = 1.5;
a **= 2;
// 等同于 a = a * a;

let b = 4;
b **= 3;
// 等同于 b = b * b * b;
```

- 注意，V8 引擎的指数运算符与`Math.pow`的实现不相同，对于特别大的运算结果，两者会有细微的差异。

```javascript
Math.pow(99, 99)
// 3.697296376497263e+197

99 ** 99
// 3.697296376497268e+197
```

- 上面代码中，两个运算结果的最后一位有效数字是有差异的。

# 7. 函数的扩展

## 函数参数的默认值

### 基本用法

```javascript
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello

function log(x) {
  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'World';

  console.log(x, y);
}
```

- 参数变量是默认声明的，所以不能用`let`或`const`再次声明。

```javascript
function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
```

- 使用参数默认值时，函数不能有同名参数。

```javascript
// 不报错
function foo(x, x, y) {
  // ...
}

// 报错
function foo(x, x, y = 1) {
  // ...
}
// SyntaxError: Duplicate parameter name not allowed in this context
```

- 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。

```javascript
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101
```

- 上面代码中，参数`p`的默认值是`x + 1`。这时，每次调用函数`foo`，都会重新计算`x + 1`，而不是默认`p`等于 100。

### 与解构赋值默认值结合使用

- 参数默认值可以与解构赋值的默认值，结合起来使用。

### 参数默认值的位置

- 通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。

```javascript
// 例一
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) {
  return [x, y, z];
}

f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
```

- 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入`undefined`。

- 如果传入`undefined`，将触发该参数等于默认值，`null`则没有这个效果。

```javascript
function foo(x = 5, y = 6) {
  console.log(x, y);
}

foo(undefined, null)
// 5 null
```

- 上面代码中，`x`参数对应`undefined`，结果触发了默认值，`y`参数等于`null`，就没有触发默认值。

### 函数的 length 属性

- 指定了默认值以后，函数的`length`属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，`length`属性将失真。

```javascript
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
```

- 上面代码中，`length`属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数`c`指定了默认值，因此`length`属性等于`3`减去`1`，最后得到`2`。

- 这是因为`length`属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入`length`属性。

```javascript
(function(...args) {}).length // 0
```

- 如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了。

```javascript
(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
```

### 作用域

- 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。

```javascript
var x = 1;

function f(x, y = x) {
  console.log(y);
}

f(2) // 2
```

- 上面代码中，参数`y`的默认值等于变量`x`。调用函数`f`时，参数形成一个单独的作用域。在这个作用域里面，默认值变量`x`指向第一个参数`x`，而不是全局变量`x`，所以输出是`2`。

### 应用

- 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。

```javascript
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter
```

- 上面代码的`foo`函数，如果调用的时候没有参数，就会调用默认值`throwIfMissing`函数，从而抛出一个错误。

- 从上面代码还可以看到，参数`mustBeProvided`的默认值等于`throwIfMissing`函数的运行结果（注意函数名`throwIfMissing`之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。

- 另外，可以将参数默认值设为`undefined`，表明这个参数是可以省略的。

```javascript
function foo(optional = undefined) { ··· }
```

## rest 参数

- ES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

```javascript
function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
```

- 上面代码的`add`函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。

- 下面是一个 rest 参数代替`arguments`变量的例子。

```javascript
// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();

var sortNumbers = function sortNumbers() {
  for (var _len = arguments.length, numbers = Array(_len), _key = 0; _key < _len; _key++) {
    numbers[_key] = arguments[_key];
  }

  return numbers.sort();
};
```

- `arguments`对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用`Array.prototype.slice.call`先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。

- 下面是一个利用 rest 参数改写数组`push`方法的例子。

```javascript
  function push(array, ...items) {
    items.forEach(function(item) {
      array.push(item);
      console.log(item);
    });
  }

  var a = [];
  push(a, 1, 2, 3)
```

- 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。

```javascript
// 报错
function f(a, ...b, c) {
  // ...
}
```

- 函数的`length`属性，不包括 rest 参数。

```javascript
(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
```

### 严格模式

- 从 ES5 开始，函数内部可以设定为严格模式。

```javascript
function doSomething(a, b) {
  'use strict';
  // code
}
```

- ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。

```javascript
// 报错
function doSomething(a, b = a) {
  'use strict';
  // code
}

// 报错
const doSomething = function ({a, b}) {
  'use strict';
  // code
};

// 报错
const doSomething = (...a) => {
  'use strict';
  // code
};

const obj = {
  // 报错
  doSomething({a, b}) {
    'use strict';
    // code
  }
};
```

- 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。

```javascript
// 报错
function doSomething(value = 070) {
  'use strict';
  return value;
}
```

- 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。

```javascript
'use strict';

function doSomething(a, b = a) {
  // code
}
```

- 第二种是把函数包在一个无参数的立即执行函数里面。

```javascript
const doSomething = (function () {
  'use strict';
  return function(value = 42) {
    return value;
  };
}());
```

## name 属性

- 函数的`name`属性，返回该函数的函数名。

```javascript
function foo() {}
foo.name // "foo"
```

- 这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。

- 需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的`name`属性，会返回空字符串，而 ES6 的`name`属性会返回实际的函数名。

```javascript
var f = function () {};

// ES5
f.name // ""

// ES6
f.name // "f"
```

- 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的`name`属性都返回这个具名函数原本的名字。

```javascript
const bar = function baz() {};

// ES5
bar.name // "baz"

// ES6
bar.name // "baz"
```

- `Function`构造函数返回的函数实例，`name`属性的值为`anonymous`。

```javascript
(new Function).name // "anonymous"
```

- `bind`返回的函数，`name`属性值会加上`bound`前缀。

```javascript
function foo() {};
foo.bind({}).name // "bound foo"

(function(){}).bind({}).name // "bound "
```

## 箭头函数

### 基本用法

- ES6 允许使用“箭头”（`=>`）定义函数。

```javascript
var f = v => v;

// 等同于
var f = function (v) {
  return v;
};
```

- 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。

```javascript
var f = () => 5;
// 等同于
var f = function () { return 5 };

var sum = (num1, num2) => num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};
```

- 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用`return`语句返回。

```javascript
var sum = (num1, num2) => { return num1 + num2; }
```

- 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。

```javascript
// 报错
let getTempItem = id => { id: id, name: "Temp" };

// 不报错
let getTempItem = id => ({ id: id, name: "Temp" });
```

- 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。

```javascript
let fn = () => void doesNotReturn();
```

- 箭头函数的一个用处是简化回调函数。

```javascript
// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x => x * x);
```

- 下面是 rest 参数与箭头函数结合的例子。

```javascript
const numbers = (...nums) => nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]

const headAndTail = (head, ...tail) => [head, tail];

headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
```

### 使用注意点

1. 函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象。

2. 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。

3. 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

4. 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。

- 上面四点中，第一点尤其值得注意。`this`对象的指向是可变的，但是在箭头函数中，它是固定的。

```javascript
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

var id = 21;

foo.call({ id: 42 });
// id: 42
```

- 上面代码中，`setTimeout`的参数是一个箭头函数，这个箭头函数的定义生效是在`foo`函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时`this`应该指向全局对象`window`，这时应该输出`21`。但是，箭头函数导致`this`总是指向函数定义生效时所在的对象（本例是`{id: 42}`），所以输出的是`42`。

- `this`指向的固定化，并不是因为箭头函数内部有绑定`this`的机制，实际原因是箭头函数根本没有自己的`this`，导致内部的`this`就是外层代码块的`this`。正是因为它没有`this`，所以也就不能用作构造函数。

- 所以，箭头函数转成 ES5 的代码如下。

```javascript
// ES6
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;

  setTimeout(function () {
    console.log('id:', _this.id);
  }, 100);
}
```

- 上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的`this`，而是引用外层的`this`。

```javascript
function foo() {
  return () => {
    return () => {
      return () => {
        console.log('id:', this.id);
      };
    };
  };
}

var f = foo.call({id: 1});

var t1 = f.call({id: 2})()(); // id: 1
var t2 = f().call({id: 3})(); // id: 1
var t3 = f()().call({id: 4}); // id: 1
```

- 上面代码之中，只有一个`this`，就是函数`foo`的`this`，所以`t1`、`t2`、`t3`都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的`this`，它们的`this`其实都是最外层`foo`函数的`this`。

- 除了`this`，以下**三个变量**在箭头函数之中也是**不存在的**，指向外层函数的对应变量：`arguments`、`super`、`new.target`。

```javascript
function foo() {
  setTimeout(() => {
    console.log('args:', arguments);
  }, 100);
}

foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]
```

- 上面代码中，箭头函数内部的变量`arguments`，其实是函数`foo`的`arguments`变量。

- 另外，由于箭头函数没有自己的`this`，所以当然也就不能用`call()`、`apply()`、`bind()`这些方法去改变`this`的指向。

```javascript
(function() {
  return [
    (() => this.x).bind({ x: 'inner' })()
  ];
}).call({ x: 'outer' });
// ['outer']
```

- 上面代码中，箭头函数没有自己的`this`，所以`bind`方法无效，内部的`this`指向外部的`this`。

- 长期以来，JavaScript 语言的`this`对象一直是一个令人头痛的问题，在对象方法中使用`this`，必须非常小心。箭头函数”绑定”`this`，很大程度上解决了这个困扰。

### 不适用场合

- 由于箭头函数使得`this`从“动态”变成“静态”，下面两个场合不应该使用箭头函数。

- 第一个场合是定义函数的方法，且该方法内部包括`this`。

```javascript
const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
  }
}
```

- 第二个场合是需要动态`this`的时候，也不应使用箭头函数。

```javascript
var button = document.getElementById('press');
button.addEventListener('click', () => {
  this.classList.toggle('on');
});
```

- 上面代码运行时，点击按钮会报错，因为`button`的监听函数是一个箭头函数，导致里面的`this`就是全局对象。如果改成普通函数，`this`就会动态指向被点击的按钮对象。

- 另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。

### 嵌套的箭头函数

- 箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。

```javascript
function insert(value) {
  return {into: function (array) {
    return {after: function (afterValue) {
      array.splice(array.indexOf(afterValue) + 1, 0, value);
      return array;
    }};
  }};
}

insert(2).into([1, 3]).after(1); //[1, 2, 3]
```

- 上面这个函数，可以使用箭头函数改写。

```javascript
let insert = (value) => ({into: (array) => ({after: (afterValue) => {
  array.splice(array.indexOf(afterValue) + 1, 0, value);
  return array;
}})});

insert(2).into([1, 3]).after(1); //[1, 2, 3]
```

- 下面是一个**部署管道机制**（pipeline）的例子，即前一个函数的输出是后一个函数的输入。

```javascript
const pipeline = (...funcs) =>
  val => funcs.reduce((a, b) => b(a), val);

const plus1 = a => a + 1;
const mult2 = a => a * 2;
const addThenMult = pipeline(plus1, mult2);

addThenMult(5)
// 12
```

- 如果觉得上面的写法可读性比较差，也可以采用下面的写法。

```javascript
const plus1 = a => a + 1;
const mult2 = a => a * 2;

mult2(plus1(5))
// 12
```

- 箭头函数还有一个功能，就是可以很方便地改写 λ 演算。

```javascript
// λ演算的写法
fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))

// ES6的写法
var fix = f => (x => f(v => x(x)(v)))
               (x => f(v => x(x)(v)));
```

- 上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。

## 双冒号运算符

- 箭头函数可以绑定`this`对象，大大减少了显式绑定`this`对象的写法（`call`、`apply`、`bind`）。但是，箭头函数并不适用于所有场合，所以现在有一个[提案](https://github.com/zenparsing/es-function-bind)，提出了“函数绑定”（function bind）运算符，用来取代`call`、`apply`、`bind`调用。

- 函数绑定运算符是并排的两个冒号（`::`），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即`this`对象），绑定到右边的函数上面。

```javascript
foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);

const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return obj::hasOwnProperty(key);
}
```

- 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。

```javascript
var method = obj::obj.foo;
// 等同于
var method = ::obj.foo;

let log = ::console.log;
// 等同于
var log = console.log.bind(console);
```

- 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。

```javascript
import { map, takeWhile, forEach } from "iterlib";

getPlayers()
::map(x => x.character())
::takeWhile(x => x.strength > 100)
::forEach(x => console.log(x));
```

## 尾调用优化

### 什么是尾调用？

- 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。

```javascript
function f(x){
  return g(x);
}
```

- 上面代码中，函数`f`的最后一步是调用函数`g`，这就叫尾调用。

- 以下三种情况，都不属于尾调用。

```javascript
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){
  g(x);
}
```

- 上面代码中，情况一是调用函数`g`之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。

```javascript
function f(x){
  g(x);
  return undefined;
}
```

```javascript
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```

- 上面代码中，函数`m`和`n`都属于尾调用，因为它们都是函数`f`的最后一步操作。

### 尾调用优化

- 尾调用之所以与其他调用不同，就在于它的特殊的调用位置。

- 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数`A`的内部调用函数`B`，那么在`A`的调用帧上方，还会形成一个`B`的调用帧。等到`B`运行结束，将结果返回到`A`，`B`的调用帧才会消失。如果函数`B`内部还调用函数`C`，那就还有一个`C`的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。

- 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。

```javascript
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```

- 上面代码中，如果函数`g`不是尾调用，函数`f`就需要保存内部变量`m`和`n`的值、`g`的调用位置等信息。但由于调用`g`之后，函数`f`就结束了，所以执行到最后一步，完全可以删除`f(x)`的调用帧，只保留`g(3)`的调用帧。

- 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。

- 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。

```javascript
function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}
```

- 上面的函数不会进行尾调用优化，因为内层函数`inner`用到了外层函数`addOne`的内部变量`one`。

### 尾递归

- 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

- 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

```javascript
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120
```

- 上面代码是一个阶乘函数，计算`n`的阶乘，最多需要保存`n`个调用记录，复杂度 O(n) 。

- 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。

```javascript
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120
```

- 还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。

- 非尾递归的 Fibonacci 数列实现如下。

```javascript
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 堆栈溢出
Fibonacci(500) // 堆栈溢出
```

- 尾递归优化过的 Fibonacci 数列实现如下。

```javascript
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
```

- 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。

### 递归函数的改写

尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量`total`，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算`5`的阶乘，需要传入两个参数`5`和`1`？

两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。

```javascript
function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

function factorial(n) {
  return tailFactorial(n, 1);
}

factorial(5) // 120
```

上面代码通过一个正常形式的阶乘函数`factorial`，调用尾递归函数`tailFactorial`，看起来就正常多了。

函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。

```javascript
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120
```

上面代码通过柯里化，将尾递归函数`tailFactorial`变为只接受一个参数的`factorial`。

第二种方法就简单多了，就是采用 ES6 的函数默认值。

```javascript
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
```

上面代码中，参数`total`有默认值`1`，所以调用时不用提供这个值。

总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归

### 严格模式

ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。

这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。

- `func.arguments`：返回调用时函数的参数。
- `func.caller`：返回调用当前函数的那个函数。

尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。

```javascript
function restricted() {
  'use strict';
  restricted.caller;    // 报错
  restricted.arguments; // 报错
}
restricted();
```

## 函数参数的尾逗号

- ES2017 [允许](https://github.com/jeffmo/es-trailing-function-commas)函数的最后一个参数有尾逗号（trailing comma）。

- 此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。

```javascript
function clownsEverywhere(
  param1,
  param2
) { /* ... */ }

clownsEverywhere(
  'foo',
  'bar'
);
```

- 上面代码中，如果在`param2`或`bar`后面加一个逗号，就会报错。

- 如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数`clownsEverywhere`添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。

```javascript
function clownsEverywhere(
  param1,
  param2,
) { /* ... */ }

clownsEverywhere(
  'foo',
  'bar',
);
```

- 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。

# 8. 数组的扩展

## ES5.1重要扩展

### Array.prototype.map()

**参数**

- **callback**，生成新数组元素的函数，使用三个参数（都是自动传入的）：
  - currentValue，callback数组当前正在使用的元素
  - index，当前正在处理的元素的索引
  - array，正在调用map方法的数组
  - callback(currentValue[, index[, array]])
- **thisArg**
  - 执行callback时，使用的this值
  - 如果 `thisArg` 参数有值，则每次 `callback` 函数被调用的时候，`this` 都会指向 `thisArg` 参数上的这个对象。如果省略了 `thisArg `参数,或者赋值为 null` 或 `undefined`，则 this 指向全局对象 。

- `map` 方法会给原数组中的每个元素都按顺序调用一次  `callback` 函数。`callback` 每次执行后的返回值（包括 [`undefined`]）组合起来形成一个新数组。 `callback` 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 `delete` 删除的索引则不会被调用。
- `map `不修改调用它的原数组本身（当然可以在 `callback` 执行时改变原数组），需要**显式return并接受**
- 使用 map 方法处理数组时，数组元素的范围是在 callback 方法**第一次**调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。
- 用箭头函数简化

```js
const arr = [1,2,3,4,5,6,]
/*const arr2 = arr.map((item) => {
  return item+10
})*/
const arr2 = arr.map((item) => {item+10})
console.log(arr,arr2)
// Array(6) [1, 2, 3, 4, 5, 6]
// Array(6) [11, 12, 13, 14, 15, 16]

const numbers = [1, 4, 9];
const roots = numbers.map(Math.sqrt);
// Math.sqrt()也传入了value、index、array，只是方法本身只接受一个参数，所以ok
// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9]

["1", "2", "3"].map(parseInt)
// 你可能觉的会是[1, 2, 3]
// 但实际的结果是 [1, NaN, NaN]
['1', '2', '3'].map( str => parseInt(str) );
// 一个更简单的方式:
['1', '2', '3'].map(Number); // [1, 2, 3]
// 与`parseInt` 不同，下面的结果会返回浮点数或指数:
['1.1', '2.2e2', '3e300'].map(Number); // [1.1, 220, 3e+300]
```

**使用ES5实现map方法**

- ```js
  // 实现 ECMA-262, Edition 5, 15.4.4.19
  // 参考: http://es5.github.com/#x15.4.4.19
  if (!Array.prototype.map) {
    Array.prototype.map = function(callback, thisArg) {
  
      var T, A, k;
  
      if (this == null) {
        throw new TypeError(" this is null or not defined");
      }
  
      // 1. 将O赋值为调用map方法的数组.
      var O = Object(this);
  
      // 2.将len赋值为数组O的长度.
      var len = O.length >>> 0;
  
      // 3.如果callback不是函数,则抛出TypeError异常.
      if (Object.prototype.toString.call(callback) != "[object Function]") {
        throw new TypeError(callback + " is not a function");
      }
  
      // 4. 如果参数thisArg有值,则将T赋值为thisArg;否则T为undefined.
      if (thisArg) {
        T = thisArg;
      }
  
      // 5. 创建新数组A,长度为原数组O长度len
      A = new Array(len);
  
      // 6. 将k赋值为0
      k = 0;
  
      // 7. 当 k < len 时,执行循环.
      while(k < len) {
  
        var kValue, mappedValue;
  
        //遍历O,k为原数组索引
        if (k in O) {
  
          //kValue为索引k对应的值.
          kValue = O[ k ];
  
          // 执行callback,this指向T,参数有三个.分别是kValue:值,k:索引,O:原数组.
          mappedValue = callback.call(T, kValue, k, O);
  
          // 返回值添加到新数组A中.
          A[ k ] = mappedValue;
        }
        // k自增1
        k++;
      }
  
      // 8. 返回新数组A
      return A;
    };      
  }
  ```

### Array.prototype.filter()

**参数**

- 和map()类似，自动传入三个参数，可设置thisArg

**描述**

- `filter` 为数组中的每个元素调用一次 `callback` 函数，并利用所有使得 `callback` 返回 true 或 等价于 true 的值的元素创建一个新数组。
- `callback` 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 `callback` 测试的元素会被跳过，不会被包含在新数组中。
- `filter`同样不会改变原数组，遍历的元素在第一次调用callback时时决定

- ```js
  function isBigEnough(element) {
    return element >= 10;
  }
  var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
  // filtered is [12, 130, 44]
  
  ```

**ES5的实现**

- ```js
  if (!Array.prototype.filter)
  {
    Array.prototype.filter = function(fun /* , thisArg*/)
    {
      "use strict";
  
      if (this === void 0 || this === null)
        throw new TypeError();
  
      var t = Object(this);
      var len = t.length >>> 0;
      if (typeof fun !== "function")
        throw new TypeError();
  
      var res = [];
      var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
      for (var i = 0; i < len; i++)
      {
        if (i in t)
        {
          var val = t[i];
  
          // NOTE: Technically this should Object.defineProperty at
          //       the next index, as push can be affected by
          //       properties on Object.prototype and Array.prototype.
          //       But that method's new, and collisions should be
          //       rare, so use the more-compatible alternative.
          if (fun.call(thisArg, val, i, t))
            res.push(val);
        }
      }
  
      return res;
    };
  }
  ```

### Array.prototype.reduce()

- `reduce()` 方法对数组中的每个元素执行一个由您提供的**reducer**函数(升序执行)，将其结果汇总为单个返回值。

**参数**

- callback：**reducer函数**，接受4个参数
  - Accumulator (acc) (累计器)
  - Current Value (cur) (当前值)
  - Current Index (idx) (当前索引)
  - Source Array (src) (源数组)
  - **reducer函数**的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。

- initialValue：可选

  - 作为第一次调用 `callback函数时`的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。

- 回调函数第一次执行时，`accumulator` 和`currentValue`的取值有两种情况：

  - 如果调用`reduce()`时提供了`initialValue`，`accumulator`取值为`initialValue`，`currentValue`取数组中的第一个值；
  - 如果没有提供 `initialValue`，那么`accumulator`取数组中的第一个值，`currentValue`取数组中的第二个值。
  - **注意：**如果没有提供`initialValue`，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供`initialValue`，从索引0开始。

- ```js
  const total = [ 0, 1, 2, 3 ].reduce(
    ( acc, cur ) => acc + cur,
    0
  );
  // 进行累加操作，一定要提供初始值，任意值即可
  
  //将二维数组转化为一维
  const flattened = [[0, 1], [2, 3], [4, 5]].reduce(
   ( acc, cur ) => acc.concat(cur),
   []
  );
  // flattened is [0, 1, 2, 3, 4, 5]
  
  // 计算数组中每个元素出现的次数
  var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];
  
  var countedNames = names.reduce(function (allNames, name) { 
    if (name in allNames) {
      allNames[name]++;
    }
    else {
      allNames[name] = 1;
    }
    return allNames;
  }, {});
  // countedNames is:
  // { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }
  
  // 数组去重
  let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];
  let result = arr.sort().reduce((init, current)=>{
      if(init.length===0 || init[init.length-1]!==current){
          init.push(current);
      }
      return init;
  }, []);
  console.log(result); //[1,2,3,4,5]
  ```

**ployfill**

- ```js
  // Production steps of ECMA-262, Edition 5, 15.4.4.21
  // Reference: http://es5.github.io/#x15.4.4.21
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  if (!Array.prototype.reduce) {
    Object.defineProperty(Array.prototype, 'reduce', {
      value: function(callback /*, initialValue*/) {
        if (this === null) {
          throw new TypeError( 'Array.prototype.reduce ' + 
            'called on null or undefined' );
        }
        if (typeof callback !== 'function') {
          throw new TypeError( callback +
            ' is not a function');
        }
  
        // 1. Let O be ? ToObject(this value).
        var o = Object(this);
  
        // 2. Let len be ? ToLength(? Get(O, "length")).
        var len = o.length >>> 0; 
  
        // Steps 3, 4, 5, 6, 7      
        var k = 0; 
        var value;
  
        if (arguments.length >= 2) {
          value = arguments[1];
        } else {
          while (k < len && !(k in o)) {
            k++; 
          }
  
          // 3. If len is 0 and initialValue is not present,
          //    throw a TypeError exception.
          if (k >= len) {
            throw new TypeError( 'Reduce of empty array ' +
              'with no initial value' );
          }
          value = o[k++];
        }
  
        // 8. Repeat, while k < len
        while (k < len) {
          // a. Let Pk be ! ToString(k).
          // b. Let kPresent be ? HasProperty(O, Pk).
          // c. If kPresent is true, then
          //    i.  Let kValue be ? Get(O, Pk).
          //    ii. Let accumulator be ? Call(
          //          callbackfn, undefined,
          //          « accumulator, kValue, k, O »).
          if (k in o) {
            value = callback(value, o[k], k, o);
          }
  
          // d. Increase k by 1.      
          k++;
        }
  
        // 9. Return accumulator.
        return value;
      }
    });
  }
  ```

- 

## 扩展运算符

### 含义

- 扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，**隐式遍历**

```javascript
console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll('div')]
// [<div>, <div>, <div>]
```

- 该运算符主要用于函数调用。

```javascript
function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

const numbers = [4, 38];
add(...numbers) // 42
```

- 上面代码中，`array.push(...items)`和`add(...numbers)`这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。

扩展运算符与正常的函数参数可以结合使用，非常灵活。

```javascript
function f(v, w, x, y, z) { }
const args = [0, 1];
f(-1, ...args, 2, ...[3]);
```

扩展运算符后面还可以放置表达式。

```javascript
const arr = [
  ...(x > 0 ? ['a'] : []),
  'b',
];
```

- 如果扩展运算符后面是一个空数组，则不产生任何效果。

```javascript
[...[], 1]
// [1]
```

- 注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。

```javascript
(...[1, 2])
// Uncaught SyntaxError: Unexpected number

console.log((...[1, 2]))
// Uncaught SyntaxError: Unexpected number

console.log(...[1, 2])
// 1 2
```

- 上面前两种情况都会报错，因为扩展运算符所在的括号不是函数调用，而第三种情况`console.log(...[1, 2])`就不会报错，因为这时是函数调用。

### 替代函数的 apply 方法

- 由于扩展运算符可以展开数组，所以不再需要`apply`方法，将数组转为函数的参数了。

```javascript
// ES5 的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) {
  // ...
}
let args = [0, 1, 2];
f(...args);
```

- 下面是扩展运算符取代`apply`方法的一个实际的例子，应用`Math.max`方法，简化求出一个数组最大元素的写法。

```javascript
// ES5 的写法
Math.max.apply(null, [14, 3, 77])

// ES6 的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
```

- 上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用`Math.max`函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用`Math.max`了。

- 另一个例子是通过`push`函数，将一个数组添加到另一个数组的尾部。

```javascript
// ES5的 写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);

// ES6 的写法
let arr1 = [0, 1, 2];
let arr2 = [3, 4, 5];
arr1.push(...arr2);
```

- 上面代码的 ES5 写法中，`push`方法的参数不能是数组，所以只好通过`apply`方法变通使用`push`方法。有了扩展运算符，就可以直接将数组传入`push`方法。

- 下面是另外一个例子。

```javascript
// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);
```

### 扩展运算符的应用

**（1）复制数组**

- ES5 只能用变通方法来复制数组。

```javascript
const a1 = [1, 2];
const a2 = a1.concat();

a2[0] = 2;
a1 // [1, 2]
```

- 上面代码中，`a1`会返回原数组的克隆，再修改`a2`就不会对`a1`产生影响。

- 扩展运算符提供了复制数组的简便写法。

```javascript
const a1 = [1, 2];
// 写法一
const a2 = [...a1];

function _toConsumableArray(arr) { 
  if (Array.isArray(arr)) { 
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { 
      arr2[i] = arr[i]; 
    } 
    return arr2; 
  } else { 
    return Array.from(arr); 
  } 
}

var a2 = [].concat(_toConsumableArray(a1));

// 写法二
const [...a2] = a1;

function _toArray(arr) { 
  return Array.isArray(arr) ? arr : Array.from(arr); 
}

var _a = a1,
    _a2 = _toArray(_a),
    a2 = _a2.slice(0);
```

- 上面的两种写法，`a2`都是`a1`的克隆。

**（2）合并数组**

- 扩展运算符提供了数组合并的新写法。

```javascript
const arr1 = ['a', 'b'];
const arr2 = ['c'];
const arr3 = ['d', 'e'];

// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]

// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]
// babel
[].concat(arr1, arr2, arr3);
```

- 不过，这两种方法都是浅拷贝，使用的时候需要注意。

```javascript
const a1 = [{ foo: 1 }];
const a2 = [{ bar: 2 }];

const a3 = a1.concat(a2);
const a4 = [...a1, ...a2];

a3[0] === a1[0] // true
a4[0] === a1[0] // true
```

- 上面代码中，`a3`和`a4`是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。

**（3）与解构赋值结合**

- 扩展运算符可以与解构赋值结合起来，用于生成数组。

```javascript
// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
```

- 下面是另外一些例子。

```javascript
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []

const [first, ...rest] = ["foo"];
first  // "foo"
rest   // []
```

- 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

```javascript
const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
```

**（4）字符串**

- 扩展运算符还可以将字符串转为真正的数组。

```javascript
[...'hello']
// [ "h", "e", "l", "l", "o" ]

function _toConsumableArray(arr) { 
  if (Array.isArray(arr)) { 
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { 
      arr2[i] = arr[i]; 
    } 
    return arr2; 
  } else { 
    return Array.from(arr); 
  } 
}

[].concat(_toConsumableArray('hello'));
```

**（5）实现了 Iterator 接口的对象**

- 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。

```javascript
let nodeList = document.querySelectorAll('div');
let array = [...nodeList];
```

- 上面代码中，`querySelectorAll`方法返回的是一个`NodeList`对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于`NodeList`对象实现了 Iterator 。

- 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。

```javascript
let arrayLike = {
  '0': 'a',
  '1': 'b',
  '2': 'c',
  length: 3
};

// TypeError: Cannot spread non-iterable object.
let arr = [...arrayLike];
```

- 上面代码中，`arrayLike`是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用`Array.from`方法将`arrayLike`转为真正的数组。

**（6）Map 和 Set 结构，Generator 函数**

- 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。

```javascript
let map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

let arr = [...map.keys()]; // [1, 2, 3]
```

- Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。

```javascript
const go = function*(){
  yield 1;
  yield 2;
  yield 3;
};

[...go()] // [1, 2, 3]
```

- 上面代码中，变量`go`是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。

- 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。

```javascript
const obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
```

## Array.from()

- `Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。

- 下面是一个类似数组的对象，`Array.from`将它转为真正的数组。

```javascript
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

- 只要是部署了 Iterator 接口的数据结构，`Array.from`都能将其转为数组。

```javascript
Array.from('hello')
// ['h', 'e', 'l', 'l', 'o']

let namesSet = new Set(['a', 'b'])
Array.from(namesSet) // ['a', 'b']
```

- 上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被`Array.from`转为真正的数组。

如果参数是一个真正的数组，`Array.from`会返回一个一模一样的新数组。

```javascript
Array.from([1, 2, 3])
// [1, 2, 3]
```

- 值得提醒的是，扩展运算符（`...`）也可以将某些数据结构转为数组。

```javascript
// arguments对象
function foo() {
  const args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll('div')]
```

- 扩展运算符背后调用的是遍历器接口（`Symbol.iterator`），如果一个对象没有部署这个接口，就无法转换。`Array.from`方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有`length`属性。因此，任何有`length`属性的对象，都可以通过`Array.from`方法转为数组，而此时扩展运算符就无法转换。

```javascript
Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
```

- 上面代码中，`Array.from`返回了一个具有三个成员的数组，每个位置的值都是`undefined`。扩展运算符转换不了这个对象。

- 对于还没有部署该方法的浏览器，可以用`Array.prototype.slice`方法替代。

```javascript
const toArray = (() =>
  Array.from ? Array.from : obj => [].slice.call(obj)
)();
```

- `Array.from`还可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。

```javascript
Array.from(arrayLike, x => x * x);
// 等同于
Array.from(arrayLike).map(x => x * x);

Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
```

- 下面的例子是取出一组 DOM 节点的文本内容。

```javascript
let spans = document.querySelectorAll('span.name');

// map()
let names1 = Array.prototype.map.call(spans, s => s.textContent);

// Array.from()
let names2 = Array.from(spans, s => s.textContent)
```

- 下面的例子将数组中布尔值为`false`的成员转为`0`。

```javascript
Array.from([1, , 2, , 3], (n) => n || 0)
// [1, 0, 2, 0, 3]
```

- 另一个例子是返回各种数据的类型。

```javascript
function typesOf () {
  return Array.from(arguments, value => typeof value)
}
typesOf(null, [], NaN)
// ['object', 'object', 'number']
```

- 如果`map`函数里面用到了`this`关键字，还可以传入`Array.from`的第三个参数，用来绑定`this`。

- `Array.from()`可以将各种值转为真正的数组，并且还提供`map`功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。

```javascript
Array.from({ length: 2 }, () => 'jack')
// ['jack', 'jack']
```

- 上面代码中，`Array.from`的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。

- `Array.from()`的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于`\uFFFF`的 Unicode 字符，算作两个字符的 bug。

```javascript
function countSymbols(string) {
  return Array.from(string).length;
}
```

## Array.of()

- `Array.of`方法用于将一组值，转换为数组。

```javascript
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
```

- 这个方法的主要目的，是弥补数组构造函数`Array()`的不足。因为参数个数的不同，会导致`Array()`的行为有差异。

```javascript
Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
```

- `Array.of`基本上可以用来替代`Array()`或`new Array()`，并且不存在由于参数不同而导致的重载。它的行为非常统一。

```javascript
Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
```

- `Array.of`方法可以用下面的代码模拟实现。

```javascript
function ArrayOf(){
  return [].slice.call(arguments);
}
```

## 数组实例的 copyWithin()

- 数组实例的`copyWithin`方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。

```javascript
Array.prototype.copyWithin(target, start = 0, end = this.length)
```

**接受三个参数**

- target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
- start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

## 数组实例的 find() 和 findIndex()

- 数组实例的`find`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。

```javascript
[1, 4, -5, 10].find((n) => n < 0)
// -5
```

- 上面代码找出数组中第一个小于 0 的成员。

```javascript
[1, 5, 10, 15].find(function(value, index, arr) {
  return value > 9;
}) // 10
```

- 上面代码中，`find`方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。

- 数组实例的`findIndex`方法的用法与`find`方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1`。

```javascript
[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value > 9;
}) // 2
```

- 这两个方法都可以接受第二个参数，用来绑定回调函数的`this`对象。

```javascript
function f(v){
  return v > this.age;
}
let person = {name: 'John', age: 20};
[10, 12, 26, 15].find(f, person);    // 26
```

- 上面的代码中，`find`函数接收了第二个参数`person`对象，回调函数中的`this`对象指向`person`对象。

- 另外，这两个方法都可以发现`NaN`，弥补了数组的`indexOf`方法的不足。

```javascript
[NaN].indexOf(NaN)
// -1

[NaN].findIndex(y => Object.is(NaN, y))
// 0
```

- 上面代码中，`indexOf`方法无法识别数组的`NaN`成员，但是`findIndex`方法可以借助`Object.is`方法做到。

## 数组实例的 fill()

- `fill`方法使用给定值，填充一个数组。

```javascript
['a', 'b', 'c'].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
```

- 上面代码表明，`fill`方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。

## 数组实例的 entries()，keys() 和 values()

- ES6 提供三个新的方法——`entries()`，`keys()`和`values()`——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用`for...of`循环进行遍历，唯一的区别是`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。

## 数组实例的 includes()

- `Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。ES2016 引入了该方法。

```javascript
[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
```

## 数组实例的 flat()，flatMap()

- 数组的成员有时还是数组，`Array.prototype.flat()`用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。

```javascript
[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
```

- 上面代码中，原数组的成员里面有一个数组，`flat()`方法将子数组的成员取出来，添加在原来的位置。

- `flat()`默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将`flat()`方法的参数写成一个整数，表示想要拉平的层数，默认为1。

```javascript
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
```

- `flatMap()`方法对原数组的每个成员执行一个函数（相当于执行`Array.prototype.map()`），然后对返回值组成的数组执行`flat()`方法。该方法返回一个新数组，不改变原数组。

```javascript
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]
```

- `flatMap()`只能展开一层数组。

```javascript
// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()
[1, 2, 3, 4].flatMap(x => [[x * 2]])
// [[2], [4], [6], [8]]
```

## 数组的空位

- 数组的空位指，数组的某一个位置没有任何值。比如，`Array`构造函数返回的数组都是空位。

```javascript
Array(3) // [, , ,]
```

- 注意，空位不是`undefined`，一个位置的值等于`undefined`，依然是有值的。空位是没有任何值，`in`运算符可以说明这一点。

```javascript
0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
```

- 上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。

- **由于空位的处理规则非常不统一，所以建议避免出现空位**

# 9. 对象的扩展

## 属性的简洁表示法

- 上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。

```javascript
function f(x, y) {
  return {x, y};
}

// 等同于

function f(x, y) {
  return {x: x, y: y};
}

f(1, 2) // Object {x: 1, y: 2}
```

- 除了属性简写，方法也可以简写。

```javascript
const o = {
  method() {
    return "Hello!";
  }
};

// 等同于

const o = {
  method: function() {
    return "Hello!";
  }
};
```

- 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。

```javascript
const cart = {
  _wheels: 4,

  get wheels () {
    return this._wheels;
  },

  set wheels (value) {
    if (value < this._wheels) {
      throw new Error('数值太小了！');
    }
    this._wheels = value;
  }
}
```

- 注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。

```javascript
const obj = {
  class () {}
};

// 等同于

var obj = {
  'class': function() {}
};
```

- 上面代码中，`class`是字符串，所以不会因为它属于关键字，而导致语法解析报错。

- 如果某个方法的值是一个 Generator 函数，前面需要加上星号。

```javascript
const obj = {
  * m() {
    yield 'hello world';
  }
};
```

## 属性名表达式

- JavaScript 定义对象的属性，有两种方法。

```javascript
// 方法一
obj.foo = true;

// 方法二
obj['a' + 'bc'] = 123;
```

- 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。

- 但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。

```javascript
var obj = {
  foo: true,
  abc: 123
};
```

- ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。

```javascript
let propKey = 'foo';

let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
};
```

- 下面是另一个例子。

```javascript
let lastWord = 'last word';

const a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"
```

- 表达式还可以用于定义方法名。

```javascript
let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};

obj.hello() // hi
```

- 注意，属性名表达式与简洁表示法，不能同时使用，会报错。

```javascript
// 报错
const foo = 'bar';
const bar = 'abc';
const baz = { [foo] };

// 正确
const foo = 'bar';
const baz = { [foo]: 'abc'};
```

- 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串`[object Object]`，这一点要特别小心。

```javascript
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: "valueB"}
```

- 上面代码中，`[keyA]`和`[keyB]`得到的都是`[object Object]`，所以`[keyB]`会把`[keyA]`覆盖掉，而`myObject`最后只有一个`[object Object]`属性。

## 方法的 name 属性

- 函数的`name`属性，返回函数名。对象方法也是函数，因此也有`name`属性。

```javascript
const person = {
  sayName() {
    console.log('hello!');
  },
};

person.sayName.name   // "sayName"
```

- 上面代码中，方法的`name`属性返回函数名（即方法名）。

- 如果对象的方法使用了取值函数（`getter`）和存值函数（`setter`），则`name`属性不是在该方法上面，而是该方法的属性的描述对象的`get`和`set`属性上面，返回值是方法名前加上`get`和`set`。

```javascript
const obj = {
  get foo() {},
  set foo(x) {}
};

obj.foo.name
// TypeError: Cannot read property 'name' of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

descriptor.get.name // "get foo"
descriptor.set.name // "set foo"
```

- 有两种特殊情况：`bind`方法创造的函数，`name`属性返回`bound`加上原函数的名字；`Function`构造函数创造的函数，`name`属性返回`anonymous`。

```javascript
(new Function()).name // "anonymous"

var doSomething = function() {
  // ...
};
doSomething.bind().name // "bound doSomething"
```

- 如果对象的方法是一个 Symbol 值，那么`name`属性返回的是这个 Symbol 值的描述。

```javascript
const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // "[description]"
obj[key2].name // ""
```

- 上面代码中，`key1`对应的 Symbol 值有描述，`key2`没有。

## 属性的可枚举性和遍历

### 可枚举性

- 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。`Object.getOwnPropertyDescriptor`方法可以获取该属性的描述对象。

```javascript
let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
```

- 描述对象的`enumerable`属性，称为“可枚举性”，如果该属性为`false`，就表示某些操作会忽略当前属性。

- 目前，有四个操作会忽略`enumerable`为`false`的属性。
  - `for...in`循环：只遍历对象自身的和继承的可枚举的属性。
  - `Object.keys()`：返回对象自身的所有可枚举的属性的键名。
  - `JSON.stringify()`：只串行化对象自身的可枚举的属性。
  - `Object.assign()`： 忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性。

- 这四个操作之中，前三个是 ES5 就有的，最后一个`Object.assign()`是 ES6 新增的。其中，只有`for...in`会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（`enumerable`）这个概念的最初目的，就是让某些属性可以规避掉`for...in`操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的`toString`方法，以及数组的`length`属性，就通过“可枚举性”，从而避免被`for...in`遍历到。

```javascript
Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable
// false

Object.getOwnPropertyDescriptor([], 'length').enumerable
// false
```

- 上面代码中，`toString`和`length`属性的`enumerable`都是`false`，因此`for...in`不会遍历到这两个继承自原型的属性。

- 另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。

```javascript
Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable
// false
```

- 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用`for...in`循环，而用`Object.keys()`代替。

### 属性的遍历

ES6 一共有 5 种方法可以遍历对象的属性。

**（1）for...in**

- `for...in`循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

**（2）Object.keys(obj)**

- `Object.keys`返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

**（3）Object.getOwnPropertyNames(obj)**

- `Object.getOwnPropertyNames`返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

**（4）Object.getOwnPropertySymbols(obj)**

- `Object.getOwnPropertySymbols`返回一个数组，包含对象自身的所有 Symbol 属性的键名。

**（5）Reflect.ownKeys(obj)**

- `Reflect.ownKeys`返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。

- 首先遍历所有数值键，按照数值升序排列。
- 其次遍历所有字符串键，按照加入时间升序排列。
- 最后遍历所有 Symbol 键，按照加入时间升序排列。

```javascript
Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// ['2', '10', 'b', 'a', Symbol()]
```

- 上面代码中，`Reflect.ownKeys`方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性`2`和`10`，其次是字符串属性`b`和`a`，最后是 Symbol 属性。

## super 关键字

- 我们知道，`this`关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字`super`，指向当前对象的原型对象。

```javascript
const proto = {
  foo: 'hello'
};

const obj = {
  foo: 'world',
  find() {
    return super.foo;
  }
};

Object.setPrototypeOf(obj, proto);
obj.find() // "hello"
```

- 上面代码中，对象`obj.find()`方法之中，通过`super.foo`引用了原型对象`proto`的`foo`属性。

- 注意，`super`关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。

```javascript
// 报错
const obj = {
  foo: super.foo
}

// 报错
const obj = {
  foo: () => super.foo
}

// 报错
const obj = {
  foo: function () {
    return super.foo
  }
}
```

- 上面三种`super`的用法都会报错，因为对于 JavaScript 引擎来说，这里的`super`都没有用在对象的方法之中。第一种写法是`super`用在属性里面，第二种和第三种写法是`super`用在一个函数里面，然后赋值给`foo`属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。

- JavaScript 引擎内部，`super.foo`等同于`Object.getPrototypeOf(this).foo`（属性）或`Object.getPrototypeOf(this).foo.call(this)`（方法）。

```javascript
const proto = {
  x: 'hello',
  foo() {
    console.log(this.x);
  },
};

const obj = {
  x: 'world',
  foo() {
    super.foo();
  }
}

Object.setPrototypeOf(obj, proto);

obj.foo() // "world"
```

- 上面代码中，`super.foo`指向原型对象`proto`的`foo`方法，但是绑定的`this`却还是当前对象`obj`，因此输出的就是`world`。

## 对象的扩展运算符

《数组的扩展》一章中，已经介绍过扩展运算符（`...`）。ES2018 将这个运算符引入了对象。

### 解构赋值

- 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。

```javascript
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```

- 由于解构赋值要求等号右边是一个对象，所以如果等号右边是`undefined`或`null`，就会报错，因为它们无法转为对象。

```javascript
let { x, y, ...z } = null; // 运行时错误
let { x, y, ...z } = undefined; // 运行时错误
```

- 解构赋值必须是最后一个参数，否则会报错。

```javascript
let { ...x, y, z } = someObject; // 句法错误
let { x, ...y, ...z } = someObject; // 句法错误
```

- 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。

```javascript
let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2;
x.a.b // 2
```

- 上面代码中，`x`是解构赋值所在的对象，拷贝了对象`obj`的`a`属性。`a`属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。

- 另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。

```javascript
let o1 = { a: 1 };
let o2 = { b: 2 };
o2.__proto__ = o1;
let { ...o3 } = o2;
o3 // { b: 2 }
o3.a // undefined
```

- 上面代码中，对象`o3`复制了`o2`，但是只复制了`o2`自身的属性，没有复制它的原型对象`o1`的属性。

# 10. 对象的新增方法

## Object.is() 

- ES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。

- ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。

- 不同之处只有两个：一是`+0`不等于`-0`，二是`NaN`等于自身。

  - ```javascript
    +0 === -0 //true
    NaN === NaN // false
    
    Object.is(+0, -0) // false
    Object.is(NaN, NaN) // true
    ```

**polyfill**

- ```javascript
  Object.defineProperty(Object, 'is', {
    value: function(x, y) {
      if (x === y) {
        // 针对+0 不等于 -0的情况
        return x !== 0 || 1 / x === 1 / y;
      }
      // 针对NaN的情况
      return x !== x && y !== y;
    },
    configurable: true,
    enumerable: false,
    writable: true
  });
  ```

## Object.assign()

### 基本用法

- `Object.assign`方法用于对象的合并，将源对象（source）的所有可**枚举属性**，复制到目标对象（target）。

- ```javascript
  const target = { a: 1 };
  
  const source1 = { b: 2 };
  const source2 = { c: 3 };
  
  Object.assign(target, source1, source2);
  target // {a:1, b:2, c:3}
  ```

- `Object.assign`方法的第一个参数是目标对象，后面的参数都是源对象。

### **参数**

- 如果只有一个参数，`Object.assign`会直接返回该参数。

  ```javascript
  const obj = {a: 1};
  Object.assign(obj) === obj // true
  ```

- 如果该参数不是对象，则会先转成对象，然后返回。

  ```javascript
  typeof Object.assign(2) // "object"
  ```

- 由于`undefined`和`null`无法转成对象，所以如果它们作为参数，就会报错。

  ```javascript
  Object.assign(undefined) // 报错
  Object.assign(null) // 报错
  ```

- 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果`undefined`和`null`不在首参数，就不会报错。

  ```javascript
  let obj = {a: 1};
  Object.assign(obj, undefined) === obj // true
  Object.assign(obj, null) === obj // true
  ```

- 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。

  ```javascript
  const v1 = 'abc';
  const v2 = true;
  const v3 = 10;
  
  const obj = Object.assign({}, v1, v2, v3);
  console.log(obj); // { "0": "a", "1": "b", "2": "c" }
  //上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。
  ```

- 布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性`[[PrimitiveValue]]`上面，这个属性是不会被`Object.assign`拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。

  ```javascript
  Object(true) // {[[PrimitiveValue]]: true}
  Object(10)  //  {[[PrimitiveValue]]: 10}
  Object('abc') // {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}
  ```

- `Object.assign`拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（`enumerable: false`）

  ```javascript
  Object.assign({b: 'c'},
    Object.defineProperty({}, 'invisible', {
      enumerable: false,
      value: 'hello'
    })
  )
  // { b: 'c' }
  // 上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。
  ```

- 属性名为 Symbol 值的属性，也会被`Object.assign`拷贝。

  ```javascript
  Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' })
  // { a: 'b', Symbol(c): 'd' }
  ```

### 注意

- **target本身也会被修改，同时也会返回修改后的target**
- 如果目标对象与源对象有**同名属性**，或多个源对象有同名属性，则后面的属性会覆盖前面的属性

**浅拷贝**

- `Object.assign`方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。

  ```javascript
  const obj1 = {a: {b: 1}};
  const obj2 = Object.assign({}, obj1);
  
  obj1.a.b = 2;
  obj2.a.b // 2
  ```

- 上面代码中，源对象`obj1`的`a`属性的值是一个对象，`Object.assign`拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。

**数组的处理**

- `Object.assign`可以用来处理数组，但是会把数组视为对象。

  ```javascript
  Object.assign([1, 2, 3], [4, 5])
  // [4, 5, 3]
  ```

- 上面代码中，`Object.assign`把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性`4`覆盖了目标数组的 0 号属性`1`。

**取值函数的处理**

- `Object.assign`只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。

  ```javascript
  const source = {
    get foo() { return 1 }
  };
  const target = {};
  
  Object.assign(target, source)
  // { foo: 1 }
  ```

  上面代码中，`source`对象的`foo`属性是一个**取值函数**，`Object.assign`不会复制这个取值函数，只会拿到值以后，将这个值复制过去。

### 常见用途

**为对象添加属性**

- 通过`Object.assign`方法，将`x`属性和`y`属性添加到`Point`类的对象实例。

  ```javascript
  class Point {
    constructor(x, y) {
      Object.assign(this, {x, y});
    }
  }
  ```

**为对象添加方法**

- 下面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用`assign`方法添加到`SomeClass.prototype`之中。

- ```javascript
  Object.assign(SomeClass.prototype, {
    someMethod(arg1, arg2) {
      ···
    },
    anotherMethod() {
      ···
    }
  });
  
  // 等同于下面的写法
  SomeClass.prototype.someMethod = function (arg1, arg2) {
    ···
  };
  SomeClass.prototype.anotherMethod = function () {
    ···
  };
  ```

**克隆对象**

- ```javascript
  function clone(origin) {
    return Object.assign({}, origin);
  }
  ```

- 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。

- 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。

  ```javascript
  function clone(origin) {
    let originProto = Object.getPrototypeOf(origin);
    return Object.assign(Object.create(originProto), origin);
  }
  ```

**合并多个对象**

- 将多个对象合并到某个对象。

  ```javascript
  const merge =
    (target, ...sources) => Object.assign(target, ...sources);
  ```

- 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。

  ```javascript
  const merge =
    (...sources) => Object.assign({}, ...sources);
  ```

**为属性指定默认值**

- ```javascript
  const DEFAULTS = {
    logLevel: 0,
    outputFormat: 'html'
  };
  
  function processContent(options) {
    options = Object.assign({}, DEFAULTS, options);
    console.log(options);
    // ...
  }
  ```

- 上面代码中，`DEFAULTS`对象是默认值，`options`对象是用户提供的参数。`Object.assign`方法将`DEFAULTS`和`options`合并成一个新对象，如果两者有同名属性，则`option`的属性值会覆盖`DEFAULTS`的属性值。

- 注意，由于存在浅拷贝的问题，`DEFAULTS`对象和`options`对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，`DEFAULTS`对象的该属性很可能不起作用。

  ```javascript
  const DEFAULTS = {
    url: {
      host: 'example.com',
      port: 7070
    },
  };
  
  processContent({ url: {port: 8000} })
  // {
  //   url: {port: 8000}
  // }
  ```

- 上面代码的原意是将`url.port`改成 8000，`url.host`不变。实际结果却是`options.url`覆盖掉`DEFAULTS.url`，所以`url.host`就不存在了。

- 

# 11. 对象属性描述符相关方法

## 基本重要概念

- ECMAScript对象中目前存在的**属性描述符**主要有两种，**数据描述符(数据属性)**和存取描述符**(访问器属性)**，数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。

### 数据(数据描述符)属性

- 数据属性有4个描述内部属性的特性

**[[Configurable]]**

- 表示能否通过**delete**删除此属性，能否修改属性的特性，或能否修改把属性**修改为访问器属性**，如果直接使用**字面量定义对象**，默认值为true
- delete只是不可删除，并不会报错

**[[Enumerable]]**

- 表示该属性是否可枚举，即是否通过**for-in循环或Object.keys()**返回属性，如果直接使用**字面量定义对象**，默认值为true

**[[Writable]]**

- 能否**修改**属性的值，如果直接使用字面量定义对象，默认值为true

**[[Value]]**

- 该属性对应的值，默认为undefined

### 访问器(存取描述符)属性

- 访问器属性也有4个描述内部属性的特性

**[[Configurable]]**

- 和数据属性的[[Configurable]]一样，表示能否通过delete删除此属性，能否修改属性的特性，或能否修改把属性修改为**数据属性**，如果直接使用字面量定义对象，默认值为true

**[[Enumerable]]**

- 和数据属性的[[Configurable]]一样，表示该属性是否可枚举，即是否通过for-in循环或Object.keys()返回属性，如果直接使用字面量定义对象，默认值为true

**[[Get]]**

- 一个给属性提供 **getter 的方法(访问对象属性时调用的函数,返回值就是当前属性的值)**，如果没有 getter 则为 undefined。该方法返**回值被用作属性值**。默认为 undefined

**[[Set]]**

- 一个给属性提供 **setter 的方法(给对象属性设置值时调用的函数)**，如果没有 setter 则为 undefined。该方法将默认接受**唯一参数：属性的新值**。默认为 undefined，如果不在setter内部给属性赋值，属性的值不会改变

**对象内的get和set方法**

- 可以在创建对象字面量的时候直接使用get和set方法：

  1、get与set是方法

  2、get是得到 一般是要返回的   set 是设置 不用返回

  3、如果调用对象内部的属性**约定的命名方式**是_bar  

  ```js
  var myObject = {
    foo: 4,
    _bar:1,
    get bar(){
      return this._bar
    },
    set bar(value) {
      this.foo = value
    }
  }
  console.log(myObject.bar=1,myObject.foo) // 1,1
  // 上面的代码中通过get和set操作符定义了bar属性的setter
  // 如果只有set，则bar属性不可读，因为get默认是undefined，相当于创建了一个只写属性，bar没有真正的值
  // 如果只有get，则bar属性不可写，因为set默认是undefined，相当于创建了一个只读属性，bar不可写
  ```

- **在访问器属性描述符中的[[get]]，[[set]]都是描述符，本质上是调用对象自身的get和set操作符**

### 区别

1. 访问对象的属性是否需要加this
2. getter和setter简写的形式不同
3. 共同点：所有对属性的读写本质上都是通过get和set

+ ```js
  var myObject = {
    foo:1,
    _bar:1,
    get bar(){
      return this._bar // 必须要加this，否则无法访问到外部属性
    },
    set bar(value) {
      this.foo = value
      console.log('set:bar')
    } 
  }
  Object.defineProperty(myObject, 'foo', {
    configurable : true,
    enumerable : true,
    get: function() {
        console.log('get:'+this)
        return foo // foo 可以直接访问，加了this反而报错,加了this 变成了访问foo，又会触发getter
    },
    set: function(newValue) {
        foo = newValue
        console.log('set:'+this)
    }
  })
  myObject.bar = 4
  console.log(myObject.bar,myObject.foo) //1,4
  myObject.foo = 2
  console.log(myObject.bar,myObject.foo) //1,2
  ```

## ES5.1重要扩展

### Object.defineProperty(obj, prop, descriptor)

- 该方法会直接在一个对象上定义**一个新属性**，或者**修改一个对象的现有属性**， 并**返回这个对象**
- 如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined

**参数**

- **obj:** 需要被操作的目标对象

- **prop:** 目标对象需要定义或修改的属性的名称

- **descriptor:** 将被定义或修改的属性的描述符

- ```js
  var obj = new Object();
  
  Object.defineProperty(obj, 'name', {
      configurable: false,
      writable: true,
      enumerable: true,
      value: '张三'
  })
  
  console.log(obj.name)  //张三
  ```

**注意**

- 属性名如果是字符串，必须显式的加上引号，与变量做区分，属性名哪些时候可以省略引号呢？

### Object.defineProperties(object,descriptors)

- 方法直接在一个对象上定义**一个或多个新的属性或修改现有属性，并返回该对象**。

**参数**

- **obj:** 将要被添加属性或修改属性的对象

- **props:** 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置，如果没有设置，则默认为false

- ```js
  var obj = new Object();
  Object.defineProperties(obj, {
      name: {
          value: '张三',
          configurable: false,
          writable: true,
          enumerable: true
      },
      age: {
          value: 18,
          configurable: true
      }
  })
  
  console.log(obj.name, obj.age) // 张三, 18
  ```

### Object.getOwnPropertyDescriptor(obj, prop)

- 该方法返回指定对象上一个**自有属性对应的属性描述符**。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）

**参数**

- **obj:** 需要查找的目标对象

- **prop:** 目标对象内属性名称

- ```js
  var person = {
      name: '张三',
      age: 18
  }
  
  var desc = Object.getOwnPropertyDescriptor(person, 'name'); 
  console.log(desc)  结果如下
  // {
  //     configurable: true,
  //     enumerable: true,
  //     writable: true,
  //     value: "张三"
  // }
  ```

## ES6重要扩展

### Object.getOwnPropertyDescriptors() 

- ES2017 引入了`Object.getOwnPropertyDescriptors()`方法，返回指定对象所有**自身属性**（非继承属性）的**描述对象**。

  ```javascript
  const obj = {
    foo: 123,
    get bar() { return 'abc' }
  };
  
  Object.getOwnPropertyDescriptors(obj)
  // { foo:
  //    { value: 123,
  //      writable: true,
  //      enumerable: true,
  //      configurable: true },
  //   bar:
  //    { get: [Function: get bar],
  //      set: undefined,
  //      enumerable: true,
  //      configurable: true } }
  ```

- 上面代码中，`Object.getOwnPropertyDescriptors()`方法返回一个对象，**所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。**

**polyfill**

- ```javascript
  function getOwnPropertyDescriptors(obj) {
    const result = {};
    for (let key of Reflect.ownKeys(obj)) {
      result[key] = Object.getOwnPropertyDescriptor(obj, key);
    }
    return result;
  }
  ```

### 常见用途

**拷贝**

- 该方法的引入目的，主要是为了解决`Object.assign()`无法正确拷贝`get`属性和`set`属性的问题。

- ```javascript
  const source = {
    set foo(value) {
      console.log(value);
    }
  };
  
  const target1 = {};
  Object.assign(target1, source);
  
  Object.getOwnPropertyDescriptor(target1, 'foo')
  // { value: undefined,
  //   writable: true,
  //   enumerable: true,
  //   configurable: true }
  ```

- 上面代码中，`source`对象的`foo`属性的值是一个赋值函数，`Object.assign`方法将这个属性拷贝给`target1`对象，结果该属性的值变成了`undefined`。这是因为`Object.assign`方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。

- 这时，`Object.getOwnPropertyDescriptors()`方法配合`Object.defineProperties()`方法，就可以实现正确拷贝。

  ```javascript
  const source = {
    set foo(value) {
      console.log(value);
    }
  };
  
  const target2 = {};
  Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
  Object.getOwnPropertyDescriptor(target2, 'foo')
  // { get: undefined,
  //   set: [Function: set foo],
  //   enumerable: true,
  //   configurable: true }
  
  // 合并两个函数
  const shallowMerge = (target, source) => Object.defineProperties(
    target,
    Object.getOwnPropertyDescriptors(source)
  );
  ```

**继承**

- 另外，`Object.getOwnPropertyDescriptors()`方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。

  ```javascript
  const obj = {
    __proto__: prot,
    foo: 123,
  };
  ```

- ES6 规定`__proto__`只有浏览器要部署，其他环境不用部署。如果去除`__proto__`，上面代码就要改成下面这样。

  ```javascript
  const obj = Object.create(prot);
  obj.foo = 123;
  
  // 或者
  
  const obj = Object.assign(
    Object.create(prot),
    {
      foo: 123,
    }
  );
  ```

- 有了`Object.getOwnPropertyDescriptors()`，我们就有了另一种写法。

  ```javascript
  const obj = Object.create(
    prot,
    Object.getOwnPropertyDescriptors({
      foo: 123,
    })
  );
  ```

**混入模式**

- `Object.getOwnPropertyDescriptors()`也可以用来实现 Mixin（混入）模式。

  ```javascript
  let mix = (object) => ({
    with: (...mixins) => mixins.reduce(
      (c, mixin) => Object.create(
        c, Object.getOwnPropertyDescriptors(mixin)
      ), object)
  });
  
  // multiple mixins example
  let a = {a: 'a'};
  let b = {b: 'b'};
  let c = {c: 'c'};
  let d = mix(c).with(a, b);
  
  d.c // "c"
  d.b // "b"
  d.a // "a"
  ```

  上面代码返回一个新的对象`d`，代表了对象`a`和`b`被混入了对象`c`的操作。

  出于完整性的考虑，`Object.getOwnPropertyDescriptors()`进入标准以后，以后还会新增`Reflect.getOwnPropertyDescriptors()`方法。

## 各种场景下描述符属性的的扩展示例讲解

### 在对象中添加数据描述符属性

- 如果设置configurable属性为false，则不可使用delete操作符(在严格模式下抛出错误), 修改所有内部属性值会抛出错误,在《javaScript高级教程中》说只可以改变writable的值，现在改变writable的值也会抛出错误

- ```js
  var person = {};
  
  Object.defineProperty(person, 'name', {
      configurable: false,
      value: 'John'
  }) ;
  
  delete person.name   // 严格模式下抛出错误
  
  console.log(person.name)  // 'John'  没有删除
  
  Object.defineProperty(person, 'name', {
      configurable: true  //报错
  });
  
  Object.defineProperty(person, 'name', {
      enumerable: 2  //报错
  });
  
  Object.defineProperty(person, 'name', {
      writable: true  //报错
  });
  
  Object.defineProperty(person, 'name', {
      value: 2  //报错
  });
  ```

**注意:**

- 以上是最开始定义属性描述符时,**writable默认为false**,才会出现上述效果,如果writable定义为true, 则可以修改[[writable]]和[[value]]属性值,修改另外两个属性值报错

- ```js
  var obj = {};
  
  Object.defineProperty(obj, 'a', {
      configurable: false,
      writable: true,
      value: 1
  });
  
  Object.defineProperty(obj, 'a', {
      // configurable: true, //报错
      // enumerable: true,  //报错
      writable: false,
      value: 2
  });
  var d = Object.getOwnPropertyDescriptor(obj, 'a')
  console.log(d);
  // {
  //     value: 2, 
  //     writable: false, 
  // }
  ```

### 在对象中添加存取描述符属性

- ```js
  var obj = {};
  var aValue; //如果不初始化变量, 不给下面的a属性设置值,直接读取会报错aValue is not defined
  var b;
  Object.defineProperty(obj, 'a', {
      configurable : true,
      enumerable : true,
      get: function() {
          return aValue
      },
      set: function(newValue) {
          aValue = newValue;
          b = newValue + 1
      }
  })
  console.log(b) // undefined
  console.log(obj.a)  // undefined, 当读取属性值时，调用get方法,返回undefined
  obj.a = 2;  // 当设置属性值时,调用set方法,aValue为2
  
  console.log(obj.a) // 2  读取属性值,调用get方法,此时aValue为2
  console.log(b) // 3  再给obj.a赋值时,执行set方法,b的值被修改为2,额外说一句,vue中的计算属性就是利用setter来实现的
  ```

**注意:**

- 1.getter和setter可以不同时使用,但在严格模式下只其中一个,会抛出错误

- 2.数据描述符与存取描述符不可混用,会抛出错误

- ```js
  var obj = {};
  Object.defineProperty(obj, 'a', {
      value: 'a1',
      get: function() {
         return 'a2'
      }    
  });
  // TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute
  ```

### descriptor不同情况下的初始值

- ```js
  var a = 1; // a属于window, 相当于window.a
  
  var d = Object.getOwnPropertyDescriptor(window, 'a');
  console.log(d)
  // {
  //     configurable: false,
  //     value: 1,
  //     writable: true,
  //     enumerable: true
  // }
  
  
  ```

- 在来看一下另一种不适用var声明的方式初始化a变量，相当于声明window的属性，其他对象的属性也是一样

- ```js
  a = 1; //a相当于window的一个属性, window.a
  
  var descriptor = Object.getOwnPropertyDescriptor(window, 'a');
  console.log(descriptor)
  // {
  //     configurable: true,   // 此时configurable属性值为true
  //     value: 1,
  //     writable: true,
  //     enumerable: true
  // }
  ```

- 使用字面量定义的对象,该对象内部的属性的数据描述符属性都为true

- ```js
  var b = {
      name: 'bbb'
  }
  var descriptor = Object.getOwnPropertyDescriptor(b, 'name');
  console.log(descriptor)
  // {
  //     configurable: true
  //     writable: true,
  //     enumerable: true
  //     value: 'bbb'
  // }
  ```

### [[Writable]]

- 当writable为false(并且configurable为true),[[value]]可以通过defineeProperty修改, 但**不能直接赋值修改**

- ```js
  var obj = {};
  
  Object.defineProperty(obj, 'a', {
      configurable: true,
      enumerable: false,
      writable: false,
      value: 1
  });
  
  Object.defineProperty(obj, 'a', {
      configurable: false,
      enumerable: true,
      writable: false ,
      value: 2
  });
  var d = Object.getOwnPropertyDescriptor(obj, 'a')
  
  console.log(d); // 结果如下
  // {
  //     value: 2, 
  //     writable: false, 
  //     enumerable: true, 
  //     configurable: false
  // }
  
  
  // 但是如果直接赋值修改
  var obj = {}
  
  Object.defineProperty(obj, 'a', {
      configurable: true,
      enumerable: false,
      writable: false,
      value: 1
  });
  obj.a=2;
  var d = Object.getOwnPropertyDescriptor(obj, 'a')
  
  console.log(d); // 结果如下
  
  // {
  //     value: 1,  // 没有做出修改，不会报错
  //     writable: false, 
  //     enumerable: true, 
  //     configurable: false
  // }
  ```

### [[Enumerable]]

- ```js
  var obj = {};
  Object.defineProperties(obj, {
      a: {
          value: 1,
          enumerable: false
      }, 
      b: {
          value: 2,
          enumerable: true
      },
      c: {
          value: 3,
          enumerable: false
      }
  })
  
  obj.d = 4;
  
  //等同于
  
  //Object.defineProperty(obj, 'd', {
  //    configurable: true,
  //    enumerable: true,
  //    writable: true,
  //    value: 4
  //})
  
  for(var key in obj) {
      console.log(key);  
      // 打印一次b, 一次d, a和c属性enumerable为false，不可被枚举
  } 
  
  var arr = Object.keys(obj);
  console.log(arr);  // ['b', 'd']
  ```

### get和set实现简单的数据双向绑定

- html

- ```html
  <body>
      <p>
          input1=><input type="text" id="input1">
      </p>
      <p>
          input2=>
          <input type="text" id="input2">
      </p>
      <div>
          我每次比input2的值加1=>
          <span id="span"></span>
      </div>
  </body>
  ```

- js

- ```js
  var oInput1 = document.getElementById('input1');
  var oInput2 = document.getElementById('input2');
  var oSpan = document.getElementById('span');
  var obj = {};
  Object.defineProperties(obj, {
      val1: {
          configurable: true,
          get: function() {
              oInput1.value = 0;
              oInput2.value = 0;
              oSpan.innerHTML = 0;
              return 0 //设置初始显示值
          },
          set: function(newValue) {
              oInput2.value = newValue;
              // 可以访问到val2的值吗？使用this可以读取到
              this.val2 = newValue;
              oSpan.innerHTML = Number(newValue) ? Number(newValue)+1 : 0
          }
      },
      val2: {
          configurable: true,
          get: function() {
              oInput1.value = 0;
              oInput2.value = 0;
              oSpan.innerHTML = 0;
              return 0 //设置初始显示值
          },
          set: function(newValue) {
              oInput1.value = newValue;
              oSpan.innerHTML = Number(newValue)+1;
          }
      }
  })
  // 初始化显示，直接修改input1，input1的setter修改了input2和span
  oInput1.value = obj.val1;
  oInput1.addEventListener('keyup', function() {
      obj.val1 = oInput1.value;
  }, false)
  oInput2.addEventListener('keyup', function() {
      obj.val2 = oInput2.value;
  }, false)
  ```

# 12. 对象的原型相关方法

### `__proto__`属性

- `__proto__`属性（前后各两个下划线），用来读取或设置当前对象的`prototype`对象。目前，所有浏览器（包括 IE11）都部署了这个属性。

- ```javascript
  // es5 的写法
  const obj = {
    method: function() { ... }
  };
  obj.__proto__ = someOtherObj;
  
  // es6 的写法
  var obj = Object.create(someOtherObj);
  obj.method = function() { ... };
  ```

- 该属性没有写入 ES6 的正文，而是写入了附录，原因是`__proto__`前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。
- 因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的`Object.setPrototypeOf()`（写操作）、`Object.getPrototypeOf()`（读操作）、`Object.create()`（生成操作）代替。

**polyfill**

- ```javascript
  Object.defineProperty(Object.prototype, '__proto__', {
    get() {
      let _thisObj = Object(this);
      return Object.getPrototypeOf(_thisObj);
    },
    set(proto) {
      if (this === undefined || this === null) {
        throw new TypeError();
      }
      if (!isObject(this)) {
        return undefined;
      }
      if (!isObject(proto)) {
        return undefined;
      }
      let status = Reflect.setPrototypeOf(this, proto);
      if (!status) {
        throw new TypeError();
      }
    },
  });
  
  function isObject(value) {
    return Object(value) === value;
  }
  ```



## ES5.1重要扩展

### Object.create(proto, [propertiesObject])

- **Object.create()**方法创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`
- 返回一个新对象，带着**指定的原型对象和属性**。

**参数**

- proto：新创建对象的原型对象
- propertiesObject：可选。如果没有指定为 `undefined`，则是要添加到新创建对象的**可枚举属性**（即其自身定义的属性，而不是其原型链上的枚举属性）对象的**属性描述符**以及相应的**属性名称**。这些属性对应`Object.defineProperties()`的**第二个参数**
- 如果`propertiesObject`参数不是 `null` 或一个对象，则抛出一个 `TypeError`异常

**常见用途**

- **创建对象**

- ```js
  var o;
  
  // 创建一个原型为null的空对象
  o = Object.create(null);
  
  
  o = {};
  // 以字面量方式创建的空对象就相当于:
  o = Object.create(Object.prototype);
  
  
  o = Object.create(Object.prototype, {
    // foo会成为所创建对象的数据属性
    foo: { 
      writable:true,
      configurable:true,
      value: "hello" 
    },
    // bar会成为所创建对象的访问器属性
    bar: {
      configurable: false,
      get: function() { return 10 },
      set: function(value) {
        console.log("Setting `o.bar` to", value);
      }
    }
  });
  
  
  function Constructor(){}
  o = new Constructor();
  // 上面的一句就相当于:
  o = Object.create(Constructor.prototype);
  // 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码
  
  
  // 创建一个以另一个空对象为原型,且拥有一个属性p的对象
  o = Object.create({}, { p: { value: 42 } })
  
  // 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:
  o.p = 24
  o.p
  //42
  
  o.q = 12
  for (var prop in o) {
     console.log(prop)
  }
  //"q"
  
  delete o.p
  //false
  
  //创建一个可写的,可枚举的,可配置的属性p
  o2 = Object.create({}, {
    p: {
      value: 42, 
      writable: true,
      enumerable: true,
      configurable: true 
    } 
  });
  ```

- **实现类式继承**

- ```js
  // Shape - 父类(superclass)
  function Shape() {
    this.x = 0;
    this.y = 0;
  }
  
  // 父类的方法
  Shape.prototype.move = function(x, y) {
    this.x += x;
    this.y += y;
    console.info('Shape moved.');
  };
  
  // Rectangle - 子类(subclass)
  function Rectangle() {
    Shape.call(this); // call super constructor.
  }
  
  // 子类续承父类
  Rectangle.prototype = Object.create(Shape.prototype);
  Rectangle.prototype.constructor = Rectangle;
  
  var rect = new Rectangle();
  
  console.log('Is rect an instance of Rectangle?',
    rect instanceof Rectangle); // true
  console.log('Is rect an instance of Shape?',
    rect instanceof Shape); // true
  rect.move(1, 1); // Outputs, 'Shape moved.'
  ```

- 如果你希望能继承到多个对象，则可以使用混入的方式。

- ```js
  function MyClass() {
       SuperClass.call(this);
       OtherSuperClass.call(this);
  }
  
  // 继承一个类
  MyClass.prototype = Object.create(SuperClass.prototype);
  // 混合其它
  Object.assign(MyClass.prototype, OtherSuperClass.prototype);
  // 重新指定constructor
  MyClass.prototype.constructor = MyClass;
  
  MyClass.prototype.myMethod = function() {
       // do a thing
  };
  ```

**polyfill**

- ```js
  if (typeof Object.create !== "function") {
      Object.create = function (proto, propertiesObject) {
          if (typeof proto !== 'object' && typeof proto !== 'function') {
              throw new TypeError('Object prototype may only be an Object: ' + proto);
          } else if (proto === null) {
              throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");
          }
  
          if (typeof propertiesObject != 'undefined') throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");
  
          function F() {}
          F.prototype = proto;
  
          return new F();
      };
  }
  ```

### Object.setPrototypeOf(obj, prototype)

- `Object.setPrototypeOf`方法的作用与`__proto__`相同，用来设置一个对象的`prototype`对象，返回**参数对象本身**。它是 ES6 **正式推荐**的设置原型对象的方法。

- ```javascript
  const o = Object.setPrototypeOf({}, null);
  
  // 相当于
  function setPrototypeOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  ```

**参数**

- 如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。

  ```javascript
  Object.setPrototypeOf(1, {}) === 1 // true
  Object.setPrototypeOf('foo', {}) === 'foo' // true
  Object.setPrototypeOf(true, {}) === true // true
  ```

- 由于`undefined`和`null`无法转为对象，所以如果第一个参数是`undefined`或`null`，就会报错。

  ```javascript
  Object.setPrototypeOf(undefined, {})
  // TypeError: Object.setPrototypeOf called on null or undefined
  
  Object.setPrototypeOf(null, {})
  // TypeError: Object.setPrototypeOf called on null or undefined
  ```

## ES6新增

### Object.getPrototypeOf(object)

- 该方法与`Object.setPrototypeOf`方法配套，用于读取一个对象的原型对象。

  ```javascript
  function Rectangle() {
    // ...
  }
  
  const rec = new Rectangle();
  
  Object.getPrototypeOf(rec) === Rectangle.prototype
  // true
  
  Object.setPrototypeOf(rec, Object.prototype);
  Object.getPrototypeOf(rec) === Rectangle.prototype
  // false
  ```

**参数**

- 如果参数不是对象，会被自动转为对象。

- ```javascript
  // 等同于 Object.getPrototypeOf(Number(1))
  Object.getPrototypeOf(1)
  // Number {[[PrimitiveValue]]: 0}
  
  // 等同于 Object.getPrototypeOf(String('foo'))
  Object.getPrototypeOf('foo')
  // String {length: 0, [[PrimitiveValue]]: ""}
  
  // 等同于 Object.getPrototypeOf(Boolean(true))
  Object.getPrototypeOf(true)
  // Boolean {[[PrimitiveValue]]: false}
  
  Object.getPrototypeOf(1) === Number.prototype // true
  Object.getPrototypeOf('foo') === String.prototype // true
  Object.getPrototypeOf(true) === Boolean.prototype // true
  ```

- 如果参数是`undefined`或`null`，它们无法转为对象，所以会报错。

- ```javascript
  Object.getPrototypeOf(null)
  // TypeError: Cannot convert undefined or null to object
  
  Object.getPrototypeOf(undefined)
  // TypeError: Cannot convert undefined or null to object
  ```

## 性能问题

- 由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 **`[[Prototype]]`**在各个浏览器和 JavaScript 引擎上都是一个**很慢**的操作。

- 其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 `obj.__proto__ = ...` 语句上的时间花费，而且可能会延伸到任何代码，那些可以访问任何**[[Prototype]]**`已被更改的对象的代码。`

- 如果你关心性能，你应该避免设置一个对象的 [[Prototype]]。相反，你应该使用 **Object.create()**来创建带有你想要的[[Prototype]]的新对象。

- ```js
  var MyPrototype = {
      method1 : function(){...},
      method2 : function(){...},
      ...
  };
  
  var newObject = Object.setPrototypeOf({
      property : 1,
      property2 : 'text'                 
  }, MyPrototype);
  
  //性能更高的写法
  var MyPrototype = {
      method1 : function(){...},
      method2 : function(){...},
      ...
  };
  
  var newObject = Object.assign(Object.create(MyPrototype), {
      property : 1,
      property2 : 'text'                 
  });
  ```

# 13. 对象的值相关方法

## ES5.1重要扩展

### Object.keys()

- `Object.keys`方法，返回一个数组，成员是参数**对象自身**的（不含继承的）所有可遍历（enumerable）属性的**键名**。

- ```javascript
  var obj = { foo: 'bar', baz: 42 };
  Object.keys(obj)
  // ["foo", "baz"]
  ```

**参数**

- 如果是一个空对象，则返回一个空数组

## ES6重要扩展

- ES2017 引入了跟`Object.keys`配套的`Object.values`和`Object.entries`，作为遍历一个对象的补充手段，供`for...of`循环使用。

- ```javascript
  let {keys, values, entries} = Object;
  let obj = { a: 1, b: 2, c: 3 };
  
  for (let key of keys(obj)) {
    console.log(key); // 'a', 'b', 'c'
  }
  
  for (let value of values(obj)) {
    console.log(value); // 1, 2, 3
  }
  
  for (let [key, value] of entries(obj)) {
    console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
  }
  ```

### Object.values() 

- `Object.values`方法返回一个数组，成员是参数**对象自身**的（不含继承的）所有可遍历（enumerable）属性的**键值**。

  ```javascript
  const obj = { foo: 'bar', baz: 42 };
  Object.values(obj)
  // ["bar", 42]
  ```

- 返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。

  ```javascript
  const obj = { 100: 'a', 2: 'b', 7: 'c' };
  Object.values(obj)
  // ["b", "c", "a"]
  // 上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。
  ```

- `Object.values`只返回对象自身的可遍历属性。

  ```javascript
  const obj = Object.create({}, {p: {value: 42}});
  Object.values(obj) // []
  ```

- 上面代码中，`Object.create`方法的第二个参数添加的对象属性（属性`p`），如果不显式声明，默认是不可遍历的，因为`p`的属性描述对象的`enumerable`默认是`false`，`Object.values`不会返回这个属性。只要把`enumerable`改成`true`，`Object.values`就会返回属性`p`的值。

  ```javascript
  const obj = Object.create({}, {p:
    {
      value: 42,
      enumerable: true
    }
  });
  Object.values(obj) // [42]
  ```

- `Object.values`会过滤属性名为 Symbol 值的属性。

  ```javascript
  Object.values({ [Symbol()]: 123, foo: 'abc' });
  // ['abc']
  ```

**参数**

- 如果`Object.values`方法的参数是一个字符串，会返回各个字符组成的一个数组。

  ```javascript
  Object.values('foo')
  // ['f', 'o', 'o']
  // 上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，`Object.values`返回每个属性的键值，就是各个字符组成的一个数组。
  ```

- 如果参数是一个空对象，则返回空数组

- 如果参数不是对象，`Object.values`会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，`Object.values`会返回空数组。

  ```javascript
  Object.values(42) // []
  Object.values(true) // []
  ```

### Object.entries()

- `Object.entries()`方法返回一个数组，成员是参数**对象自身**的（不含继承的）所有可遍历（enumerable）属性的**键值对数组**。

  ```javascript
  const obj = { foo: 'bar', baz: 42 };
  Object.entries(obj)
  // [ ["foo", "bar"], ["baz", 42] ]
  ```

- 除了返回值不一样，该方法的行为与`Object.values`基本一致。

- 如果原对象的属性名是一个 Symbol 值，该属性会被忽略。

  ```javascript
  Object.entries({ [Symbol()]: 123, foo: 'abc' });
  // [ [ 'foo', 'abc' ] ]
  ```

- 上面代码中，原对象有两个属性，`Object.entries`只输出属性名非 Symbol 值的属性。将来可能会有`Reflect.ownEntries()`方法，返回对象自身的所有属性。

- `Object.entries`的基本用途是**遍历对象的属性**。

  ```javascript
  let obj = { one: 1, two: 2 };
  for (let [k, v] of Object.entries(obj)) {
    console.log(
      `${JSON.stringify(k)}: ${JSON.stringify(v)}`
    );
  }
  // "one": 1
  // "two": 2
  ```

- `Object.entries`方法的另一个用处是，将对象转为真正的`Map`结构。

  ```javascript
  const obj = { foo: 'bar', baz: 42 };
  const map = new Map(Object.entries(obj));
  map // Map { foo: "bar", baz: 42 }
  ```

**polyfill**

- ```javascript
  // Generator函数的版本
  function* entries(obj) {
    for (let key of Object.keys(obj)) {
      yield [key, obj[key]];
    }
  }
  
  // 非Generator函数的版本
  function entries(obj) {
    let arr = [];
    for (let key of Object.keys(obj)) {
      arr.push([key, obj[key]]);
    }
    return arr;
  }
  ```

### Object.fromEntries()

- `Object.fromEntries()`方法是`Object.entries()`的逆操作，用于将一个键值对数组转为对象。

- ```javascript
  Object.fromEntries([
    ['foo', 'bar'],
    ['baz', 42]
  ])
  // { foo: "bar", baz: 42 }
  ```

- 该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。

- ```javascript
  // 例一
  const entries = new Map([
    ['foo', 'bar'],
    ['baz', 42]
  ]);
  
  Object.fromEntries(entries)
  // { foo: "bar", baz: 42 }
  
  // 例二
  const map = new Map().set('foo', true).set('bar', false);
  Object.fromEntries(map)
  // { foo: true, bar: false }
  ```

- 该方法的一个用处是配合`URLSearchParams`对象，将查询字符串转为对象。

  ```javascript
  Object.fromEntries(new URLSearchParams('foo=bar&baz=qux'))
  // { foo: "bar", baz: "qux" }
  ```

# 14. Symbol

## 概述

- ES5 的对象属性名都是字符串，这容易造成属性名的冲突。

  - 比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。

- 如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。

- ES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是 JavaScript 语言的第七种数据类型

  - 前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。

- Symbol 值通过`Symbol`函数生成。这就是说，对象的**属性名**现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。

  ```javascript
  let s = Symbol();
  
  typeof s
  // "symbol"
  // 上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。
  ```

- **注意**，`Symbol`函数前不能使用`new`命令，否则会报错。这是因为生成的 Symbol 是一个**原始类型的值**，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种**类似于字符串的数据类型**。

**参数**

- `Symbol`函数可以**接受一个字符串作为参数**，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。

  ```javascript
  let s1 = Symbol('foo');
  let s2 = Symbol('bar');
  
  s1 // Symbol(foo)
  s2 // Symbol(bar)
  
  s1.toString() // "Symbol(foo)"
  s2.toString() // "Symbol(bar)"
  // 上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。
  ```

- 如果 Symbol 的参数是一个**对象**，就会调用该对象的`toString`方法，将其转为字符串，然后才生成一个 Symbol 值。

  ```javascript
  const obj = {
    toString() {
      return 'abc';
    }
  };
  const sym = Symbol(obj);
  sym // Symbol(abc)
  ```

- **注意**，`Symbol`函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的`Symbol`函数的返回值是不相等的。

  ```javascript
  // 没有参数的情况
  let s1 = Symbol();
  let s2 = Symbol();
  
  s1 === s2 // false
  
  // 有参数的情况
  let s1 = Symbol('foo');
  let s2 = Symbol('foo');
  
  s1 === s2 // false
  // 上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。
  ```

**注意**

- Symbol 值不能与其他类型的值进行运算，会报错。

  ```javascript
  let sym = Symbol('My symbol');
  
  "your symbol is " + sym
  // TypeError: can't convert symbol to string
  `your symbol is ${sym}`
  // TypeError: can't convert symbol to string
  ```

- 但是，Symbol 值可以**显式**转为字符串。

  ```javascript
  let sym = Symbol('My symbol');
  
  String(sym) // 'Symbol(My symbol)'
  sym.toString() // 'Symbol(My symbol)'
  ```

- 另外，Symbol 值也可以转为**布尔值**，但是**不能转为数值**。

  ```javascript
  let sym = Symbol();
  Boolean(sym) // true
  !sym  // false
  
  if (sym) {
    // ...
  }
  
  Number(sym) // TypeError
  sym + 2 // TypeError
  ```

## 作为属性名的 Symbol

- 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。

  ```javascript
  let mySymbol = Symbol();
  
  // 第一种写法
  let a = {};
  a[mySymbol] = 'Hello!';
  
  // 第二种写法
  let a = {
    [mySymbol]: 'Hello!'
  };
  
  // 第三种写法
  let a = {};
  Object.defineProperty(a, mySymbol, { value: 'Hello!' });
  
  // 以上写法都得到同样结果
  a[mySymbol] // "Hello!"
  
  // 上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。
  ```

- **注意**，Symbol 值作为对象属性名时，**不能用点运算符**。因为点运算符后面总是字符串，所以不会读取`mySymbol`作为标识名所指代的那个值，导致`a`的属性名**实际上是一个字符串**，而不是一个 Symbol 值。

  ```javascript
  const mySymbol = Symbol();
  const a = {};
  
  a.mySymbol = 'Hello!';
  a[mySymbol] // undefined
  a['mySymbol'] // "Hello!"
  // 变量mySymbol被转换为字符串
  ```

- 同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。

  ```javascript
  let s = Symbol();
  
  let obj = {
    [s]: function (arg) { ... }
  };
  
  obj[s](123);
  // 上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个 Symbol 值。
  ```

**用途**

- Symbol 类型还可以用于**定义一组常量**，保证这组常量的值都是不相等的。常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证`switch`语句会按设计的方式工作。

  ```javascript
  const log = {};
  
  log.levels = {
    DEBUG: Symbol('debug'),
    INFO: Symbol('info'),
    WARN: Symbol('warn')
  };
  console.log(log.levels.DEBUG, 'debug message');
  console.log(log.levels.INFO, 'info message');
  
  // 另一个例子
  const COLOR_RED    = Symbol();
  const COLOR_GREEN  = Symbol();
  
  function getComplement(color) {
    switch (color) {
      case COLOR_RED:
        return COLOR_GREEN;
      case COLOR_GREEN:
        return COLOR_RED;
      default:
        throw new Error('Undefined color');
      }
  }
  ```

### 实例：消除魔术字符串

- 魔术字符串指的是，在代码之中多次出现、与代码形成**强耦合**的某一个具体的**字符串或者数值**。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。

  ```javascript
  function getArea(shape, options) {
    let area = 0;
  
    switch (shape) {
      case 'Triangle': // 魔术字符串
        area = .5 * options.width * options.height;
        break;
      /* ... more code ... */
    }
  
    return area;
  }
  
  getArea('Triangle', { width: 100, height: 100 }); // 魔术字符串
  
  // 上面代码中，字符串Triangle就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。
  ```

- 常用的消除魔术字符串的方法，就是把它写成一个变量。

  ```javascript
  const shapeType = {
    triangle: 'Triangle'
  };
  
  function getArea(shape, options) {
    let area = 0;
    switch (shape) {
      case shapeType.triangle:
        area = .5 * options.width * options.height;
        break;
    }
    return area;
  }
  
  getArea(shapeType.triangle, { width: 100, height: 100 });
  
  // 上面代码中，我们把Triangle写成shapeType对象的triangle属性，这样就消除了强耦合。
  ```

- 如果仔细分析，可以发现`shapeType.triangle`等于哪个值并不重要，只要确保不会跟其他`shapeType`属性的值冲突即可。因此，这里就很适合改用 Symbol 值。

  ```javascript
  const shapeType = {
    triangle: Symbol()
  };
  // 上面代码中，除了将shapeType.triangle的值设为一个 Symbol，其他地方都不用修改。
  ```

### 属性名的遍历

- Symbol 作为属性名，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。
- 但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols`方法，可以获取指定对象的所有 Symbol 属性名。

- `Object.getOwnPropertySymbols`方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。

  ```javascript
  const obj = {};
  let a = Symbol('a');
  let b = Symbol('b');
  
  obj[a] = 'Hello';
  obj[b] = 'World';
  
  const objectSymbols = Object.getOwnPropertySymbols(obj);
  
  objectSymbols
  // [Symbol(a), Symbol(b)]
  ```

- 下面是另一个例子，`Object.getOwnPropertySymbols`方法与`for...in`循环、`Object.getOwnPropertyNames`方法进行对比的例子。

  ```javascript
  const obj = {};
  
  let foo = Symbol("foo");
  
  Object.defineProperty(obj, foo, {
    value: "foobar",
  });
  
  for (let i in obj) {
    console.log(i); // 无输出
  }
  
  Object.getOwnPropertyNames(obj)
  // []
  
  Object.getOwnPropertySymbols(obj)
  // [Symbol(foo)]
  
  // 上面代码中，使用Object.getOwnPropertyNames方法得不到Symbol属性名，需要使用Object.getOwnPropertySymbols方法。
  ```

- 另一个新的 API，`Reflect.ownKeys`方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。

  ```javascript
  let obj = {
    [Symbol('my_key')]: 1,
    enum: 2,
    nonEnum: 3
  };
  
  Reflect.ownKeys(obj)
  //  ["enum", "nonEnum", Symbol(my_key)]
  ```

- 由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些**非私有的**、但又希望**只用于内部**的方法。

  ```javascript
  let size = Symbol('size');
  
  class Collection {
    constructor() {
      this[size] = 0;
    }
  
    add(item) {
      this[this[size]] = item;
      this[size]++;
    }
  
    static sizeOf(instance) {
      return instance[size];
    }
  }
  
  let x = new Collection();
  Collection.sizeOf(x) // 0
  
  x.add('foo'); x.add('foo'); // 为x添加了一个'0'属性
  Collection.sizeOf(x) // 1
  
  Object.keys(x) // ['0']
  Object.getOwnPropertyNames(x) // ['0']
  Object.getOwnPropertySymbols(x) // [Symbol(size)]
  ```

- 上面代码中，对象`x`的`size`属性是一个 Symbol 值，所以`Object.keys(x)`、`Object.getOwnPropertyNames(x)`都无法获取它。这就造成了一种非私有的内部方法的效果。

## Symbol.for()，Symbol.keyFor() 

- 有时，我们希望重新使用同一个 Symbol 值，`Symbol.for`方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。

  ```javascript
  let s0 = Symbol('foo')
  let s1 = Symbol.for('foo');
  let s2 = Symbol.for('foo');
  
  s0 === s1 // false
  s1 === s2 // true
  
  // 上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。
  ```

- `Symbol.for()`与`Symbol()`这两种写法，都会生成新的 Symbol。它们的区别是，前者会被**登记**在全局环境中供搜索，后者不会。`Symbol.for()`不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的`key`是否已经存在，如果不存在才会新建一个值。

- 比如，如果你调用`Symbol.for("cat")`30 次，每次都会返回同一个 Symbol 值，但是调用`Symbol("cat")`30 次，会返回 30 个不同的 Symbol 值。

  ```javascript
  Symbol.for("bar") === Symbol.for("bar")
  // true
  
  Symbol("bar") === Symbol("bar")
  // false
  // 上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。
  ```

- **参数**：如果没有传入字符串，则会自动传入'undefined'

- ```js
  let s1 = Symbol.for();
  let s2 = Symbol.for();
  
  s1 === s2 // true
  Symbol.keyFor(s1) // 'undefined'
  typeof Symbol.keyFor(s1) // string
  typeof undefined // undefined
  ```

- `Symbol.keyFor`方法返回一个**已登记**的 Symbol 类型值的`key`。

  ```javascript
  let s1 = Symbol.for("foo");
  Symbol.keyFor(s1) // "foo"
  
  let s2 = Symbol("foo");
  Symbol.keyFor(s2) // undefined
  typeof Symbol.keyFor(s2) // undefined
  // 上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。
  ```

- 需要注意的是，`Symbol.for`为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。

  ```javascript
  iframe = document.createElement('iframe');
  iframe.src = String(window.location);
  document.body.appendChild(iframe);
  
  iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo')
  // true，上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。
  ```

## 实例：模块的 Singleton 模式

- Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。
- 对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？

- 很容易想到，可以把实例放到顶层对象`global`。

  ```javascript
  // mod.js
  function A() {
    this.foo = 'hello';
  }
  
  if (!global._foo) {
    global._foo = new A();
  }
  
  module.exports = global._foo;
  ```

- 然后，加载上面的`mod.js`。

  ```javascript
  const a = require('./mod.js');
  console.log(a.foo); // hellow
  ```

- 上面代码中，变量`a`任何时候加载的都是`A`的同一个实例。

- 但是，这里有一个问题，全局变量`global._foo`是可写的，任何文件都可以修改。

  ```javascript
  global._foo = { foo: 'world' };
  
  const a = require('./mod.js');
  console.log(a.foo);
  ```

- 上面的代码，会使得加载`mod.js`的脚本都失真。

- 为了防止这种情况出现，我们就可以使用 Symbol。

  ```javascript
  // mod.js
  const FOO_KEY = Symbol.for('foo');
  
  function A() {
    this.foo = 'hello';
  }
  
  if (!global[FOO_KEY]) {
    global[FOO_KEY] = new A();
  }
  
  module.exports = global[FOO_KEY];
  ```

- 上面代码中，可以保证`global[FOO_KEY]`不会被无意间覆盖，但还是**可以被改写**。

  ```javascript
  global[Symbol.for('foo')] = { foo: 'world' };
  
  const a = require('./mod.js');
  ```

- 如果键名使用`Symbol`方法生成，那么外部将无法引用这个值，当然也就无法改写。

- 

  ```javascript
  // mod.js
  const FOO_KEY = Symbol('foo');
  
  // 后面代码相同 ……
  ```

- 上面代码将导致其他脚本都无法引用`FOO_KEY`。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的`FOO_KEY`都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。

- 还是使用`Symbol.for('foo')`

## 内置的 Symbol 值

- 除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值
- 这些内置 Symbol 值被 JavaScript **内建算法**所使用。例如 `Symbol.iterator` 被用来迭代遍历数组项或字符串，甚至定义自己的迭代器函数。
- 这些特殊的 Symbol 值非常重要，因为它们是对象的**系统属性**，这些属性允许你定义**定制的行为**。听起来不错吧，用它们来打入 JavaScript 内部！

### Symbol.hasInstance

- 对象的`Symbol.hasInstance`属性，指向一个内部方法。当其他对象使用`instanceof`**运算符**，判断是否为该对象的实例时，会调用这个方法。比如，`foo instanceof Foo`在语言内部，实际调用的是`Foo[Symbol.hasInstance](foo)`。

  ```javascript
  class MyClass {
    [Symbol.hasInstance](foo) {
      return foo instanceof Array;
    }
  }
  
  [1, 2, 3] instanceof new MyClass() // true
  ```

- 上面代码中，`MyClass`是一个类，`new MyClass()`会返回一个实例。该实例的`Symbol.hasInstance`方法，会在进行`instanceof`运算时自动调用，判断左侧的运算子是否为`Array`的实例。

- 下面是另一个例子，**定制了通俗的类行为**

  ```javascript
  class Even {
    static [Symbol.hasInstance](obj) {
      return Number(obj) % 2 === 0;
    }
  }
  
  // 等同于
  const Even = {
    [Symbol.hasInstance](obj) {
      return Number(obj) % 2 === 0;
    }
  };
  
  1 instanceof Even // false
  2 instanceof Even // true
  12345 instanceof Even // false
  ```

### Symbol.isConcatSpreadable

- 对象的`Symbol.isConcatSpreadable`属性等于一个**布尔值**，表示该对象用于`Array.prototype.concat()`时，是否展开。

  ```javascript
  let arr1 = ['c', 'd'];
  ['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']
  arr1[Symbol.isConcatSpreadable] // undefined
  
  let arr2 = ['c', 'd'];
  arr2[Symbol.isConcatSpreadable] = false;
  ['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']
  ```

- 上面代码说明，数组的默认行为是**展开**，`Symbol.isConcatSpreadable`默认等于`undefined`。该属性等于`true`时，也有展开的效果。

- **类似数组**的对象正好相反，默认**不展开**。它的`Symbol.isConcatSpreadable`属性设为`true`，才可以展开。

  ```javascript
  let obj = {length: 2, 0: 'c', 1: 'd'};
  ['a', 'b'].concat(obj, 'e') // ['a', 'b', obj, 'e']
  
  obj[Symbol.isConcatSpreadable] = true;
  ['a', 'b'].concat(obj, 'e') // ['a', 'b', 'c', 'd', 'e']
  ```

- `Symbol.isConcatSpreadable`属性也可以定义在类里面。

  ```javascript
  class A1 extends Array {
    constructor(args) {
      super(args);
      this[Symbol.isConcatSpreadable] = true;
    }
  }
  class A2 extends Array {
    constructor(args) {
      super(args);
    }
    get [Symbol.isConcatSpreadable] () {
      return false;
    }
  }
  let a1 = new A1();
  a1[0] = 3;
  a1[1] = 4;
  let a2 = new A2();
  a2[0] = 5;
  a2[1] = 6;
  [1, 2].concat(a1).concat(a2)
  // [1, 2, 3, 4, [5, 6]]
  ```

- 上面代码中，类`A1`是可展开的，类`A2`是不可展开的，所以使用`concat`时有不一样的结果。

- 注意，`Symbol.isConcatSpreadable`的位置差异，`A1`是定义在实例上，`A2`是定义在类本身，效果相同。

### Symbol.species

### Symbol.match

### Symbol.replace

### Symbol.search

### Symbol.split

### Symbol.iterator 

### Symbol.toPrimitive

### Symbol.toStringTag

### Symbol.unscopables

- > https://juejin.im/entry/57bd14961532bc006583d805

# 15. Set 和 Map 数据结构

## Set

### 基本用法

- ES6 提供了新的数据结构 Set。它**类似于数组**，但是成员的值都是**唯一**的，没有重复的值。

+ `Set`本身是一个**构造函数**，用来生成 Set 数据结构。

  ```javascript
  const s = new Set();
  
  [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
  
  for (let i of s) {
    console.log(i);
  }
  // 2 3 5 4
  // 上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。
  ```

- `Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来**初始化**。

  ```javascript
  // 例一
  const set = new Set([1, 2, 3, 4, 4]);
  [...set]
  // [1, 2, 3, 4]
  
  // 例二
  const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
  items.size // 5
  
  // 例三
  const set = new Set(document.querySelectorAll('div'));
  set.size // 56
  
  // 类似于
  const set = new Set();
  document
   .querySelectorAll('div')
   .forEach(div => set.add(div));
  set.size // 56
  
  // 上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。
  ```

- 上面代码也展示了一种**去除数组重复成员**的方法。

  ```javascript
  // 去除数组的重复成员
  [...new Set(array)]
  ```

+ 上面的方法也可以用于，去除字符串里面的**重复字符**。

  ```javascript
  [...new Set('ababbc')].join('')
  // "abc"
  ```

- 向 Set 加入值的时候，**不会发生类型转换**，所以`5`和`"5"`是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（`===`），主要的区别是`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。

  ```javascript
  let set = new Set();
  let a = NaN;
  let b = NaN;
  set.add(a);
  set.add(b);
  set // Set {NaN}
  
  // 上面代码向 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等。
  ```

+ 另外，两个对象总是不相等的。

  ```javascript
  let set = new Set();
  
  set.add({});
  set.size // 1
  
  set.add({});
  set.size // 2
  
  // 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。
  ```

### Set 实例的属性和方法

Set 结构的实例有以下属性：

- `Set.prototype.constructor`：构造函数，默认就是`Set`函数。
- `Set.prototype.size`：返回`Set`实例的成员总数。

- Set 实例的方法分为两大类：**操作方法**（用于操作数据）和**遍历方法**（用于遍历成员）。

四个**操作方法**

- `add(value)`：添加某个值，返回 Set 结构本身。

- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。

  - 如果没有这个值，也就无法删除了

- `has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。

- `clear()`：清除所有成员，没有返回值。

- 上面这些属性和方法的实例如下。

  ```javascript
  s.add(1).add(2).add(2);
  // 注意2被加入了两次
  
  s.size // 2
  
  s.has(1) // true
  s.has(2) // true
  s.has(3) // false
  
  s.delete(2);
  s.has(2) // false
  ```

- 下面是一个对比，看看在判断是否包括一个键上面，`Object`结构和`Set`结构的写法不同。

  ```javascript
  // 对象的写法
  const properties = {
    'width': 1,
    'height': 1
  };
  
  if (properties[someName]) {
    // do something
  }
  
  // Set的写法
  const properties = new Set();
  
  properties.add('width');
  properties.add('height');
  
  if (properties.has(someName)) {
    // do something
  }
  ```

- `Array.from`方法可以将 Set 结构转为数组。

  ```javascript
  const items = new Set([1, 2, 3, 4, 5]);
  const array = Array.from(items);
  ```

- 这就提供了去除数组重复成员的另一种方法。

  ```javascript
  function dedupe(array) {
    return Array.from(new Set(array));
  }
  
  dedupe([1, 1, 2, 3]) // [1, 2, 3]
  ```

**四个遍历方法**

- `keys()`：返回键名的遍历器
- `values()`：返回键值的遍历器
- `entries()`：返回键值对的遍历器
- `forEach()`：使用回调函数遍历每个成员

- 需要特别指出的是，`Set`的**遍历顺序就是插入顺序**。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。

- `keys`方法、`values`方法、`entries`方法返回的都是**遍历器对象**（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说**键名和键值是同一个值**），所以`keys`方法和`values`方法的行为完全一致。

  ```javascript
  let set = new Set(['red', 'green', 'blue']);
  
  for (let item of set.keys()) {
    console.log(item);
  }
  // red
  // green
  // blue
  
  for (let item of set.values()) {
    console.log(item);
  }
  // red
  // green
  // blue
  
  for (let item of set.entries()) {
    console.log(item);
  }
  // ["red", "red"]
  // ["green", "green"]
  // ["blue", "blue"]
  // 上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。
  ```

+ Set 结构的实例默认可遍历，它的**默认遍历器生成函数**就是它的`values`方法。

  ```javascript
  Set.prototype[Symbol.iterator] === Set.prototype.values
  // true
  ```

+ 这意味着，可以省略`values`方法，直接用`for...of`循环遍历 Set。

  ```javascript
  let set = new Set(['red', 'green', 'blue']);
  
  for (let x of set) {
    console.log(x);
  }
  // red
  // green
  // blue
  ```

**foreach**

+ Set 结构的实例与数组一样，也拥有`forEach`方法，用于对每个成员执行某种操作，没有返回值。

  ```javascript
  let set = new Set([1, 4, 9]);
  set.forEach((value, key) => console.log(key + ' : ' + value))
  // 1 : 1
  // 4 : 4
  // 9 : 9
  ```

+ 上面代码说明，`forEach`方法的参数就是一个处理函数。该函数的**参数**与数组的`forEach`一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。

+ 另外，`forEach`方法还可以有第二个参数，表示绑定处理函数内部的`this`对象。

### 遍历的应用

+ 扩展运算符（`...`）内部使用`for...of`循环，所以也可以用于 Set 结构。

  ```javascript
  let set = new Set(['red', 'green', 'blue']);
  let arr = [...set];
  // ['red', 'green', 'blue']
  ```

+ 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。

  ```javascript
  let arr = [3, 5, 2, 2, 5, 5];
  let unique = [...new Set(arr)];
  // [3, 5, 2]
  ```

+ 而且，数组的`map`和`filter`方法也可以间接用于 Set 了。

  ```javascript
  let set = new Set([1, 2, 3]);
  set = new Set([...set].map(x => x * 2));
  // 返回Set结构：{2, 4, 6}
  
  let set = new Set([1, 2, 3, 4, 5]);
  set = new Set([...set].filter(x => (x % 2) == 0));
  // 返回Set结构：{2, 4}
  ```

+ 因此使用 Set 可以很容易地实现**并集（Union）**、**交集（Intersect）**和**差集（Difference）**。

  ```javascript
  let a = new Set([1, 2, 3]);
  let b = new Set([4, 3, 2]);
  
  // 并集，两个集合去重
  let union = new Set([...a, ...b]);
  // Set {1, 2, 3, 4}
  
  // 交集
  let intersect = new Set([...a].filter(x => b.has(x)));
  // set {2, 3}
  
  // 差集
  let difference = new Set([...a].filter(x => !b.has(x)));
  // Set {1}
  ```

+ 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用`Array.from`方法。

  ```javascript
  // 方法一
  let set = new Set([1, 2, 3]);
  set = new Set([...set].map(val => val * 2));
  // set的值是2, 4, 6
  
  // 方法二
  let set = new Set([1, 2, 3]);
  set = new Set(Array.from(set, val => val * 2));
  // set的值是2, 4, 6
  ```

+ 上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。

## WeakSet

### 含义

+ WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

+ 首先，WeakSet 的成员只能是**对象**，而不能是其他类型的值。

+ ```javascript
  const ws = new WeakSet();
  ws.add(1)
  // TypeError: Invalid value used in weak set
  ws.add(Symbol())
  // TypeError: invalid value used in weak set
  ```

+ 上面代码试图向 WeakSet 添加一个数值和`Symbol`值，结果报错，因为 WeakSet 只能放置对象。

+ 其次，WeakSet 中的对象都是**弱引用**，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

+ 这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为`0`，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。
+ 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。
+ 这些特点同样适用于本章后面要介绍的 WeakMap 结构。

### 语法

+ WeakSet 是一个构造函数，可以使用`new`命令，创建 WeakSet 数据结构。

  ```javascript
  const ws = new WeakSet();
  ```

+ 作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。

+ ```javascript
  const a = [[1, 2], [3, 4]];
  const ws = new WeakSet(a);
  // WeakSet {[1, 2], [3, 4]}
  // 上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为 WeakSet 构造函数的参数，a的成员会自动成为 WeakSet 的成员。
  ```

+ 注意，是`a`数组的成员成为 WeakSet 的成员，而不是`a`数组本身。这意味着，**数组的成员只能是对象**。

  ```javascript
  const b = [3, 4];
  const ws = new WeakSet(b);
  // Uncaught TypeError: Invalid value used in weak set(…)
  ```

### WeakSet 结构的三个方法。

- **WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。

- **WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。

- **WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。

  ```javascript
  const ws = new WeakSet();
  const obj = {};
  const foo = {};
  
  ws.add(window);
  ws.add(obj);
  
  ws.has(window); // true
  ws.has(foo);    // false
  
  ws.delete(window);
  ws.has(window);    // false
  ```

+ WeakSet 没有`size`属性，没有办法遍历它的成员。

  ```javascript
  ws.size // undefined
  ws.forEach // undefined
  
  ws.forEach(function(item){ console.log('WeakSet has ' + item)})
  // TypeError: undefined is not a function
  ```

+ 上面代码试图获取`size`和`forEach`属性，结果都不能成功。

+ WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是**储存 DOM 节点**，而不用担心这些节点从文档移除时，会引发内存泄漏。

+ 下面是 WeakSet 的另一个例子。

  ```javascript
  const foos = new WeakSet()
  class Foo {
    constructor() {
      foos.add(this)
    }
    method () {
      if (!foos.has(this)) {
        throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');
      }
    }
  }
  ```

+ 上面代码保证了`Foo`的实例方法，只能在`Foo`的实例上调用。这里使用 WeakSet 的好处是，`foos`对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑`foos`，也不会出现内存泄漏。

## Map

### 含义和基本用法

+ JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。

  ```javascript
  const data = {};
  const element = document.getElementById('myDiv');
  
  data[element] = 'metadata';
  data['[object HTMLDivElement]'] // "metadata"
  ```

+ 上面代码原意是将一个 DOM 节点作为对象`data`的键，但是由于对象只接受字符串作为键名，所以`element`被自动转为字符串`[object HTMLDivElement]`。

+ 为了解决这个问题，ES6 提供了 Map 数据结构。它**类似于对象**，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

  ```javascript
  const m = new Map();
  const o = {p: 'Hello World'};
  
  m.set(o, 'content')
  m.get(o) // "content"
  
  m.has(o) // true
  m.delete(o) // true
  m.has(o) // false
  ```

+ 上面代码使用 Map 结构的`set`方法，将对象`o`当作`m`的一个键，然后又使用`get`方法读取这个键，接着使用`delete`方法删除了这个键。

+ 上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该**数组的成员是一个个表示键值对的数组**。

  ```javascript
  const map = new Map([
    ['name', '张三'],
    ['title', 'Author']
  ]);
  
  map.size // 2
  map.has('name') // true
  map.get('name') // "张三"
  map.has('title') // true
  map.get('title') // "Author"
  
  // 上面代码在新建 Map 实例时，就指定了两个键name和title。
  ```

+ `Map`构造函数接受数组作为参数，实际上执行的是下面的算法。

  ```javascript
  const items = [
    ['name', '张三'],
    ['title', 'Author']
  ];
  
  const map = new Map();
  
  items.forEach(
    ([key, value]) => map.set(key, value)
  );
  ```

+ 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个**双元素的数组的数据结构**（详见《Iterator》一章）都可以当作`Map`构造函数的参数。这就是说，`Set`和`Map`都可以用来生成新的 Map。

  ```javascript
  const set = new Set([
    ['foo', 1],
    ['bar', 2]
  ]);
  const m1 = new Map(set);
  m1.get('foo') // 1
  
  const m2 = new Map([['baz', 3]]);
  const m3 = new Map(m2);
  m3.get('baz') // 3
  
  // 上面代码中，我们分别使用 Set 对象和 Map 对象，当作Map构造函数的参数，结果都生成了新的 Map 对象。
  ```

+ 如果对同一个键多次赋值，后面的值将覆盖前面的值。

  ```javascript
  const map = new Map();
  
  map
  .set(1, 'aaa')
  .set(1, 'bbb');
  
  map.get(1) // "bbb"
  ```

+ 如果读取一个未知的键，则返回`undefined`。

  ```javascript
  new Map().get('asfddfsasadf')
  // undefined
  ```

+ 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。

  ```javascript
  const map = new Map();
  
  map.set(['a'], 555);
  map.get(['a']) // undefined
  
  // 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。
  ```

+ 同理，同样的值的两个实例，在 Map 结构中被视为两个键。

  ```javascript
  const map = new Map();
  
  const k1 = ['a'];
  const k2 = ['a'];
  
  map
  .set(k1, 111)
  .set(k2, 222);
  
  map.get(k1) // 111
  map.get(k2) // 222
  // 上面代码中，变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键。
  ```

+ 由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。

  + Symbol也可以解决同样的问题

+ 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值**严格相等**，Map 将其视为一个键，比如`0`和`-0`就是一个键，布尔值`true`和字符串`true`则是两个不同的键。另外，`undefined`和`null`也是两个不同的键。虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键。

  + ===的规则，加上NaN的规则，但是没有+0 -0的规则，或者是Object.is()规则，没有00

+ ```javascript
  let map = new Map();
  
  map.set(-0, 123);
  map.get(+0) // 123
  
  map.set(true, 1);
  map.set('true', 2);
  map.get(true) // 1
  
  map.set(undefined, 3);
  map.set(null, 4);
  map.get(undefined) // 3
  
  map.set(NaN, 123);
  map.get(NaN) // 123
  ```

### 实例的属性和操作方法

**size 属性**

+ `size`属性返回 Map 结构的成员总数。

  ```javascript
  const map = new Map();
  map.set('foo', true);
  map.set('bar', false);
  
  map.size // 2
  ```

**set(key, value)**

+ `set`方法设置键名`key`对应的键值为`value`，然后返回**整个 Map 结构**。如果`key`已经有值，则键值会被更新，否则就新生成该键。

  ```javascript
  const m = new Map();
  
  m.set('edition', 6)        // 键是字符串
  m.set(262, 'standard')     // 键是数值
  m.set(undefined, 'nah')    // 键是 undefined
  ```

+ `set`方法返回的是当前的`Map`对象，因此可以采用链式写法。

  ```javascript
  let map = new Map()
    .set(1, 'a')
    .set(2, 'b')
    .set(3, 'c');
  ```

**get(key)**

+ `get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

  ```javascript
  const m = new Map();
  
  const hello = function() {console.log('hello');};
  m.set(hello, 'Hello ES6!') // 键是函数
  
  m.get(hello)  // Hello ES6!
  ```

**has(key)**

+ `has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

  ```javascript
  const m = new Map();
  
  m.set('edition', 6);
  m.set(262, 'standard');
  m.set(undefined, 'nah');
  
  m.has('edition')     // true
  m.has('years')       // false
  m.has(262)           // true
  m.has(undefined)     // true
  ```

**delete(key)**

+ `delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

  ```javascript
  const m = new Map();
  m.set(undefined, 'nah');
  m.has(undefined)     // true
  
  m.delete(undefined)
  m.has(undefined)       // false
  ```

**clear()**

+ `clear`方法清除所有成员，没有返回值。

  ```javascript
  let map = new Map();
  map.set('foo', true);
  map.set('bar', false);
  
  map.size // 2
  map.clear()
  map.size // 0
  ```

### 遍历方法

Map 结构原生提供三个**遍历器生成函数**和一个**遍历方法**。

- `keys()`：返回键名的遍历器。
- `values()`：返回键值的遍历器。
- `entries()`：返回所有成员的遍历器。
- `forEach()`：遍历 Map 的所有成员。

+ 需要特别注意的是，Map 的**遍历顺序就是插入顺序**。

  ```javascript
  const map = new Map([
    ['F', 'no'],
    ['T',  'yes'],
  ]);
  
  for (let key of map.keys()) {
    console.log(key);
  }
  // "F"
  // "T"
  
  for (let value of map.values()) {
    console.log(value);
  }
  // "no"
  // "yes"
  
  for (let item of map.entries()) {
    console.log(item[0], item[1]);
  }
  // "F" "no"
  // "T" "yes"
  
  // 或者
  for (let [key, value] of map.entries()) {
    console.log(key, value);
  }
  // "F" "no"
  // "T" "yes"
  
  // 等同于使用map.entries()
  for (let [key, value] of map) {
    console.log(key, value);
  }
  // "F" "no"
  // "T" "yes"
  ```

+ 上面代码最后的那个例子，表示 Map 结构的**默认遍历器接口（`Symbol.iterator`属性），就是`entries`方法**，所以后三者的表现才会如此类似

  ```javascript
  map[Symbol.iterator] === map.entries
  // true
  ```

+ Map 结构转为数组结构，比较快速的方法是使用扩展运算符（`...`）。

  ```javascript
  const map = new Map([
    [1, 'one'],
    [2, 'two'],
    [3, 'three'],
  ]);
  
  [...map.keys()]
  // [1, 2, 3]
  
  [...map.values()]
  // ['one', 'two', 'three']
  
  [...map.entries()]
  // [[1,'one'], [2, 'two'], [3, 'three']]
  
  [...map]
  // [[1,'one'], [2, 'two'], [3, 'three']]
  ```

+ 结合数组的`map`方法、`filter`方法，可以实现 Map 的遍历和过滤（Map 本身没有`map`和`filter`方法）。

  ```javascript
  const map0 = new Map()
    .set(1, 'a')
    .set(2, 'b')
    .set(3, 'c');
  
  const map1 = new Map(
    [...map0].filter(([k, v]) => k < 3)
  );
  // 产生 Map 结构 {1 => 'a', 2 => 'b'}
  
  const map2 = new Map(
    [...map0].map(([k, v]) => [k * 2, '_' + v])
      );
  // 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}
  ```

+ 此外，Map 还有一个`forEach`方法，与数组的`forEach`方法类似，也可以实现遍历。

  ```javascript
  map.forEach(function(value, key, map) {
    console.log("Key: %s, Value: %s", key, value);
  });
  ```

+ `forEach`方法还可以接受第二个参数，用来绑定`this`。

  ```javascript
  const reporter = {
    report: function(key, value) {
      console.log("Key: %s, Value: %s", key, value);
    }
  };
  
  map.forEach(function(value, key, map) {
    this.report(key, value);
  }, reporter);
  ```

+ 上面代码中，`forEach`方法的回调函数的`this`，就指向`reporter`。

### 与其他数据结构的互相转换

**Map 转为数组**

+ Map 转为数组最方便的方法，就是使用扩展运算符（`...`）。

  ```javascript
  const myMap = new Map()
    .set(true, 7)
    .set({foo: 3}, ['abc']);
  [...myMap]
  // [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
  ```

**数组 转为 Map**

+ 将数组传入 Map 构造函数，就可以转为 Map。

  ```javascript
  new Map([
    [true, 7],
    [{foo: 3}, ['abc']]
  ])
  // Map {
  //   true => 7,
  //   Object {foo: 3} => ['abc']
  // }
  ```

**Map 转为对象**

+ 如果所有 Map 的键都是字符串，它可以无损地转为对象。

  ```javascript
  function strMapToObj(strMap) {
    let obj = Object.create(null);
    for (let [k,v] of strMap) {
      obj[k] = v;
    }
    return obj;
  }
  
  const myMap = new Map()
    .set('yes', true)
    .set('no', false);
  strMapToObj(myMap)
  // { yes: true, no: false }
  ```

+ 如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。

**对象转为 Map**

+ ```javascript
  function objToStrMap(obj) {
    let strMap = new Map();
    for (let k of Object.keys(obj)) {
      strMap.set(k, obj[k]);
    }
    return strMap;
  }
  
  objToStrMap({yes: true, no: false})
  // Map {"yes" => true, "no" => false}
  ```

**Map 转为 JSON**

+ Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。

  ```javascript
  function strMapToJson(strMap) {
    return JSON.stringify(strMapToObj(strMap));
  }
  
  let myMap = new Map().set('yes', true).set('no', false);
  strMapToJson(myMap)
  // '{"yes":true,"no":false}'
  ```

+ 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。

  ```javascript
  function mapToArrayJson(map) {
    return JSON.stringify([...map]);
  }
  
  let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
  mapToArrayJson(myMap)
  // '[[true,7],[{"foo":3},["abc"]]]'
  ```

**JSON 转为 Map**

+ JSON 转为 Map，正常情况下，所有键名都是字符串。

  ```javascript
  function jsonToStrMap(jsonStr) {
    return objToStrMap(JSON.parse(jsonStr));
  }
  
  jsonToStrMap('{"yes": true, "no": false}')
  // Map {'yes' => true, 'no' => false}
  ```

+ 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。

  ```javascript
  function jsonToMap(jsonStr) {
    return new Map(JSON.parse(jsonStr));
  }
  
  jsonToMap('[[true,7],[{"foo":3},["abc"]]]')
  // Map {true => 7, Object {foo: 3} => ['abc']}
  ```

## WeakMap

### 含义

+ `WeakMap`结构与`Map`结构类似，也是用于生成键值对的集合。

  ```javascript
  // WeakMap 可以使用 set 方法添加成员
  const wm1 = new WeakMap();
  const key = {foo: 1};
  wm1.set(key, 2);
  wm1.get(key) // 2
  
  // WeakMap 也可以接受一个数组，
  // 作为构造函数的参数
  const k1 = [1, 2, 3];
  const k2 = [4, 5, 6];
  const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);
  wm2.get(k2) // "bar"
  ```

+ `WeakMap`与`Map`的区别有两点。

+ 首先，`WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。

  ```javascript
  const map = new WeakMap();
  map.set(1, 2)
  // TypeError: 1 is not an object!
  map.set(Symbol(), 2)
  // TypeError: Invalid value used as weak map key
  map.set(null, 2)
  // TypeError: Invalid value used as weak map key
  ```

+ 其次，`WeakMap`的键名所指向的对象，不计入垃圾回收机制。

+ `WeakMap`的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。

  ```javascript
  const e1 = document.getElementById('foo');
  const e2 = document.getElementById('bar');
  const arr = [
    [e1, 'foo 元素'],
    [e2, 'bar 元素'],
  ];
  ```

+ 上面代码中，`e1`和`e2`是两个对象，我们通过`arr`数组对这两个对象添加一些文字说明。这就形成了`arr`对`e1`和`e2`的引用。

+ 一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放`e1`和`e2`占用的内存。

  ```javascript
  // 不需要 e1 和 e2 的时候
  // 必须手动删除引用
  arr [0] = null;
  arr [1] = null;
  ```

+ 上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。

+ WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

+ 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用`WeakMap`结构。当该 DOM 元素被清除，其所对应的`WeakMap`记录就会自动被移除。

  ```javascript
  const wm = new WeakMap();
  
  const element = document.getElementById('example');
  
  wm.set(element, 'some information');
  wm.get(element) // "some information"
  ```

+ 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对`element`的引用就是弱引用，不会被计入垃圾回收机制。

+ 也就是说，上面的 DOM 节点对象的引用计数是`1`，而不是`2`。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。

+ 总之，`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。`WeakMap`结构有助于防止内存泄漏。

+ 注意，WeakMap 弱引用的只是**键名**，而不是键值。键值依然是正常引用。

  ```javascript
  const wm = new WeakMap();
  let key = {};
  let obj = {foo: 1};
  
  wm.set(key, obj);
  obj = null;
  wm.get(key)
  // Object {foo: 1}
  ```

+ 上面代码中，键值`obj`是正常引用。所以，即使在 WeakMap 外部消除了`obj`的引用，WeakMap 内部的引用依然存在。

### WeakMap 的语法

+ WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有`keys()`、`values()`和`entries()`方法），也没有`size`属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持`clear`方法。因此，`WeakMap`只有四个方法可用：`get()`、`set()`、`has()`、`delete()`。

  ```javascript
  const wm = new WeakMap();
  
  // size、forEach、clear 方法都不存在
  wm.size // undefined
  wm.forEach // undefined
  wm.clear // undefined
  ```

### WeakMap 的示例

### WeakMap 的用途

+ 前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。

  ```javascript
  let myElement = document.getElementById('logo');
  let myWeakmap = new WeakMap();
  
  myWeakmap.set(myElement, {timesClicked: 0});
  
  myElement.addEventListener('click', function() {
    let logoData = myWeakmap.get(myElement);
    // get到的是对象{timesClicked:0}
    logoData.timesClicked++;
  }, false);
  ```

+ 上面代码中，`myElement`是一个 DOM 节点，每当发生`click`事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是`myElement`。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。

+ WeakMap 的另一个用处是部署私有属性。

  ```javascript
  const _counter = new WeakMap();
  const _action = new WeakMap();
  
  class Countdown {
    constructor(counter, action) {
      _counter.set(this, counter);
      _action.set(this, action);
    }
    dec() {
      let counter = _counter.get(this);
      if (counter < 1) return;
      counter--;
      _counter.set(this, counter);
      if (counter === 0) {
        _action.get(this)();
      }
    }
  }
  
  const c = new Countdown(2, () => console.log('DONE'));
  
  c.dec()
  c.dec()
  // DONE
  ```

+ 上面代码中，`Countdown`类的两个内部属性`_counter`和`_action`，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。

# 16. Proxy

## 概述

+ Proxy 用于修改某些操作的**默认行为**，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。

+ Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“**代理器**”。

  ```javascript
  var obj = new Proxy({}, {
    get: function (target, key, receiver) {
      console.log(`getting ${key}!`);
      return Reflect.get(target, key, receiver);
    },
    set: function (target, key, value, receiver) {
      console.log(`setting ${key}!`);
      return Reflect.set(target, key, value, receiver);
    }
  });
  ```

+ 上面代码对一个空对象架设了一层拦截，重定义了属性的读取（`get`）和设置（`set`）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象`obj`，去读写它的属性，就会得到下面的结果。

  ```javascript
  obj.count = 1
  //  setting count!
  ++obj.count
  //  getting count!
  //  setting count!
  //  2
  ```

+ 上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。

+ ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。

  ```javascript
  var proxy = new Proxy(target, handler);
  ```

+ Proxy 对象的所有用法，都是上面这种形式，不同的只是`handler`参数的写法。其中，`new Proxy()`表示生成一个`Proxy`实例，`target`参数表示所要**拦截的目标对象**，`handler`参数也是一个对象，用来定制拦截行为。

+ 下面是另一个拦截读取属性行为的例子。

  ```javascript
  var proxy = new Proxy({}, {
    get: function(target, property) {
      return 35;
    }
  });
  
  proxy.time // 35
  proxy.name // 35
  proxy.title // 35
  ```

+ 上面代码中，作为构造函数，`Proxy`接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有`Proxy`的介入，操作原来要访问的就是这个对象；第二个参数是一个**配置对象**，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个**`get`方法**，用来拦截对目标对象属性的**访问请求**。`get`方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回`35`，所以访问任何属性都得到`35`。

+ **注意**，要使得`Proxy`起作用，必须**针对`Proxy`实例**（上例是`proxy`对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。

+ 如果`handler`没有设置任何拦截，那就等同于**直接通向原对象**。

  ```javascript
  var target = {};
  var handler = {};
  var proxy = new Proxy(target, handler);
  proxy.a = 'b';
  target.a // "b"
  ```

+ 上面代码中，`handler`是一个空对象，没有任何拦截效果，访问`proxy`就等同于访问`target`。

### 用途

+ 一个**技巧**是将 Proxy 对象，设置到`object.proxy`**属性**，从而可以在`object`对象上调用。

  ```javascript
  var object = { proxy: new Proxy(target, handler) };
  ```

+ Proxy 实例也可以作为其他对象的**原型对象**。

  ```javascript
  var proxy = new Proxy({}, {
    get: function(target, property) {
      return 35;
    }
  });
  
  let obj = Object.create(proxy);
  obj.time // 35
  ```

+ 上面代码中，`proxy`对象是`obj`对象的原型，`obj`对象本身并没有`time`属性，所以根据原型链，会在`proxy`对象上读取该属性，导致被拦截。

### 拦截操作一览

+ 同一个拦截器函数，可以设置拦截多个操作。

  ```javascript
  var handler = {
    get: function(target, name) {
      if (name === 'prototype') {
        return Object.prototype;
      }
      return 'Hello, ' + name;
    },
  
    apply: function(target, thisBinding, args) {
      return args[0];
    },
  
    construct: function(target, args) {
      return {value: args[1]};
    }
  };
  
  var fproxy = new Proxy(function(x, y) {
    return x + y;
  }, handler);
  
  fproxy(1, 2) // 1
  new fproxy(1, 2) // {value: 2}
  fproxy.prototype === Object.prototype // true
  fproxy.foo === "Hello, foo" // true
  ```

+ 对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。

下面是 Proxy 支持的拦截操作一览，一共 13 种。

- **get(target, propKey, receiver)**：拦截对象属性的**读取**，比如`proxy.foo`和`proxy['foo']`。
- **set(target, propKey, value, receiver)**：拦截对象属性的**设置**，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值。
- **has(target, propKey)**：拦截`propKey in proxy`的操作，返回一个布尔值。
- **deleteProperty(target, propKey)**：拦截`delete proxy[propKey]`的操作，返回一个布尔值。
- **ownKeys(target)**：拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`、`for...in`循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而`Object.keys()`的返回结果仅包括目标对象自身的可遍历属性。
- **getOwnPropertyDescriptor(target, propKey)**：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。
- **defineProperty(target, propKey, propDesc)**：拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。
- **preventExtensions(target)**：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。
- **getPrototypeOf(target)**：拦截`Object.getPrototypeOf(proxy)`，返回一个对象。
- **isExtensible(target)**：拦截`Object.isExtensible(proxy)`，返回一个布尔值。
- **setPrototypeOf(target, proto)**：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
- **apply(target, object, args)**：拦截 Proxy 实例作为**函数调用**的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。
- **construct(target, args)**：拦截 Proxy 实例作为**构造函数调用**的操作，比如`new proxy(...args)`。

## Proxy 实例的方法

### get()

+ `get`方法用于拦截某个属性的读取操作，可以接受三个参数，依次为**目标对象**、**属性名**和 proxy **实例本身**（严格地说，是操作行为所针对的对象），其中最后一个参数**可选**。

  + 前两个必填？并不是，不填也是ok的，只是一般都会用到而已

+ `get`方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。

  ```javascript
  var person = {
    name: "张三"
  };
  
  var proxy = new Proxy(person, {
    get: function(target, property) {
      if (property in target) {
        return target[property];
      } else {
        throw new ReferenceError("Property \"" + property + "\" does not exist.");
      }
    }
  });
  
  proxy.name // "张三"
  proxy.age // 抛出一个错误
  ```

+ 上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回`undefined`。

+ `get`方法可以**继承**。

  ```javascript
  let proto = new Proxy({}, {
    get(target, propertyKey, receiver) {
      console.log('GET ' + propertyKey);
      return target[propertyKey];
    }
  });
  
  let obj = Object.create(proto);
  obj.foo // "GET foo"
  ```

+ 上面代码中，拦截操作定义在`Prototype`对象上面，所以如果读取`obj`对象继承的属性时，拦截会生效。

**用途实例**

+ 下面的例子使用`get`拦截，实现数组读取**负数的索引**。

  ```javascript
  function createArray(...elements) {
    let handler = {
      get(target, propKey, receiver) {
        let index = Number(propKey);
        if (index < 0) {
          propKey = String(target.length + index);
        }
        return Reflect.get(target, propKey, receiver);
      }
    };
  
    let target = [];
    target.push(...elements);
    return new Proxy(target, handler);
  }
  
  let arr = createArray('a', 'b', 'c');
  arr[-1] // c
  ```

+ 上面代码中，数组的位置参数是`-1`，就会输出数组的倒数第一个成员。

+ 利用 Proxy，可以将读取属性的操作（`get`），转变为执行某个函数，从而实现属性的**链式操作**。

  ```javascript
  var pipe = (function () {
    return function (value) {
      var funcStack = [];
      var oproxy = new Proxy({} , {
        get : function (pipeObject, fnName) {
          if (fnName === 'get') {
            return funcStack.reduce(function (val, fn) {
              return fn(val);
            },value);
          }
          funcStack.push(window[fnName]);
          return oproxy;
        }
      });
  
      return oproxy;
    }
  }());
  
  var double = n => n * 2;
  var pow    = n => n * n;
  var reverseInt = n => n.toString().split("").reverse().join("") | 0;
  
  pipe(3).double.pow.reverseInt.get; // 63
  ```

+ 下面的例子则是利用`get`拦截，实现一个**生成各种 DOM 节点的通用函数**`dom`。

  ```javascript
  const dom = new Proxy({}, {
    get(target, property) {
      return function(attrs = {}, ...children) {
        const el = document.createElement(property);
        for (let prop of Object.keys(attrs)) {
          el.setAttribute(prop, attrs[prop]);
        }
        for (let child of children) {
          if (typeof child === 'string') {
            child = document.createTextNode(child);
          }
          el.appendChild(child);
        }
        return el;
      }
    }
  });
  
  const el = dom.div({},
    'Hello, my name is ',
    dom.a({href: '//example.com'}, 'Mark'),
    '. I like:',
    dom.ul({},
      dom.li({}, 'The web'),
      dom.li({}, 'Food'),
      dom.li({}, '…actually that\'s it')
    )
  );
  
  document.body.appendChild(el);
  ```

+ 下面是一个`get`方法的第三个参数的例子，它总是指向**原始的读操作**所在的那个对象，一般情况下就是 Proxy 实例。

  ```javascript
  const proxy = new Proxy({}, {
    get: function(target, property, receiver) {
      return receiver;
    }
  });
  proxy.getReceiver === proxy // true
  ```

+ 上面代码中，`proxy`对象的`getReceiver`属性是由`proxy`对象提供的，所以`receiver`**指向`proxy`对象**。
+  ```javascript
  const proxy = new Proxy({}, {
    get: function(target, property, receiver) {
      return receiver;
    }
  });
  
  const d = Object.create(proxy);
  d.a === d // true
  ```
+ 上面代码中，`d`对象本身没有`a`属性，所以读取`d.a`的时候，会去`d`的原型`proxy`对象找。这时，`receiver`就**指向`d`**，代表原始的读操作所在的那个对象。

+ 如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会**报错**。

  ```javascript
  const target = Object.defineProperties({}, {
    foo: {
      value: 123,
      writable: false,
      configurable: false
    },
  });
  
  const handler = {
    get(target, propKey) {
      return 'abc';
    }
  };
  
  const proxy = new Proxy(target, handler);
  
  proxy.foo
  // TypeError: Invariant check failed
  ```

### set()

+ `set`方法用来拦截某个属性的**赋值操作**，可以接受四个参数，依次为**目标对象**、**属性名**、**属性值**和 Proxy **实例本身**，其中最后一个参数可选。

+ 假定`Person`对象有一个`age`属性，该属性应该是一个不大于 200 的整数，那么可以使用`Proxy`保证`age`的属性值符合要求。

  ```javascript
  let validator = {
    set: function(obj, prop, value) {
      if (prop === 'age') {
        if (!Number.isInteger(value)) {
          throw new TypeError('The age is not an integer');
        }
        if (value > 200) {
          throw new RangeError('The age seems invalid');
        }
      }
  
      // 对于满足条件的 age 属性以及其他属性，直接保存
      obj[prop] = value;
    }
  };
  
  let person = new Proxy({}, validator);
  
  person.age = 100;
  
  person.age // 100
  person.age = 'young' // 报错
  person.age = 300 // 报错
  ```

+ 上面代码中，由于设置了存值函数`set`，任何不符合要求的`age`属性赋值，都会抛出一个错误，这是**数据验证**的一种实现方法。利用`set`方法，还可以**数据绑定**，即每当对象发生变化时，会自动更新 DOM。

+ 有时，我们会在对象上面设置**内部属性**，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合`get`和`set`方法，就可以做到防止这些内部属性被外部读写。

  ```javascript
  const handler = {
    get (target, key) {
      invariant(key, 'get');
      return target[key];
    },
    set (target, key, value) {
      invariant(key, 'set');
      target[key] = value;
      return true;
    }
  };
  function invariant (key, action) {
    if (key[0] === '_') {
      throw new Error(`Invalid attempt to ${action} private "${key}" property`);
    }
  }
  const target = {};
  const proxy = new Proxy(target, handler);
  proxy._prop
  // Error: Invalid attempt to get private "_prop" property
  proxy._prop = 'c'
  // Error: Invalid attempt to set private "_prop" property
  ```

+ 下面是`set`方法第**四个参数**的例子。

  ```javascript
  const handler = {
    set: function(obj, prop, value, receiver) {
      obj[prop] = receiver;
    }
  };
  const proxy = new Proxy({}, handler);
  proxy.foo = 'bar';
  proxy.foo === proxy // true
  ```

+ 上面代码中，`set`方法的第四个参数`receiver`，指的是原始的操作行为所在的那个对象，一般情况下是`**proxy`实例本身**，请看下面的例子。

  ```javascript
  const handler = {
    set: function(obj, prop, value, receiver) {
      obj[prop] = receiver;
    }
  };
  const proxy = new Proxy({}, handler);
  const myObj = {};
  Object.setPrototypeOf(myObj, proxy);
  
  myObj.foo = 'bar';
  myObj.foo === myObj // true
  ```

+ 上面代码中，设置`myObj.foo`属性的值时，`myObj`并没有`foo`属性，因此引擎会到`myObj`的原型链去找`foo`属性。`myObj`的原型对象`proxy`是一个 Proxy 实例，设置它的`foo`属性会触发`set`方法。这时，第四个参数`receiver`就指向原始**赋值行为所在的对象`myObj`**。

+ 注意，如果目标对象自身的某个属性，不可写且不可配置，那么`set`方法将不起作用。

  ```javascript
  const obj = {};
  Object.defineProperty(obj, 'foo', {
    value: 'bar',
    writable: false,
  });
  
  const handler = {
    set: function(obj, prop, value, receiver) {
      obj[prop] = 'baz';
    }
  };
  
  const proxy = new Proxy(obj, handler);
  proxy.foo = 'baz';
  proxy.foo // "bar"
  ```

+ 上面代码中，`obj.foo`属性不可写，Proxy 对这个属性的`set`代理将不会生效。

+ 注意，**严格模式**下，`set`代理如果没有返回`true`，就会报错。

  ```javascript
  'use strict';
  const handler = {
    set: function(obj, prop, value, receiver) {
      obj[prop] = receiver;
      // 无论有没有下面这一行，都会报错
      return false;
    }
  };
  const proxy = new Proxy({}, handler);
  proxy.foo = 'bar';
  // TypeError: 'set' on proxy: trap returned falsish for property 'foo'
  ```

+ 上面代码中，严格模式下，`set`代理返回`false`或者`undefined`，都会报错。

### apply()

+ `apply`方法拦截**函数的调用、`call`和`apply`操作**。

+ `apply`方法可以接受三个参数，分别是**目标对象**、**目标对象的上下文对象（`this`）**和**目标对象的参数数组**。

  ```javascript
  var handler = {
    apply (target, ctx, args) {
      return Reflect.apply(...arguments);
    }
  };
  ```

+ 下面是一个例子。

  ```javascript
  var target = function () { return 'I am the target'; };
  var handler = {
    apply: function () {
      return 'I am the proxy';
    }
  };
  
  var p = new Proxy(target, handler);
  
  p()
  // "I am the proxy"
  // 上面代码中，变量p是 Proxy 的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。
  ```

+ 下面是另外一个例子。

  ```javascript
  var twice = {
    apply (target, ctx, args) {
      return Reflect.apply(...arguments) * 2;
    }
  };
  function sum (left, right) {
    return left + right;
  };
  var proxy = new Proxy(sum, twice);
  proxy(1, 2) // 6
  proxy.call(null, 5, 6) // 22
  proxy.apply(null, [7, 8]) // 30
  // 上面代码中，每当执行`proxy`函数（直接调用或`call`和`apply`调用），就会被`apply`方法拦截。
  ```

+ 另外，直接调用`Reflect.apply`方法，也会被拦截。

  ```javascript
  Reflect.apply(proxy, null, [9, 10]) // 38
  ```

### 自定义的方法

- ```javascript
  const target = {
    m: function () {
      console.log(this === proxy);
    }
  };
  const handler = {};
  
  const proxy = new Proxy(target, handler);
  
  target.m() // false
  proxy.m()  // true
  ```

+ 通过proxy访问m属性，也会被代理

## Proxy.revocable()

+ `Proxy.revocable`方法返回一个可取消的 Proxy 实例。

```javascript
let target = {};
let handler = {};

let {proxy, revoke} = Proxy.revocable(target, handler);

proxy.foo = 123;
proxy.foo // 123

revoke();
proxy.foo // TypeError: Revoked
```

+ `Proxy.revocable`方法返回一个对象，该对象的`proxy`属性是`Proxy`实例，`revoke`属性是一个函数，可以取消`Proxy`实例。上面代码中，当执行`revoke`函数之后，再访问`Proxy`实例，就会抛出一个错误。

+ `Proxy.revocable`的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。

## this 问题

+ 虽然 Proxy 可以代理针对目标对象的**访问**，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。

+ 主要原因就是在 Proxy 代理的情况下，目标对象内部的`this`关键字会指向 Proxy 代理。

  ```javascript
  const target = {
    m: function () {
      console.log(this === proxy);
    }
  };
  const handler = {};
  
  const proxy = new Proxy(target, handler);
  
  target.m() // false
  proxy.m()  // true
  ```

+ 上面代码中，一旦`proxy`代理`target.m`，后者内部的`this`就是指向`proxy`，而不是`target`。

+ 下面是一个例子，由于`this`指向的变化，导致 Proxy 无法代理目标对象。

  ```javascript
  const _name = new WeakMap();
  
  class Person {
    constructor(name) {
      _name.set(this, name);
    }
    get name() {
      return _name.get(this);
    }
  }
  
  const jane = new Person('Jane');
  jane.name // 'Jane'
  
  const proxy = new Proxy(jane, {});
  proxy.name // undefined
  ```

+ 上面代码中，目标对象`jane`的`name`属性，实际保存在外部`WeakMap`对象`_name`上面，通过`this`键区分。由于通过`proxy.name`访问时，`this`指向`proxy`，导致无法取到值，所以返回`undefined`。

+ 此外，有些原生对象的内部属性，只有通过正确的`this`才能拿到，所以 Proxy 也**无法代理**这些原生对象的属性。

  ```javascript
  const target = new Date();
  const handler = {};
  const proxy = new Proxy(target, handler);
  
  proxy.getDate();
  // TypeError: this is not a Date object.
  ```

+ 上面代码中，`getDate`方法只能在`Date`对象实例上面拿到，如果`this`不是`Date`对象实例就会报错。这时，**`this`绑定原始对象**，就可以解决这个问题。

  ```javascript
  const target = new Date('2015-01-01');
  const handler = {
    get(target, prop) {
      if (prop === 'getDate') {
        return target.getDate.bind(target);
      }
      return Reflect.get(target, prop);
    }
  };
  const proxy = new Proxy(target, handler);
  
  proxy.getDate() // 1
  ```

## 实例：Web 服务的客户端

+ Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。

  ```javascript
  const service = createWebService('http://example.com/data');
  
  service.employees().then(json => {
    const employees = JSON.parse(json);
    // ···
  });
  ```

+ 上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。

  ```javascript
  function createWebService(baseUrl) {
    return new Proxy({}, {
      get(target, propKey, receiver) {
        return () => httpGet(baseUrl+'/' + propKey);
      }
    });
  }
  ```

+ 同理，Proxy 也可以用来实现数据库的 ORM 层。

# 17. Reflect

## 概述

+ `Reflect`对象与`Proxy`对象一样，也是 ES6 为了**操作对象**而提供的新 API。`Reflect`对象的设计目的有这样几个。

1. 将`Object`对象的一些明显属于**语言内部**的方法（比如`Object.defineProperty`），**反射**到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到**语言内部**的方法。

2. 修改某些`Object`方法的返回结果，让其变得**更合理**。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`。

   ```javascript
   // 老写法
   try {
     Object.defineProperty(target, property, attributes);
     // success
   } catch (e) {
     // failure
   }
   
   // 新写法
   if (Reflect.defineProperty(target, property, attributes)) {
     // success
   } else {
     // failure
   }
   ```

3. 让`Object`操作都变成函数行为。某些`Object`操作是**命令式**，比如`name in obj`和`delete obj[name]`，而`Reflect.has(obj, name)`和`Reflect.deleteProperty(obj, name)`让它们变成了**函数行为**。

   ```javascript
   // 老写法
   'assign' in Object // true
   
   // 新写法
   Reflect.has(Object, 'assign') // true
   ```

4. `Reflect`对象的方法**与`Proxy`对象的方法一一对应**，只要是`Proxy`对象的方法，就能在`Reflect`对象上找到对应的方法。这就让`Proxy`对象可以方便地调用对应的`Reflect`方法，完成默认行为，作为修改行为的基础。也就是说，不管`Proxy`怎么修改默认行为，你总可以在`Reflect`上**获取默认行为**。

   ```javascript
   Proxy(target, {
     set: function(target, name, value, receiver) {
       var success = Reflect.set(target,name, value, receiver);
       if (success) {
         console.log('property ' + name + ' on ' + target + ' set to ' + value);
       }
       return success;
     }
   });
   ```

+ 上面代码中，`Proxy`方法拦截`target`对象的属性赋值行为。它采用`Reflect.set`方法将值赋值给对象的属性，**确保完成原有的行为，然后再部署额外的功能。**

+ 下面是另一个例子。

  ```javascript
  var loggedObj = new Proxy(obj, {
    get(target, name) {
      console.log('get', target, name);
      return Reflect.get(target, name);
    },
    deleteProperty(target, name) {
      console.log('delete' + name);
      return Reflect.deleteProperty(target, name);
    },
    has(target, name) {
      console.log('has' + name);
      return Reflect.has(target, name);
    }
  });
  ```

+ 上面代码中，每一个`Proxy`对象的拦截操作（`get`、`delete`、`has`），内部都调用对应的`Reflect`方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作**输出一行日志**。

+ 有了`Reflect`对象以后，很多操作会更易读。

  ```javascript
  // 老写法
  Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1
  
  // 新写法
  Reflect.apply(Math.floor, undefined, [1.75]) // 1
  ```

## 静态方法 

`Reflect`对象一共有 **13 个静态方法**。

- Reflect.apply(target, thisArg, args)
- Reflect.construct(target, args)
- Reflect.get(target, **propertyKey**, receiver)
- Reflect.set(target, **propertyKey**, value, receiver)
- Reflect.defineProperty(target, **propertyKey**, desc)
- Reflect.deleteProperty(target, **propertyKey**)
- Reflect.has(target, **propertyKey**)
- Reflect.ownKeys(target)
- Reflect.isExtensible(target)
- Reflect.preventExtensions(target)
- Reflect.getOwnPropertyDescriptor(target, **propertyKey**)
- Reflect.getPrototypeOf(target)
- Reflect.setPrototypeOf(target, prototype)

+ 上面这些方法的作用，大部分与`Object`对象的同名方法的作用都是相同的，而且它与`Proxy`对象的方法是一一对应的。下面是对它们的解释。

### Reflect.get(target, **propertyKey**, receiver)

+ `Reflect.get`方法查找并返回`target`对象的**propertyKey**，如果没有该属性，则返回`undefined`。

  ```javascript
  var myObject = {
    foo: 1,
    bar: 2,
    get baz() {
      return this.foo + this.bar;
    },
  }
  
  Reflect.get(myObject, 'foo') // 1
  Reflect.get(myObject, 'bar') // 2
  Reflect.get(myObject, 'baz') // 3
  ```

+ 如果`name`属性部署了读取函数（getter），则**读取函数的`this`绑定`receiver`**，与proxy的set()有点不同，此处的receiver需要主动绑定，而proxy的receiver取决于调用的方式，**不可以**主动绑定

  ```javascript
  var myObject = {
    foo: 1,
    bar: 2,
    get baz() {
      return this.foo + this.bar;
    },
  };
  
  var myReceiverObject = {
    foo: 4,
    bar: 4,
  };
  
  Reflect.get(myObject, 'baz', myReceiverObject) // 8
  ```

+ 如果第一个参数不是对象，`Reflect.get`方法会报错。

  ```javascript
  Reflect.get(1, 'foo') // 报错
  Reflect.get(false, 'foo') // 报错
  ```

### Reflect.set(target, **propertyKey**, value, receiver)

+ `Reflect.set`方法设置`target`对象的**`propertyKey`**等于`value`。

  ```javascript
  var myObject = {
    foo: 1,
    set bar(value) {
      return this.foo = value;
    },
  }
  
  myObject.foo // 1
  
  Reflect.set(myObject, 'foo', 2);
  myObject.foo // 2
  
  Reflect.set(myObject, 'bar', 3)
  myObject.foo // 3
  ```

+ 如果`propertyKey`设置了**赋值函数**，则赋值函数的`this`绑定`receiver`。

  ```javascript
  var myObject = {
    foo: 4,
    set bar(value) {
      return this.foo = value;
    },
  };
  
  var myReceiverObject = {
    foo: 0,
  };
  
  Reflect.set(myObject, 'bar', 1, myReceiverObject);
  myObject.foo // 4
  myReceiverObject.foo // 1
  
  // target的foo并没有改变，只有receiver改变了，setter的返回值没有给到target
  ```

+ 注意，如果 `Proxy`对象和 `Reflect`对象**联合使用**，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了`receiver`，那么`Reflect.set`会触发`Proxy.defineProperty`拦截。

  ```javascript
  let p = {
    a: 'a'
  };
  
  let handler = {
    set(target, key, value, receiver) {
      console.log('set');
      Reflect.set(target, key, value, receiver)
    },
    defineProperty(target, key, attribute) {
      console.log('defineProperty');
      Reflect.defineProperty(target, key, attribute);
    }
  };
  
  let obj = new Proxy(p, handler);
  obj.a = 'A';
  // set
  // defineProperty
  ```

+ 上面代码中，`Proxy.set`拦截里面**使用**了`Reflect.set`，**而且传入**了`receiver`，导致触发`Proxy.defineProperty`拦截。这是因为`Proxy.set`的`receiver`参数总是指向当前的 `Proxy`实例（即上例的`obj`），而`Reflect.set`一旦传入`receiver`，就会将属性**赋值**到`receiver`上面（即`obj`），导致触发`defineProperty`拦截。如果`Reflect.set`没有传入`receiver`，那么就不会触发`defineProperty`拦截。

+ 如果第一个参数不是对象，`Reflect.set`会报错。

  ```javascript
  Reflect.set(1, 'foo', {}) // 报错
  Reflect.set(false, 'foo', {}) // 报错
  ```

### Reflect.has(obj, propertyKey) 

### Reflect.deleteProperty(obj, propertyKey)

### Reflect.construct(target, args)

### Reflect.getPrototypeOf(obj)

### Reflect.setPrototypeOf(obj, newProto) 

### Reflect.apply(func, thisArg, args) 

### Reflect.defineProperty(target, propertyKey, attributes)

### Reflect.getOwnPropertyDescriptor(target, propertyKey) 

### Reflect.isExtensible (target) 

### Reflect.preventExtensions(target)

### Reflect.ownKeys (target)

## 实例：使用 Proxy 实现观察者模式

+ 观察者模式（Observer mode）指的是函数自动观察数据**对象**，一旦对象有变化，函数就会自动执行。

  ```javascript
  const person = observable({
    name: '张三',
    age: 20
  });
  
  function print() {
    console.log(`${person.name}, ${person.age}`)
  }
  
  observe(print);
  person.name = '李四';
  // 输出
  // 李四, 20
  ```

+ 上面代码中，数据对象`person`是观察目标，函数`print`是观察者。一旦数据对象发生变化，`print`就会自动执行。

+ 下面，使用 Proxy 写一个观察者模式的最简单实现，即**实现`observable`和`observe`这两个函数**。思路是`observable`函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。

  ```javascript
  // 使用set结构，可以保证按添加的顺序执行
  const queuedObservers = new Set();
  
  const observe = fn => queuedObservers.add(fn);
  const observable = obj => new Proxy(obj, {set});
  
  // handler
  function set(target, key, value, receiver) {
    const result = Reflect.set(target, key, value, receiver);
    queuedObservers.forEach(observer => observer());
    return result;
  }
  ```

+ 上面代码中，先定义了一个`Set`集合，所有观察者函数都放进这个集合。然后，`observable`函数返回原始对象的代理，拦截赋值操作。拦截函数`set`之中，会自动执行所有观察者。
