---
layout: post
#标题配置
title:  React Note
#时间配置
date:   2019-3-19 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note front-end
---

* content
{:toc}



结合 create-react-app 基本使用

# 1. React基础

## React的基本认识

### 官网

- 英文官网:[ https://reactjs.org/](https://reactjs.org/)

- 中文官网: <https://doc.react-china.org/>

### 介绍描述

- 用于构建用户界面的 JavaScript 库(只关注于View)

- 由Facebook开源

### React的特点

- Declarative(声明式编码)
- Component-Based(组件化编码)
- Learn Once, Write Anywhere(支持客户端与服务器渲染)
- 高效
- 单向数据流

### React高效的原因

- 虚拟(virtual)DOM, 不总是直接操作DOM
- DOM Diff算法, 最小化页面重绘
  - 虚拟DOM结构与页面实际的DOM结构一一对应
  - 在修改DOM结构时，先修改虚拟DOM结构，操作完成后，再更新实际DOM
  - 批量更新，且Diff算法，只更新变化的部分
  - 对比：以前改一个更新一个

### 相关js库

- react.js: React的核心库

- react-dom.js: 提供操作DOM的react扩展库

- babel.min.js: 解析JSX语法代码转为纯JS语法代码的库

```html
<script type="text/javascript" src="../js/react.development.js"></script>
<script type="text/javascript" src="../js/react-dom.development.js"></script>
<script type="text/javascript" src="../js/babel.min.js"></script>
```

### 编码示例

```react
<script type="text/babel"> //必须声明babel
  // 创建虚拟DOM元素
  const vDom = <h1 id={myId}>Hello React</h1> // 千万不要加引号
  // 渲染虚拟DOM到页面真实DOM容器中
  ReactDOM.render(vDom, document.getElementById('test'))
  //did
</script>
```

- jsx语法，不可以也不需要加引号

## React JSX语法

### JSX

- 全称:  JavaScript XML

- react定义的一种类似于XML的JS扩展语法: XML+JS

- 作用: 用来创建react虚拟DOM(元素)对象

```react
var ele = <h1>Hello JSX!</h1>
```

### **基本语法规则**

- 遇到 <开头的代码, 以标签的语法解析: html同名标签转换为html同名元素, 其它标签需要特别解析
  - 必须要有闭合标签，否则无法识别，不像html浏览器会自动加上
- 遇到以 { 开头的代码，以JS语法解析: 标签中的js代码必须用{ }包含
  - 类比Vue，冒号后的JS语法

### babel.js的作用

- 浏览器不能直接解析JSX代码, 需要babel转译为纯JS的代码才能运行

- 只要用了JSX，都要加上type="text/babel", 声明需要babel来处理

### 建虚拟DOM的2种方式

**纯JS(一般不用)**

+ ```react
  const element = React.createElement(
    'h1',
    {className: 'greeting'},
    'Hello, world!'
  );
  ```

- `React.createElement()` 这个方法首先会进行一些避免bug的检查，之后会返回一个类似下面例子的对象：

- ```react
  // 注意: 以下示例是简化过的（不代表在 React 源码中是这样）
  const element = {
    type: 'h1',
    props: {
      className: 'greeting',
      children: 'Hello, world'
    }
  };
  ```

- 这样的对象被称为 “React 元素”。它代表所有你在屏幕上看到的东西。React 通过读取这些对象来构建 DOM 并保持数据内容一致。

**JSX:**

+ ```react
  const element = (
    <h1 className="greeting">
      Hello, world!
    </h1>
  );
  ```

+ 本质上：jsx写法是`React.createElement()`的语法糖，最终会编译成`React.createElement()`形式

+ 由于 JSX 编译成`React.createElement`方法的调用，所以在你的 JSX 代码中，`React`库必须也始终在作用域中。

+ ```react
  import React from 'react';
  ```

### JSX中的子代

+ 在既包含开始标签又包含结束标签的 JSX 表达式中，这两个标签之间的内容被传递为专门的属性：`props.children`。有几种不同的方法来传递子代：

**字符串字面量**

+ 你可以在开始和结束标签之间放入一个字符串，则 `props.children` 就是那个字符串。这对于许多**内置 HTML 元素**很有用。例如：

+ ```react
  <MyComponent>Hello world!</MyComponent>
  ```

+ JSX 会移除空行和开始与结尾处的空格。标签邻近的新行也会被移除，字符串常量内部的换行会被压缩成一个空格，所以下面这些都等价：

  ```react
  <div>Hello World</div>
  
  <div>
    Hello World
  </div>
  
  <div>
    Hello
    World
  </div>
  
  <div>
  
    Hello World
  </div>
  ```

**jsx子代**

+ ```react
  <MyContainer>
    <MyFirstComponent />
    <MySecondComponent />
  </MyContainer>
  ```

**JavaScript 表达式作为子代**

+ ```react
  <MyContainer>
  	{todos.map((message) => <Item key={message} message={message} />)}
  </MyContainer>
  ```

**布尔值、Null 和 Undefined 被忽略**

+ `false`、`null`、`undefined` 和 `true` 都是有效的子代，只是它们不会被渲染。下面的JSX表达式将渲染为相同的东西：

  ```react
  <div />
  
  <div></div>
  
  <div>{false}</div>
  
  <div>{null}</div>
  
  <div>{undefined}</div>
  
  <div>{true}</div>
  ```

+ 一个告诫是JavaScript中的一些 [“falsy” 值](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)(比如数字`0`)，它们依然会被React渲染。当 `props.message` 为空数组时，它会打印`0`。要解决这个问题，请确保 `&&` 前面的表达式始终为布尔值：

  ```react
  <div>
    {props.messages.length > 0 &&
      <MessageList messages={props.messages} />
    }
  </div>
  ```

+ 相反，如果你想让类似 `false`、`true`、`null` 或 `undefined` 出现在输出中，你必须先把它[转换成字符串](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion) :

  ```react
  <div>
    My JavaScript variable is {String(myVariable)}.
  </div>
  ```

### 注意

1. JSX不是字符串, 也不是HTML/XML标签，是一个表达式
2. 它最终产生的就是一个JS对象
3. 标签名任意: HTML标签或其它标签

   - 组件标签
4. **JSX必须有结束标签**
5. **只能有一个根元素**，因为最终会调用React.createElement方法
6. JSX只有className
7. JSX的style：`style={{prop:"propName"}}`
8. 标签结构有嵌套的时候，在外面包个小括号
9. 因为 JSX 的特性更接近 JavaScript 而不是 HTML , 所以 React DOM 使用 `camelCase` 小驼峰命名 来定义属性的名称，而不是使用 HTML 的属性名称。
   - 例如，`class` 变成了 [`className`](https://developer.mozilla.org/en-US/docs/Web/API/Element/className)，而 `tabindex` 则对应着 [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex)。
   - 绑定事件也是驼峰的
10. 用户定义的组件必须大写

    + 当元素类型以小写字母开头时，它表示一个内置的组件，如 `<div>` 或 `<span>`，将导致字符串 `'div'` 或 `'span'` 传递给 `React.createElement`。 以大写字母开头的类型，如 `<Foo />` 编译为 `React.createElement(Foo)`，并且它正对应于你在 JavaScript 文件中定义或导入的组件。
11. 生成的列表需要添加key以作标志，方便vDOM的快速比对
12. 在一个组件的子元素位置使用注释要用 {} 包起来
13. 省略 Boolean 属性值会导致 JSX 认为 bool 值设为了 true。要传 false 时，必须使用属性表达式。这常用于表单元素中，比如 disabled、required、checked 和 readOnly 等。
14. const data = { name: 'foo', value: 'bar' }; 
    const component = <Component {...data} />;  
15. \<div dangerouslySetInnerHTML={{__html: 'cc &copy; 2015'}} />
16. 

## 虚拟DOM

- React提供了一些API来创建一种 `特别` 的一般**js对象**

```js
var element = React.createElement('h1', {id:'myTitle'},'hello')
```

- 上面创建的就是一个简单的虚拟DOM对象
- 虚拟DOM对象最终都会被React转换为真实的DOM
- 我们编码时基本只需要操作react的虚拟DOM相关数据, react会转换为真实DOM变化而更新界面

- jsx语法编写的DOM，最终还是会转换成js的那种语法
- 创建的虚拟DOM对象，属性和方法比实际DOM少得多，而且更新虚拟DOM，不会重新渲染整个页面
- ![1546602926375](F:\OneDrive\JS\纲略合集\assets\1546602926375.png)
- ![1546602959571](F:\OneDrive\JS\纲略合集\assets\1546602959571.png)

### 渲染虚拟DOM(元素)

- 语法:  `ReactDOM.render(virtualDOM, containerDOM) `
- 作用: 将虚拟DOM元素渲染到页面中的真实容器DOM中显示
- 参数说明

1. 纯js或jsx创建的虚拟dom对象
2. 用来包含虚拟DOM元素的真实dom元素对象(一般是一个div)

```react
const vDom = <h3 id={myId}>{msg.toLowerCase}</h3>
ReactDOM.render(vDom,document.getElementById("test"))
```

## 模块与组件和模块化与组件化的理解

### 模块

- 理解: 向外提供特定功能的js程序, 一般就是一个js文件

- 为什么:  js代码更多更复杂

- 作用: 复用js, 简化js的编写, 提高js运行效率

### 组件

- 理解: 用来实现特定(局部)功能效果的代码集合(html/css/js)

- 为什么: 一个界面的功能更复杂

- 作用: 复用编码, 简化项目编码, 提高运行效率

# 2. React面向组件编程

## 基本理解和使用

- 从面向对象（纯JS）→面向模块（功能JS）→面向组件（实现功能的HCSJ）
- 组件标签和HTML标签
  - 组件标签的首字母都是大写的，为了和HTML做区分
- 从找对象搞对象，到找组件搞组件

### 自定义组件(Component) :

- 定义组件(2种方式)
  - 如果组件是有state的，不可以使用工厂模式（函数组件）

```react
/*方式1: 工厂函数组件(简单组件)、工厂模式*/
function MyComponent () {
  return <h2>工厂函数组件(简单组件)</h2>
  //return 一个虚拟DOM
}

/*方式2:  ES6类组件(复杂组件)*/
//MC2 继承于 React.Component
class MyComponent2 extends React.Component {
  
  render () {
    console.log(this) // MyComponent2的实例对象,说明是实例调用的render方法
    return <h2>ES6类组件(复杂组件)</h2>
  }
}
```

- ![1546605248667](F:\OneDrive\JS\纲略合集\assets\1546605248667.png)
- 渲染DOM

```react
ReactDOM.render(<MyComponent />, document.getElementById('example1'))
```

### React编程规范

1. 组件名必须大写
2. 渲染的时候会自动去执行定义组件函数，不用另外调用

![1546604795348](F:\OneDrive\JS\纲略合集\assets\1546604795348.png)

5. 页面最终显示的不是组件标签，而是组件标签内部包含的h2

   - 也就是为什么组件标签的名字可以随便定义

6. constructor写在最上

7. render写在最下面，因为render最后重要

8. **复杂组件定了组件类（名），我们操作的（this）是组件对象**

   - 在组件类外部对MyComponent做的操作，是在类上的，当然对象也能用

   - 在内部，对this添加的只有该**组件对象**能够使用

   - ```react
     class CommentList extends React.Component {
     	static propTypes = {
         comments: PropTypes.array.isRequired,
         delete: PropTypes.func.isRequired
     	}
     	state={}
     }
     //CommentList 是组件类
     //state是组件对象（this）的属性，通过staic关键字，propTypes添加在了组件类上
     ```

   - **通过static关键字，在组件类内部，给组件类添加属性**

   - **不加static关键字，就是组件对象的属性**

### render()渲染组件标签的基本流程

1. React内部会创建组件实例对象

2. 得到包含的虚拟DOM并解析为真实DOM

3. 插入到指定的页面元素内部

## 组件三大属性1: state

### 理解

- state是组件对象最重要的属性, 值是对象(可以包含多个数据)

- 组件被称为"状态机", 通过更新组件的state来更新对应的页面显示(重新渲染组件)
  - 类似的是VM里的data()
  - 也有vuex state的特点

### 编码操作

+ 本质是es6，类的语法

- 初始化状态:

```react
constructor (props) {
  super(props)
  this.state = {
    stateProp1 : value1,
    stateProp2 : value2
  }
}

```

- 读取某个状态值

 ```react
 this.state.statePropertyName
 ```

- 更新状态---->组件界面更新

```react
this.setState({
  stateProp1 : value1,
  stateProp2 : value2
})

```
**注意**

- 永远返回一个新的状态

- 不要修改原来的状态
- 老DOM树和新DOM树，对比更新局部渲染
  - 所以都是用的setState，没有必要，也不应该覆盖旧的数据

+ 当state是一个**数组**的时候

  + ```react
    setState({ 'arrary': [...this.state.array, newItem]})
    ```

+ state更新过后，必须重新获取this.state才可以拿到新值，再函数初始时获得的时不会变的

### demo

```react
/*
需求: 自定义组件, 功能说明如下
  1. 显示h2标题, 初始文本为: 你喜欢我
  2. 点击标题更新为: 我喜欢你
*/
class Like extends React.Component {
  constructor (props) {
    super(props)
    // 1. 初始化状态
    this.state = {
      isLikeMe: true
    }
    // 绑定this为组件对象，bind方法不改变原来的函数，而是返回一个新的函数
    this.change = this.change.bind(this)
  }
  //新添加的方法：内部的this默认不是组件对象，而是undefined
  change () {
    // 3. 更新状态: this.setState()
    // this.state.isLikeMe = !this.state.isLikeMe 
    // 不能直接更新某个状态，需要使用setState方法
    this.setState({
      isLikeMe: !this.state.isLikeMe
    })
  }
  //重写组件类的方法，组件内部本来就有这个方法
  render () {
    console.log('render()')
    // 2.读取状态
    const text = this.state.isLikeMe ? '你喜欢我' : '我喜欢你'
    return <h2 onClick={this.change}>{text}</h2>
  }
}
ReactDOM.render(<Like />, document.getElementById('example'))
```

- `onClick={this.change}`，与vue绑定事件类似，不传参数的话不用加括号，本质上是通知this（组件对象）自己去调用
- 在监听事件内部去更新状态，状态state是一个对象，所以必须传入一个对象
- 在虚拟DOM处也可以绑定this，但是这样的话每次更新state，就会创建一个新的函数
- 实际开发的时候使用箭头函数，箭头函数的特性，没有自己的this

## 组件三大属性2: props

### 使用

- `npm install --save prop-types`

### 理解

- 每个组件对象都会有props(properties的简写)属性

- **组件标签的所有属性都保存在props中**

- props也是一个对象类型

- 如果你没有给属性传值，它默认为 `true`。因此下面两个 JSX 是等价的：

  ```react
  <MyTextBox autocomplete />
  <MyTextBox autocomplete={true} />
  ```

### 作用

- 通过标签属性从组件外向组件内传递变化的数据

- 注意: 组件内部**不要修改props数据**

### 编码操作

**读取某个属性值**

+ `this.props.propertyName`

**对props中的属性值进行类型限制和必要性限制**

+ ```react
  //这种方法，React.ProtoTypes 自React v15.5起已被弃用，需要使用prop-types代替
  Person.propTypes = {
    name: React.PropTypes.string.isRequired,
    age: React.PropTypes.number.isRequired
  }
  //引入prop-types包
  Person.propTypes = {
      name: PropTypes.string.isRequired,
      sex: PropTypes.string,
      age: PropTypes.number
    	children: PropTypes.oneOfType([
      PropTypes.arrayOf(PropTypes.node),
      PropTypes.node,
      PropTypesobject,
    ]),
   }
  ```

+ 可以使用 oneOfType() 方法

+ func 而不是 function

+ bool 而不是 boolean

+ 这是因为 function 和boolean 在 JavaScript 里是关键词。 

+ PropTypes 有很多类型支持，不仅有基本类型，还包括枚举和自定义类型。 

+ 组件的静态属性 propTypes 小写，引入的 函数 PropTypes大写 

+ 新版react 已经不支持 { PropTypes } from 'react'

+ PropTypes 仅仅是对 JS 弱类型的补充，只是做类型检查而已，props 在传入的时候 就已经可以通过 this.props 直接使用了

**使用扩展运算符**

+ : 将对象的所有属性通过props传递

+ `<Person {...person}/>`

**定义默认属性值**

+ ```react
  Person.defaultProps = {
  	name: 'Mary'
  }
  ```

**组件类的构造函数**

+ ```react
  constructor (props) {
  	super(props)
  	console.log(props) // 查看所有属性
  }
  ```

### demo

```react
  /*
需求: 自定义用来显示一个人员信息的组件, 效果如页面. 说明
  1). 如果性别没有指定, 默认为男
  2). 如果年龄没有指定, 默认为18
  */

  // 1. 定义组件类
  // 工厂模式定义组件时，props作为参数传入
  // 也真正意义上的props，可以对props做出限制，可以在组件对象上产看
  /*function Person(props) {
    return (
      <ul>
        <li>姓名: {props.name}</li>
        <li>性别: {props.sex}</li>
        <li>年龄: {props.age}</li>
      </ul>
    )
  }*/
  // 定义复杂组件的时候，props本质上是组件对象的属性，所以通过this调用
  class Person extends React.Component {
    render() {
      console.log(this)
      return (
        <ul>
          <li>姓名: {this.props.name}</li>
          <li>性别: {this.props.sex}</li>
          <li>年龄: {this.props.age}</li>
        </ul>
      )
    }
  }
  // 对标签属性进行限制
  Person.propTypes = {
    name: PropTypes.string.isRequired,
    sex: PropTypes.string,
    age: PropTypes.number,
  }
  // 指定属性的默认值
  Person.defaultProps = {
    sex: '男',
    age: 18
  }

  //2. 渲染组件标签
  const person = {
    name: 'Tom',
    sex: '女',
    age: 18
  }
  //通过...操作符简化操作
  ReactDOM.render(<Person {...person}/>, document.getElementById('example1'))
  const person2 = {
    myName: 'JACK',
    age: 17
  }
  ReactDOM.render(<Person name={person2.myName} age={person2.age}/>,
    document.getElementById('example2'))
```

- 通过...操作符简化操作

## state和props的对比

- state，组件**内部的**数据，通过数据的改变，来渲染组件
- props，组件**外部**，在渲染组件的时候传进来的
- `ReactDOM.render(<Person {...person}/>, document.getElementById('example1'))`

## 组件三大属性3: refs与事件处理

### refs属性

- 组件内的标签都可以定义ref属性来标识自己

```react
<input type="text" ref="content"/>
//this.refs.content来调用，但是官方不建议这么做

<input type="text" ref={input => this.msgInput = input}/>
//把input标签保存为this的一个属性msgInput
//自然 参数的名字、属性的名字都是随意的，只要可以辨识即可
//通过this.msgInput.value再去调用
```

- 回调函数在组件初始化渲染完或卸载时自动调用

- 在组件中可以通过this.msgInput来得到对应的**真实DOM元素**

- 作用: 通过ref获取组件内容特定标签对象, 进行读取其相关数据
  - 类似Vue this.refs.xxx

### 事件处理

- 通过onXxx属性指定组件的事件处理函数(注意大小写)

- React使用的是自定义(合成)事件, 而不是使用的原生DOM事件
  - 所以通过onXxx，大写来标志一下

- React中的事件是通过事件委托方式处理的(**委托给组件最外层的元素**)

- 通过event.target得到发生事件的DOM元素对象

```react
<input onFocus={this.handleClick}/>
handleFocus(event) {
	event.target  //返回input对象
}
```

### demo

```react
 /*
 需求: 自定义组件, 功能说明如下:
   1. 界面如果页面所示
   2. 点击按钮, 提示第一个输入框中的值
   3. 当第2个输入框失去焦点时, 提示这个输入框中的值
*/
 class Mycomponent extends React.Component {
   constructor(props) {
     super(props) // 调用父类(Component)的构造函数
     //console.log(this)，this是自定义的组件对象
     // 将自定义的函数强制绑定为组件对象
     this.handleClick = this.handleClick.bind(this)
     this.handeleBlur = this.handeleBlur.bind(this)// 将返回函数中的this强制绑定为指定的对象, 并没有改变原来的函数中的this
   }
   // 自定义的方法中的this默认为null


   //自定义方法的this默认为null
   handleClick(){
     alert(this.input.value)
   }
   /*handeleBlur(){
     alert(this.blur.value)
   }*/
   //更简单的方法，直接利用event，不用设置ref
   handeleBlur(event){
     alert(event.target.value)
   }

   render(){
     return (
       <div>
         <input type="text" ref={(input)=>{this.input=input}} />
         <button onClick={this.handleClick}>submit</button>
         <input type="text" placeholder="something" onBlur={this.handeleBlur}
         ref={(blur)=>{this.blur=blur}}/>
       </div>
     )
   }
 }

 ReactDOM.render(<Mycomponent/>,document.getElementById('example'))
```

### 强烈注意

- 组件内置的方法中的this为组件对象

- 在组件类中自定义的方法中this为null

- 强制绑定this: 通过函数对象的bind()

- 箭头函数(ES6模块化编码时才能使用)

- 自己调用自己的标签，就不用设置ref属性了，直接用event.target即可

- 指定的回调函数**不可以传参数**，需要用箭头函数包装一层

  - `<button onClick={() => this.ShowDetail(m.id)}>查看详情(push)</button>`

- react也可以使用原生的事件绑定，但是要注意给事件解绑，防止内存泄漏

  - > https://www.cnblogs.com/hit-tml/p/8204597.html

## 组件化编码流程

- 功能界面的组件化编码流程(无比重要)

1. 拆分组件: 拆分界面,抽取组件

2. 实现静态组件: 使用组件实现静态页面效果

3. 实现动态组件
   - 动态显示初始化数据
   - 交互功能(从绑定事件监听开始)

```react
 /*
    1)拆分组件: 拆分界面,抽取组件
    2)实现静态组件: 使用组件实现静态页面效果
    3)实现动态组件
        ① 动态显示初始化数据
        ② 交互功能(从绑定事件监听开始)
     */
    class App extends React.Component {
      constructor(props){
        super(props)
        this.state={
          todos:["eat","sleep","coding"],
        }
        this.add = this.add.bind(this)
      }

      //在父组件定义改变状态的方法，传递给子组件进行调用
      add(todo) {
        //改变state
        const {todos} = this.state
        todos.unshift(todo)
        this.setState({todos})
      }

      render(){
        const {todos} = this.state
        return(
          <div>
            <h1>Todo Lsit</h1>
            <Add length={todos.length} add={this.add}/>
            <List todos={todos}/>
          </div>
        )
      }
    }
    class Add extends React.Component {
      constructor(props){
        super(props)
        this.addTodo= this.addTodo.bind(this)
      }

      addTodo(){
        //1.获取value
        const todo = this.input.value.trim()
        //2.验证合法性
        if(!todo){
          return
        }
        //3.更新状态
        this.props.add(todo)
        //4.清空输入
        this.input.value=''
      }

      render(){
        return(
          <div>
            <input type="text" ref={(input)=>{this.input=input}}/>
            <button onClick={this.addTodo}>add #{this.props.length+1}</button>
          </div>
        )
      }
    }

    Add.propTypes = {
      length:PropTypes.number.isRequired,
      add:PropTypes.func.isRequired
    }

    class List extends React.Component {
      render(){
        const {todos} = this.props
        return(
          <ul>
            {todos.map((text,index)=><li key={index}>{text}</li>)}
          </ul>
        )
      }
    }

    List.propTypes = {
      todos:PropTypes.array.isRequired
    }

    ReactDOM.render(<App />,document.getElementById('example'))
```

- 问题：数据保存在哪个组件里？
  - 有哪些数据
  - 哪些组件要使用哪些数据
- 问题：在子组件改变父组件的状态
  - 但是子组件`this.setState`改变的是自己的状态，而不是父组件的
  - 子组件中不能直接改变父组件的状态
  - 状态在哪个组件，更新状态的行为就在哪个组件，把改变状态的方法专递给子组件，子组件来调用

### 总结

1. 拆分组件: 拆分界面,抽取组件

   + 组件边界
   + 结果：需要定义n个组件类

2. 实现静态组件: 使用组件实现静态页面效果

   - 给各个组件类指定render()
   - 可以指定静态数据

3. 实现动态组件

   - 动态显示初始化数据

     - 数据的归属

       - 数据在哪个组件，更新数据的行为就应该在哪个组件

     - 数据的传递

       1. 通过虚拟DOM传递数据：`<Add length={todos.length} add={this.add}/>`

       2. 接受数据的组件，需要定义PropTypes

          ```react
          Add.propTypes = {
                length:PropTypes.number.isRequired,
                add:PropTypes.func.isRequired
          }
          ```

   - 交互功能(从绑定事件监听开始)
     - 绑定事件监听
       1. 通过虚拟DOM绑定监听：`onClick={this.addTodo}`
       2. 通过虚拟DOM获取真实元素对象：`ref={(input)=>{this.input=input}`
       3. 自定义监听回调函数
       4. 指定监听回调函数的this：`this.addTodo= this.addTodo.bind(this)`

## 表单

- HTML表单元素与React中的其他DOM元素有所不同,因为表单元素生来就保留一些内部状态
- 在HTML当中，像`<input>`,`<textarea>`, 和 `<select>`这类表单元素会维持自身状态，并根据用户输入进行更新。但在React中，可变的状态通常保存在组件的状态属性中，并且只能用 [`setState()`](https://react.docschina.org/docs/react-component.html#setstate) 方法进行更新。
- 我们通过使react变成一种单一数据源的状态来结合二者。React负责渲染表单的组件仍然控制用户后续输入时所发生的变化。相应的，其值由React控制的输入表单元素称为“受控组件”。
  - 本质:拦截了HTML的默认操作，使用react来更新内容，保证了数据流的一致性
- 包含**表单的组件分类**

  - 受控组件: 表单项输入数据能自动收集成状态

  - 非受控组件: 需要时才手动读取表单输入框中的数据

```react
 /*
  需求: 自定义包含表单的组件
    1. 界面如下所示
    2. 输入用户名密码后, 点击登陆提示输入信息
    3. 不提交表单
  */
  class Form extends React.Component {
    constructor(props){
      super(props)
      this.state={
        pwd:'',
      }

      this.handleSubmit=this.handleSubmit.bind(this)
      this.handleChange=this.handleChange.bind(this)
    }


    handleSubmit(event){
      const name = this.nameInput.value
      const {pwd} = this.state
      alert(`输入的用户名是${name}，输入的密码是：${pwd}`)
      event.preventDefault()
    }

    handleChange(event){
      const pwd = event.target.value
      this.setState({pwd})
    }
    render(){
      return (
        <form action="" onSubmit={this.handleSubmit}>
          用户名：<input type="text" ref={(input)=> this.nameInput= input}/>
          密码：<input type="password" value={this.state.pwd} onChange={this.handleChange}/>
          <input type="submit"/>
        </form>
      )
    }
  }
  
  ReactDOM.render(<Form />,document.getElementById('example'))
```

## 组件的生命周期

### 理解

- 组件对象从创建到死亡它会经历特定的生命周期阶段

- React组件对象包含一系列的勾子函数(生命周期回调函数), 在生命周期特定时刻回调

- 我们在定义组件时, 可以重写特定的生命周期回调函数, 做特定的工作

### 生命周期流程图

![1546671409108](F:\OneDrive\JS\纲略合集\assets\1546671409108.png)

### 生命周期详述

- 组件的三个生命周期状态:

  - Mount：插入真实 DOM

  - Update：被重新渲染

  - Unmount：被移出真实 DOM

- React 为每个状态都提供了勾子(hook)函数

  - componentWillMount()

  - componentDidMount()

  - componentWillUpdate()

  - componentDidUpdate()

  - componentWillUnmount()

**生命周期流程:**

- 第一次初始化渲染显示: ReactDOM.render()

  - constructor(): 创建对象初始化state

  - componentWillMount() : 将要插入回调

  - render() : 用于插入虚拟DOM回调

  - componentDidMount() : 已经插入回调

- 每次更新state: this.setSate()

  -  componentWillUpdate() : 将要更新回调

  - render() : 更新(重新渲染)

  - componentDidUpdate() : 已经更新回调

- 移除组件: ReactDOM.unmountComponentAtNode(containerDom)

  - componentWillUnmount() : 组件将要被移除回调


**重要的勾子**

- render(): 初始化渲染或更新渲染调用
- componentDidMount(): 开启监听, 发送ajax请求
- componentWillUnmount(): 做一些收尾工作, 如: 清理定时器
- componentWillReceiveProps(): 后面需要时讲

### demo

```react
/*
  需求: 自定义组件
    1. 让指定的文本做显示/隐藏的动画
    2. 切换时间为2S
    3. 点击按钮从界面中移除组件界面
   */
  class Life extends React.Component {
    constructor(props){
      super(props)
      this.state = {
        opacity:1,
      }
      this.removeComponent= this.removeComponent.bind(this)
    }

    componentDidMount(){

      // 箭头函数的this由作用域决定，所以不能bind？
      this.intervalId = setInterval(()=>{
        let {opacity} = this.state
        opacity -= 0.1
        if(opacity<=0){
          opacity=1
        }
        this.setState({opacity})
      },200)
      // 普通匿名函数，通过bind绑定this
      /*this.intervalId = setInterval(function () {
        console.log('--------')
        // 得到当前opacity
        let {opacity} = this.state
        // 更新opacity
        opacity -= 0.1
        if(opacity<=0) {
          opacity = 1
        }
        // 更新状态
        this.setState({opacity})
      }.bind(this), 200)*/
    }

    componentWillUnmount () {// 清除定时器/解除监听
      console.log('componentWillUnmount(): 将要被移除')
      clearInterval(this.intervalId)
    }

    removeComponent(){
      ReactDOM.unmountComponentAtNode(document.getElementById('example'))
    }

    render(){
      const {opacity} = this.state
      return (
        <div>
          <h2 style={{opacity:opacity}}>{this.props.content}</h2>
          <button onClick={this.removeComponent}>finish</button>
        </div>
      )
    }
  }
  ReactDOM.render(<Life content="react so easy"/>,document.getElementById('example'))
```

## 虚拟DOM与DOM Diff算法

### 基本原理图

![1546677654628](F:\OneDrive\JS\纲略合集\assets\1546677654628.png)

![1546678000961](F:\OneDrive\JS\纲略合集\assets\1546678000961.png)

![1546678020758](F:\OneDrive\JS\纲略合集\assets\1546678020758.png)

![1546678041632](F:\OneDrive\JS\纲略合集\assets\1546678041632.png)



+ 有一些通用的解决方案，对于生成最小操作数的这个算法问题，以将一棵树转换为另一棵树。然而，在[state of the art algorithms](http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf) 中有时间复杂度为O(n3)，在这里n代表树中元素个数。
+ 若我们在React中使用，展示1000个元素则需要进行10亿次的比较。这太过昂贵。与此不同，React基于两点假设，实现了一个启发的O(n)算法：
  1. 两个不同类型的元素将产生不同的树。
  2. 开发者可以使用`key`属性来提示哪些子元素贯穿不同渲染是稳定的。
+ 实践中，上述这些假设适用于大部分应用场景。

### 差分算法

+ 当差分两棵树时，React首先比较两个根元素。依赖于根元素的类型不同，其行为也不同。

**不同类型的元素**

+ 每当**根元素**有不同类型，React将拆除旧树并且从零开始重新构建新树。从`<a>`到`<img>`或从`<Article>`到`<Comment>`，或从`<Button>` 到 `<div>`————这些都会导致充分地重新构建。

  + 当拆除一棵树时，旧的DOM节点被销毁。组件实例收到`componentWillUnmount()`。当构建一棵新树时，新的DOM节点被插入到DOM中。组件实例先收到`componentWillMount()`，然后收到`componentDidMount()`。任何与旧树有关的状态都被丢弃。

+ 这个根下任何组件也都将被卸载，他们的状态被销毁。例如，当定义：

  ```react
  <div>
    <Counter />
  </div>
  
  <span>
    <Counter />
  </span>
  ```

+ 这将销毁旧的`Counter`并重装载一个新的。

**相同类型的DOM元素**

+ 当比较两个**相同类型**的React DOM元素时，React则会观察二者的属性(attributes)，保持相同的底层DOM节点，并**仅更新变化的属性**。例如：

  ```react
  <div className="before" title="stuff" />
  
  <div className="after" title="stuff" />
  ```

+ 通过比较这两个元素，React知道仅更改底层DOM元素的`className`。

+ 当更新`style`时，React同样知道仅更新改变的属性(properties)。例如：

  ```react
  <div style={{color: 'red', fontWeight: 'bold'}} />
  
  <div style={{color: 'green', fontWeight: 'bold'}} />
  ```

+ 当在两个元素之间转化时，React知道仅修改`color`样式，而`fontWeight`不用修改。
+ 在处理完DOM元素后，React递归其子代。

**相同类型的组件元素**

+ 当组件更新时，实例保持相同，这样状态跨渲染被维护。React通过更新底层组件实例的属性(props)来匹配新元素，并在底层实例上调用`componentWillReceiveProps()` 和 `componentWillUpdate()`。
+ 下一步，`render()`方法被调用，差分算法递归处理前一次的结果和新的结果。

**子代们上的递归**

+ 为解决该问题，React支持了一个`key`属性。
+ 现在React知道带有`'2014'`的key的元素是新的，带有`'2015'`和`'2016'`的key的元素仅需要移动。

### 权衡

+ 

## 组合VS继承

+ 使用组合，把React元素当作属性传递给子组件，有点类似与Vue的slot
+ 不使用继承，也不会用。。。

# 3. React应用（基于React脚手架）

## 使用create-react-app创建react应用

### react脚手架

- xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目
  - 包含了所有需要的配置
  - 指定好了所有的依赖
  - 可以直接安装/编译/运行一个简单效果

- react提供了一个用于创建react项目的脚手架库: create-react-app

- 项目的整体技术架构为:  react + webpack + es6 + eslint

- 使用脚手架开发的项目的特点: 模块化, 组件化, 工程化

- 自动实现：

  - 浏览器开启
  - live reload

### 资源准备

- 并没有引入prop-types的包，需要额外引入

### 创建项目并启动

```npm
npm install -g create-react-app
create-react-app hello-react
cd hello-react
npm start
```

###  react脚手架项目结构

ReactNews

  |--node_modules---第三方依赖模块文件夹

  |--public

​      *|--* *index.html-----------------**主页面*

  |--scripts

​      *|--* *build.js-------------------build**打包引用配置*

​      *|--* *start.js-------------------start**运行引用配置*

  |--src------------源码文件夹

​      *|--components-----------------react**组件*

​      *|--index.js-------------------**应用入口**js*

  |--.gitignore------git版本管制忽略的配置

  |--package.json----应用包配置文件 

  |--README.md-------应用描述说明的readme文件

- webpack相关配置：node_modules/react-scripts/config

## React组件代码模板

```react
import React, {Component} from 'react';

class Demo extends Component {
  render() {
    return (
      <div>
        
      </div>
    );
  }
}

export default Demo;
```

## 虚拟DOMCSS样式

- 所有的class必须使用className
- 在入口js导入css样式，正常编写css即可

## demo：评论管理

```react
class App extends React.Component {
  state = {
      comments: []
    }
}
//在直接作用域重写state，state初始值为null，实例属性的简洁写法
```

```reac
class CommentList extends React.Component {
	static propTypes = {
    comments: PropTypes.array.isRequired,
    delete: PropTypes.func.isRequired
	}
	state={}
}
//CommentList 是组件类
//state是组件对象（this）的属性，通过staic关键字，propTypes添加在了组件类上
```

```react
class CommentAdd extends React.Component {
  handleClick = ()=>{
    //因为箭头函数看外围作用域的this，这样就不需要bind方法了
  }
}
```

- 多个表单收集数据，要以受控组件的形式，如何统一onchange事件呢？
- comment-item不知道自己的index，但是comment-list知道，所以再把index也传给comment-item

# 4. React Ajax

## 理解

### 前置说明

- React本身只关注于界面, 并不包含发送ajax请求的代码

- 前端应用需要通过ajax请求与后台进行交互(json数据)

- react应用中需要集成第三方ajax库(或自己封装)

### 常用的ajax请求库

- jQuery: 比较重, 如果需要另外引入不建议使用

- axios: 轻量级, 建议使用
  - 封装XmlHttpRequest对象的ajax

  - promise风格

  - 可以用在浏览器端和node服务器端

- fetch: 原生函数, 但老版本浏览器不支持

  - 不再使用XmlHttpRequest对象提交ajax请求
  - 浏览器本身就支持
  - ![1546828063156](F:\OneDrive\JS\纲略合集\assets\1546828063156.png)

  - 为了兼容低版本的浏览器, 可以引入兼容库fetch.js
    - 兼容性的判断：如果有fetch函数就使用
    - 如果没有就是用XHR对象的方法

### demo

```react
/*
需求:
  1. 界面效果如下
  2. 根据指定的关键字在github上搜索匹配的最受关注的库
  3. 显示库名, 点击链接查看库
  4. 测试接口: https://api.github.com/search/repositories?q=r&sort=stars
*/

class MostRepoStar extends React.Component {
  state = {
    //使用等于号，而不是冒号，因为本质上是给this.state赋值，给对象的属性赋值？
    repoName:'',
    repoUrl:''

  }

  //发送ajax请求获取repoName和repoUrl
  componentDidMount(){
    const url = `https://api.github.com/search/repositories?q=r&sort=stars`
    axios.get(url)
      .then((res)=>{ //成功的回调
        console.log(res)
        const result  = res.data
        const repo = result.items[0]
        const {name,html_url} = repo
        //更新状态,属性名不对应不可以简写
        this.setState({repoName:name,repoUrl:html_url})
      })
      .catch(error => {
        // debugger
        console.log(error)
        alert('请求失败 '+ error.message)
      })
    /*fetch(url, {method: "GET"})
    	//箭头函数默认的return
      .then(response => response.json())
      .then(data => {
        console.log(data)
        if(data.message) {
          alert(`请求失败: ${data.message}`)
        } else {
          const repo = data.items[0]
          this.setState({
          repoName: repo.name,
          repoUrl: repo.html_url
          })
        }
      })*/
  }


  render(){
    const {repoName,repoUrl} = this.state
    if(!repoName){ //repoName没有值
      return(
        <h2>LOADING...</h2>
      )
    }else { //repo有值
      return(
        <h2>most star repo is <a href={repoUrl}>{repoName}</a></h2>
      )
    }

  }
}
ReactDOM.render(<MostRepoStar/>,document.getElementById('example'))
```

##  axios

### 文档

- <https://github.com/axios/axios>

### 应用

+ 请求和响应的拦截
+ 在请求之前做点啥（回调）
  + 统一给axios添加loading酱紫
+ 在响应之后做点啥（回调）

### 相关API

- get请求

```js
axios.get('/user?ID=12345')
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });

axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

- post请求

```js
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
})
.then(function (response) {
  console.log(response);
})
.catch(function (error) {
  console.log(error);
});
```

## Fetch

###  文档

- <https://github.github.io/fetch/>

- <https://segmentfault.com/a/1190000003810652>

### 相关API

- get请求

```js
fetch(url).then(function(response) {
  //说明返回的是一个包含数据的promise对象，有两层promise
  //为了减少嵌套，用return返回了再.then()
  return response.json() 
}).then(function(data) { 
  console.log(data)
}).catch(function(e) {
  console.log(e)
});
```

- post请求

```js
fetch(url, {
  method: "POST",
  body: JSON.stringify(data),
}).then(function(data) {
  console.log(data)
}).catch(function(e) {
  console.log(e)
})
```

### demo：github users

- 兄弟组件间通信
  - 通过父亲
  - 父亲定义改变状态的方法，给子组件A调用
  - 把改变的状态传给B，当子组件A调用了方法，B可以知道
- react监视状态改变的做法
  - 生命周期钩子函数
  - 当组件**接受到**新的属性时：componentsWillReceiveProps(newProps)
- 数组map方法的精髓：根据一个数组生成一个新的数组

  - 特点：长度一样，元素之间有对应关系

  - ```js
    const user = result.items.map(item => ({
      name:item.login,
      item:item.html_url,
      avataUrl:item.avata_url
    })) 
    //把返回的数组通过map变成想要的数组，删除多余的数据
    ```



# 5. React实践总结

## 组件间通信

### 方式一: 通过props传递

- 共同的数据放在父组件上, 特有的数据放在自己组件内部(state)

- 通过props可以传递一般数据和函数数据, 只能一层一层传递
  - 一般数据-->父组件传递数据给子组件-->子组件读取数据

  - 函数数据-->子组件传递数据给父组件-->子组件调用函数

### 方式二: 使用消息订阅(subscribe)-发布(publish)机制

- 工具库: PubSubJS

- 下载: npm install pubsub-js --save

- 使用: 

​          1.  import PubSub from 'pubsub-js' //引入

​          2.  PubSub.subscribe('delete', function(data){ }); //订阅

​          3.  PubSub.publish('delete', data) //发布消息

### 方式三: redux

- 后面专门讲解

## 事件监听理解

### 原生DOM事件

- 绑定事件监听
  - 事件名(类型): 只有有限的几个, 不能随便写
  - 回调函数

- 触发事件

  - 用户操作界面

  - 事件名(类型)

  - 数据()

### 自定义事件(消息机制)

- 订阅消息：绑定事件监听
  - 事件名(类型): 任意

  - 回调函数: 通过**形参接收数据**, 在函数体**处理事件**

  - ```react
    //search.jsx
    search=()=>{
      //发布消息
      PubSub.publish("search",data)
    }
    
    //main.jsx
    componnetDidMount(){
      //订阅消息（收到数据之后干啥）
      PubSub.subscribe("search",(msg,data)=>{ //用箭头函数，兼容this
        console.log(msg,data)
      })
    }
    ```

  - 

- 发布消息：触发事件(编码)

  - 发布了什么事件（事件名），内容是什么（数据）
  - 事件名(类型): 与绑定的事件监听的事件名一致

  - 数据: 会自动传递给回调函数

## ES6常用新语法

- 定义常量/变量:  const/let

- 解构赋值: let {a, b} = this.props   import {aa} from 'xxx'

- 对象的简洁表达: {a, b}

- 箭头函数: 
  - 常用场景
  - 组件的自定义方法: xxx = () => {}
  - 参数匿名函数

- 优点:

  - 简洁

  - 没有自己的this,使用引用this查找的是外部this

- 扩展(三点)运算符: 
  - 拆解对象(const MyProps = {}, <Xxx {...MyProps}>)

- 类:  
  - class/extends/constructor/super

- ES6模块化:  export default | import

# 6. React-router4

## 对比React-router3

```react
import React from 'react'; 
import { Router, Route, IndexRoute, hashHistory } from 'react-router'; 
import Home from '../views/Home'; 
import Detail from '../views/Detail'; 
const routes = ( 
  <Router history={hashHistory}> 
   <Route path="/" component={Home} /> 
   <Route path="/detail/:id" component={Detail} /> 
  </Router> 
```

- 组件从 'react-router' 当中获得，且推荐的方案是 Router 组件，需要主动传递 history prop

```react
import React from 'react';
import ReactDOM from 'react-dom';
import {HashRouter, Switch, Route} from 'react-router-dom'

import './index.less';
import App from './App';
import Play from './Play'

ReactDOM.render(
(
  <HashRouter>
    <Switch> {/*需要紧紧跟着Router，中间插入了其他则不行*/}
      {/* 默认路由，path='/' 必须加上exact，否则任何时候都是匹配的*/}
      <Route exact path='/' component={App}/>
      <Route path='/play' component={Play} />
    </Switch>
  </HashRouter>
), 
document.getElementById('root'));
```

- 组件从 'react-router-dom' 中获取， 'react-router' 在哪里使用呢？
- 使用 HashRouter BrowserRouter 代替了以前传递 prop 的形式，但是以前的那些组件 Router Route依然可以从 react-router 中获取，为了兼容，可以理解
- ![1552287113620](F:\OneDrive\JS\纲略合集\assets\1552287113620.png) 
- 实际渲染之后，自动补充了 Router 组件

## 理解

### react-router的理解

- react的一个插件库
  - 专门用来实现一个SPA应用
  - 基于react的项目基本都会用到此库

### SPA的理解

- 单页Web应用（single page web application，SPA）

- 整个应用只有一个完整的页面

- 点击页面中的链接不会刷新页面, 本身也不会向服务器发请求

- 当点击**路由链接**时, 只会做页面的局部更新

- 数据都需要通过ajax请求获取, 并在前端异步展现

### 路由的理解

- 什么是路由?
  - 一个路由就是一个映射关系(key:value)
    - 后台：router.get(path,fun)，路由器在注册路由

  - key为路由路径, value可能是function/component

- 路由分类

  - 后台路由: node服务器端路由, value是function, 用来处理客户端提交的请求并返回一个响应数据

  - 前台路由: 浏览器端路由, value是component, 当请求的是路由path时, 浏览器端前没有发送http请求, 但界面会更新显示对应的组件 

- 后台路由

  - 注册路由: router.get(path, function(req, res))

  - 当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据

- 前端路由

  - 注册路由: <Route path="/about" component={About}>

  - 当浏览器的hash变为#about时, 当前路由组件就会变为About组件

### 前端路由的实现

- 每种路由都会创建history对象，用来追踪当前的location[1]，并在网站变化的时候重新渲染。React Router提供的其它的组件都依赖于上下文中的history对象，所以必须在组件内部渲染。
- history库
- 网址: <https://github.com/ReactTraining/history>
- 管理浏览器会话历史(history)的工具库
- 包装的是原生BOM中window.history和window.location.hash
- history API

  - History.createBrowserHistory(): 得到封装window.history的管理对象

  - History.createHashHistory(): 得到封装window.location.hash的管理对象

  - history.push(): 添加一个新的历史记录

  - history.replace(): 用一个新的历史记录替换当前的记录

  - history.goBack(): 回退到上一个历史记录

  - history.goForword(): 前进到下一个历史记录

  - history.listen(function(location){}): 监视历史记录的变化
- ![1546845515595](F:\OneDrive\JS\纲略合集\assets\1546845515595.png)
- 其实是一个类似于栈的结构，replace就把2替换掉了，出栈，剩下1

- let history = History.createBrowserHistory() // 方式一:h5新增history
- let history = History.createHashHistory() // 方式二：哈希
  - #号
  - 锚点（哈希值），虽然没有发请求，但是还是留下了历史记录
  - 记录了哈希值

## React-router 相关API

### 组件

- 在 react-router v4 中 react-router 被划分为三个包：react-router，react-router-dom 和 react-router-native，区别如下：
  - react-router：提供核心路由组件和函数
  - react-router-dom：供浏览器使用的 react router
  - react-router-native：供 react native 使用的 react router

**一般情况下，我们直接使用的只有 react-router-dom**

<BrowserRouter>

<HashRouter>

- 两种类型的路由器

<Route>

<Redirect>

<Link>

- 点击之后不会有active的class

<NavLink>

- activeClass

<Switch>

- 包裹<Route>

### 其它

- history对象
  - this.props.history.push/replace/goforword/goback
- match对象
  - this.props.match.params
  - 通过路由参数，向**路由组件传递参数**
- withRouter函数
  - 包装普通组件，使得普通的组件也可以使用路由组件的方法
  - 常用于导航等公共组件PropTypes

## 基本路由使用

### 准备

- 下载react-router: npm install --save react-router@4
- npm install --save react-router-dom

- 引入bootstrap.css: <link rel="stylesheet" href="/css/bootstrap.css">

### demo

```react
//路由组件: views/about.jsx
import React from 'react'
export default function About() {
  return <div>About组件内容</div>
}

//路由组件: views/home.jsx
import React from 'react'
export default function About() {
  return <div>Home组件内容</div>
}

//应用组件: components/app.jsx
import React from 'react'
import {Route, Switch, Redirect} from 'react-router-dom'
import About from './views/about'
import Home from './views/home'

export default class App extends React.Component {

  render () {
    return (
      <div>

        <div className="row">
          <div className="col-xs-offset-2 col-xs-8">
            <div className="page-header">
              <h2>React Router Demo</h2>
            </div>
          </div>
        </div>

        <div className="row">
          <div className="col-xs-2 col-xs-offset-2">
            <div className="list-group">
              {/*导航路由链接*/}
              <NavLink className="list-group-item" to='/about' >About</NavLink>
              <NavLink className="list-group-item" to='/home'>Home</NavLink>
            </div>
          </div>
          <div className="col-xs-6">
            <div className="panel">
              <div className="panel-body">
                {/*可切换的路由组件*/}
                <Switch>
                  <Route path='/about' component={About} />
                  <Route path='/home' component={Home} />
                  <Redirect to='/about' />
                </Switch>
              </div>
            </div>
          </div>
        </div>
      </div>
    )
  }
}

```

### 包装现有的link组件

```react
//包装NavLink组件: components/my-nav-link.jsx
import React from 'react'
import {NavLink} from 'react-router-dom'

//把所有传过来的props都定义为NavLink的属性，组件类形式：{...this.props}
//关键是新增了所有的NavLink都需要的一个样式：activeClassName
export default function MyNavLink(props) {
  return <NavLink {...props} activeClassName='activeClass'/>
}

<MyNavLink className="list-group-item" to='/about' >About</MyNavLink>
<MyNavLink className="list-group-item" to='/home'>Home</MyNavLink>


```

```react
//入口JS: index.js

import React from 'react'
import ReactDOM from 'react-dom'
import {BrowserRouter, HashRouter} from 'react-router-dom'
import App from './components/app'

import './index.css'

ReactDOM.render(
  (
    <BrowserRouter>
      <App />
    </BrowserRouter>
    /*<HashRouter>
      <App />
    </HashRouter>*/
  ),

  document.getElementById('root')
)
```

- 需要用 <BrowserRouter>包裹<APP/>

### 默认路由

- index.js，注册路由

- ```react
  import React from 'react';
  import ReactDOM from 'react-dom';
  import {HashRouter, Switch, Route} from 'react-router-dom'
  
  import './index.less';
  import App from './App';
  import Play from './Play'
  
  ReactDOM.render(
  (
    <HashRouter>
      <Switch> {/*需要紧紧跟着Router，中间插入了其他则不行*/}
        {/* 默认路由，path='/' 必须加上exact，否则任何时候都是匹配的*/}
        <Route exact path='/' component={App}/>
        <Route path='/play' component={Play} />
      </Switch>
    </HashRouter>
  ), 
  document.getElementById('root'));
  ```

+ App,jsx，等子组件，通过Link标签进行路由跳转

+ ```react
  <NavLink to='/play'><i className='iconfont icon-play'></i></NavLink>
  ```

### 嵌套路由

+ 由于 react-router 规定：

  + Router 组件下只能有一个子元素
  + 所有 react-router 的组件必须是 Router  子孙元素

+ 为了实现嵌套路由有三种方法

+ 方法一：公共部分不含路由组件，直接把Router嵌入即可

  ```react
  <div className='n-back_container'>
    <Header ref={Header=>{this.Header=Header}}></Header>
    <HashRouter>
      <Switch>
        <Route exact path='/start' component={Start}/>
        <Route path='/play' component={Play} />
        <Route path='/result' component={Result} />
        <Redirect path="/" to={{pathname: '/start'}} />
      </Switch>
    </HashRouter>
  </div>
  ```

+ 方法二：公共部分含有路由组件，比如底部导航，在 Rouer 下再包裹一层即可

  ```react
  <HashRouter>
    <div>
      <Nav/>
      <Switch>
        <Route exact path='/' component={Home}></Route>
        <Route path='/detail/:id' component={Detail}></Route>
      </Switch>
    </div>
  </HashRouter>
  ```

+ 方法三：通用，但是逻辑表达不清晰，也可用在条件显示组件，但是不如判断语法明了

  ```react
  <ConnectedRouter history={history}>
    <div>
      <Route exact path="/login" component={LoginPage} />
      <Route exact path="/" component={privateRoute(App)} />
      <Route path="/app" component={privateRoute(App)} />
      <Route path="/app/users" component={privateRoute(UserListPage)} />
      <Route path="/app/chpwd" component={privateRoute(ChpwdPage)} />
      <Route path="/app/user" component={privateRoute(User)} />
      <Route path="/logout"  onEnter={props.logout} />
    </div>
  </ConnectedRouter>
  ```

### 向路由组件传递参数

- 问题：路由组件在<Route>标签内部，以属性的形式存在，怎么传递数据呢？

```react

//二级路由组件: views/message.jsx
const path = this.props.match.path

<NavLink to={`${path}/${m.id}`}>{m.title}</NavLink>

<Route path={`${path}/:id`} component={MessageDetail}></Route>

//三级路由组件: views/message-detail.jsx
const id = props.match.params.id

```

- 路由连接与非路由连接：为什么a标签页会发请求

### 路由跳转的两种方式

+ link标签

+ this.props.history的方法

+ ```react
   handleTouch = () =>{
      this.props.history.push('/play')
  }
  
  <i className='iconfont icon-play' onTouchStart={this.handleTouch}></i>
  ```

### React-router4的特性

+ > https://juejin.im/entry/58e72aa661ff4b0061905e6b

# 7. React-UI

## 最流行的开源React UI组件库

### material-ui(国外)

- 官网: <http://www.material-ui.com/#/>

- github: <https://github.com/callemall/material-ui>

### ant-design(国内蚂蚁金服)

- PC官网: <https://ant.design/index-cn>

- 移动官网: <https://mobile.ant.design/index-cn>

- Github: <https://github.com/ant-design/ant-design/>

- Github: <https://github.com/ant-design/ant-design-mobile/>

### 搭建antd-mobile的基本开发环境

- 下载`npm install antd-mobile --save`

### 实现按需打包(组件js/css)

1. 下载依赖包

`npm react-app-rewired --save -dev`

`npm babel-plugin-import --save -dev`

2. 修改默认配置:  

- /package.json

- ```json
  "scripts": {
    "start": "react-app-rewired start",
    "build": "react-app-rewired build",
    "test": "react-app-rewired test --env=jsdom"
  }
  
  ```

- 创建config-overrides.js

- ```js
  const {injectBabelPlugin} = require('react-app-rewired');
  module.exports = function override(config, env) {
    config = injectBabelPlugin(['import', {libraryName: 'antd-mobile', style: 'css'}], config);
    return config;
  };
  
  ```

# 8. Redux

## redux理解

### 学习文档

- 英文文档: <https://redux.js.org/>

- 中文文档: <http://www.redux.org.cn/>

- Github: <https://github.com/reactjs/redux>

### redux是什么?

- redux是一个独立专门用于做状态管理的JS库(不是react插件库)

- 它可以用在react, angular, vue等项目中, 但基本与react配合使用

- 作用: 集中式管理react应用中多个组件共享的状态

### redux工作流程

![1547027805153](F:\OneDrive\JS\纲略合集\assets\1547027805153.png)

- Action Creators是一个工厂函数

### 什么情况下需要使用redux

- 总体原则: 能不用就不用, 如果不用比较吃力才考虑使用

1. 某个组件的状态，需要共享

2. 某个状态需要在任何地方都可以拿到

3. 一个组件需要改变全局状态

4. 一个组件需要改变另一个组件的状态

## redux的核心API

### createStore()

- 作用: 创建包含指定reducer的store对象

- 编码:
```react
import {createStore} from 'redux'
import counter from './reducers/counter'
const store = createStore(counter)
```

### store对象

- 作用: 

- redux库最核心的管理对象

- 它内部维护着:

  - state

  - reducer

- 核心方法:
```react
getState()
dispatch(action)
subscribe(listener)
```
- 编码:
```react
store.getState()

store.dispatch({type:'INCREMENT', number})

store.subscribe(render)
```

### applyMiddleware()

- 作用:
  - 应用上基于redux的中间件(插件库)

- 编码:

```react
import {createStore, applyMiddleware} from 'redux'
import thunk from 'redux-thunk'  // redux异步中间件
const store = createStore(
  counter,
  applyMiddleware(thunk) // 应用上异步中间件
)
```

### combineReducers()

- 作用:
  - 合并多个reducer函数

- 编码:

```react
export default combineReducers({
  user,
  chatUser,
  chat
})
```

## redux的三个核心概念

### action

- 标识要执行行为的对象

- 包含2个方面的属性

  - type: 标识属性, 值为字符串, 唯一, 必要属性

  - xxx: 数据属性, 值类型任意, 可选属性

```react
const action = {
  type: 'INCREMENT',
  data: 2
}

// Action Creator(创建Action的工厂函数)
const increment = (number) => ({type: 'INCREMENT', data: number})
// 返回一个action对象，所以需要小括号包装一下
```

### reducer

- 根据老的state和action, 产生新的state的**纯函数**
- 在reducer定义state的初始值（以形参默认值的形式）

```react
export default function counter(state = 0, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + action.data
    case 'DECREMENT':
      return state - action.data
    default:
      return state
	}
}
```

- 注意

  - 返回一个新的状态

  - 不要修改原来的状态
  - 老DOM树和新DOM树，对比更新局部渲染
    - 所以都是用的setState，没有必要，也不应该覆盖旧的数据

### store

- 将state,action与reducer联系在一起的对象

- 如何得到此对象?

- ```react
  import {createStore} from 'redux'
  import reducer from './reducers'
  const store = createStore(reducer)
  //内部会第一次调用reducer，得到初始的state，所以：state的初始值是在reducer内部定义的
  ```

- 此对象的功能?

- ```react
  getState(): 得到state
  dispatch(action): 分发action, 触发reducer调用, 产生新的state
  subscribe(listener): 注册监听, 当产生了新的state时, 自动调用
  ```

## 参考模板

### 下载依赖包

- npm install --save redux

- redux/action-types.js 

```react
/*
action对象的type常量名称模块
*/
export const INCREMENT = 'increment'
export const DECREMENT = 'decrement'

```

-  redux/actions.js


```react
/*
action creator模块
 */
import {INCREMENT, DECREMENT} from './action-types'

export const increment = number => ({type: INCREMENT, data:number})
export const decrement = number => ({type: DECREMENT, data:number})

```

- redux/reducers.js

```react
/*
根据老的state和指定action, 处理返回一个新的state
 */
import {INCREMENT, DECREMENT} from '../constants/ActionTypes'

import {INCREMENT, DECREMENT} from './action-types'

export function counter(state = 0, action) {
  console.log('counter', state, action)
  switch (action.type) {
    case INCREMENT:
      return state + action.data
    case DECREMENT:
      return state - action.data
    default:
      return state
  }
}
```

- redux/store.js

```react
import {createStore} from 'redux'
import {counter} from './redux/reducers'

// 根据counter函数创建store对象
const store = createStore(counter)

export default store

```

- index.js
  - 订阅监听，一旦状态发生改变, 自动重新渲染

```react
import React from 'react'
import ReactDOM from 'react-dom'
//import {createStore} from 'redux'

import App from './components/app'
import store from './redux/store'
//import {counter} from './redux/reducers'

// 根据counter函数创建store对象
//const store = createStore(counter)

// 定义渲染根组件标签的函数
const render = () => {
  ReactDOM.render(
    <App store={store}/>,
    document.getElementById('root')
  )
}
// 初始化渲染
render()

// 注册(订阅)监听, 一旦状态发生改变, 自动重新渲染
store.subscribe(render)

```

-  components/app.jsx
   -  数据在app内，要进行redux的更新流程：把store作为prop传入即可
   -  得到state：`count = this.props.store.getState()`
      -  getState()返回的是直接的数据：由reducer定义的那个值
   -  更新state：
      -  工厂函数创建的action对象：`this.props.store.dispatch(actions.increment(number))`.
      -  直接定义的action对象：`this.props.store.dispatch({type:INCREMENT,data:number})`

```react
/*
应用组件
 */
import React, {Component} from 'react'
import PropTypes from 'prop-types'
//取出所有的子模块
import * as actions from '../redux/actions'

export default class App extends Component {
  static propTypes = {
    store: PropTypes.object.isRequired,
  }

  increment = () => {
    const number = this.refs.numSelect.value * 1
    this.props.store.dispatch(actions.increment(number))
  }

  decrement = () => {
    const number = this.refs.numSelect.value * 1
    this.props.store.dispatch(actions.decrement(number))
  }

  incrementIfOdd = () => {
    const number = this.refs.numSelect.value * 1

    let count = this.props.store.getState()
    if (count % 2 === 1) {
      this.props.store.dispatch(actions.increment(number))
    }
  }

  incrementAsync = () => {
    const number = this.refs.numSelect.value * 1
    setTimeout(() => {
      this.props.store.dispatch(actions.increment(number))
    }, 1000)
  }

  render() {
    return (
      <div>
        <p>
          click {this.props.store.getState()} times {' '}
        </p>
        <select ref="numSelect">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
        </select>{' '}
        <button onClick={this.increment}>+</button>
        {' '}
        <button onClick={this.decrement}>-</button>
        {' '}
        <button onClick={this.incrementIfOdd}>increment if odd</button>
        {' '}
        <button onClick={this.incrementAsync}>increment async</button>
      </div>
    )
  }
}
```

### 缺点

1. redux与react组件的代码耦合度太高

2. 编码不够简洁

## react-redux

### 理解

- 一个react插件库

- 专门用来简化react应用中使用redux

### React-Redux将所有组件分成两大类

1. UI组件

- 只负责 UI 的呈现，不带有任何业务逻辑

- 通过props接收数据(一般数据和函数)

- 不使用任何 Redux 的 API

- 一般保存在components文件夹下

2. 容器组件

- 负责管理数据和业务逻辑，不负责UI的呈现

- 使用 Redux 的 API

- 一般保存在containers文件夹下

### 相关API

### Provider

- 让所有组件都可以得到state数据

```react
<Provider store={store}>
     <App />
</Provider>
```

### connect()

- 用于包装 UI 组件生成容器组件

```react
import { connect } from 'react-redux'
   connect(
     mapStateToprops,
     mapDispatchToProps
)(Counter)
```

+ 调用 connect 函数返回了一个**高阶组件生成器**，而这个生成器会基于原始组件生成一个全新的组件，并给这个组件添加额外的 props。 
+ 在构造一个高阶组件生成器时，connect 最多接受 4 个参数，分别如下
  + [mapStateToProps(state, [ownProps]): stateProps]（类型：函数）：接受完整的 Redux状态树作为参数，返回当前组件相关部分的状态树，返回对象的所有  key  都会成为组件的 props。
  + [mapDispatchToProps(dispatch, [ownProps]): dispatchProps] （类型：对象或函数）：接受 Redux 的 dispatch 方法作为参数，返回当前组件相关部分的 action creator，并可以在这里将 action creator 与 dispatch 绑定，减少冗余代码。
  + [mergeProps(stateProps, dispatchProps, ownProps): props] （类型：函数）：如果指定这个函数，你将分别获得 mapStateToProps、mapDispatchToProps 返回值以及当前组件的props 作为参数，最终返回你期望的、完整的 props。
  + [options]（类型：对象）：可选的额外配置项，有以下两项。
    + [pure = true] （类型：布尔）：该值设为 true 时，将为组件添加 shouldComponentUpdate()
      生命周期函数，并对 mergeProps 方法返回的 props 进行浅层对比。
    + [withRef = false]（类型：布尔）：若设为 true，则为组件添加一个 ref 值，后续可
      以使用 getWrappedInstance() 方法来获取该 ref，默认为 false。

### mapStateToprops()

- 将外部的数据（即state对象）转换为UI组件的标签属性
  - 接受默认参数state
  - 将state的属性，转换为标签的属性

```react
const mapStateToprops = function (state) {
  return {
  value: state
  }
}

const mapStateToprops = state => ({count: state}) //小括号不能忘了
```

### mapDispatchToProps()

- 将分发action的函数转换为UI组件的标签属性

- 简洁语法可以直接指定为actions对象或包含多个action方法的对象

```react
// 向外暴露连接App组件的包装组件
export default connect(
  state => ({count: state}), //自动结构变成Counter的属性
  {increment, decrement}
  //increment：increment，一个是属性名（与组件引入的prop一致），一个是属性值（与action一致）
)(Counter)
```

## 使用react-redux

- 下载依赖包

`npm install --save react-redux`

- redux/action-types.js
  - 不变
- redux/actions.js
  - 不变
- redux/reducers.js
  - 不变

- index.js
  - 不需要订阅监听了
  - 把store传给provider

```react
import React from 'react'
import ReactDOM from 'react-dom'
import {createStore} from 'redux'
import {Provider} from 'react-redux'

import App from './containers/app'
import {counter} from './redux/reducers'

// 根据counter函数创建store对象
const store = createStore(counter)

// 定义渲染根组件标签的函数
ReactDOM.render(
  (
    <Provider store={store}>
      <App />
    </Provider>
  ),
  document.getElementById('root')
```

- components/counter.jsx
  - UI组件: 不包含任何redux API
  - 不在需要store的dispatch了，直接`this.props.increment(number)`

```react
/*
UI组件: 不包含任何redux API
 */
import React from 'react'
import PropTypes from 'prop-types'

export default class Counter extends React.Component {

  static propTypes = {
    count: PropTypes.number.isRequired,
    increment: PropTypes.func.isRequired,
    decrement: PropTypes.func.isRequired
  }

  increment = () => {
    const number = this.refs.numSelect.value * 1
    this.props.increment(number)
  }

  decrement = () => {
    const number = this.refs.numSelect.value * 1
    this.props.decrement(number)
  }

  incrementIfOdd = () => {
    const number = this.refs.numSelect.value * 1
    let count = this.props.count
    if (count % 2 === 1) {
      this.props.increment(number)
    }
  }

  incrementAsync = () => {
    const number = this.refs.numSelect.value * 1
    setTimeout(() => {
      this.props.increment(number)
    }, 1000)
  }

  render() {
    return (
      <div>
        <p>
          click {this.props.count} times {' '}
        </p>
        <select ref="numSelect">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
        </select>{' '}
        <button onClick={this.increment}>+</button>
        {' '}
        <button onClick={this.decrement}>-</button>
        {' '}
        <button onClick={this.incrementIfOdd}>increment if odd</button>
        {' '}
        <button onClick={this.incrementAsync}>increment async</button>
      </div>
    )
  }
}

```

- containters/app.jsx
  - connect()方法传递的对象，自动解构赋值变成Counter的属性
  - {...运算符}
  - 类比一下：`ReactDOM.render(<Person {...person}/>, document.getElementById('example1'))`

```react
/*
包含Counter组件的容器组件
 */
import React from 'react'
// 引入连接函数
import {connect} from 'react-redux'
// 引入action函数
import {increment, decrement} from '../redux/actions'

import Counter from '../components/counter'

// 向外暴露连接App组件的包装组件
export default connect(
  state => ({count: state}), //自动结构变成Counter的属性
  {increment, decrement}
  //increment：increment，一个是属性名（与组件引入的prop一致），一个是属性值（与action一致）
)(Counter)
```

### 结果：

![1547037866613](F:\OneDrive\JS\纲略合集\assets\1547037866613.png)

- provider 有store属性，里面有着store的全部方法
- App组件，经过connect()包装，获得了传入的属性，类比上次包装MyNavLink组件，通过包装组件，传入自己定义的属性

### 问题

1. redux默认是不能进行异步处理的
2. 应用中又需要在redux中执行异步任务(ajax, 定时器)

## redux异步编程

- 下载redux插件(异步中间件)

`npm install --save redux-thunk`

- index.js
  - 引用中间件

```react
import {createStore, applyMiddleware} from 'redux'
import thunk from 'redux-thunk'
// 根据counter函数创建store对象
const store = createStore(
  counter,
  applyMiddleware(thunk) // 应用上异步中间件
)
```

-  redux/actions.js
  - 同步的actions返回的都是一个对象
    - 默认只能返回一个对象
  - 一异步的actions返回的是一个函数
    - 在异步actoin函数内，最好调用一个匹配的同步action
    - 有了thunk中间件，才可以支持返回一个函数
    - 本质上：是函数的形式是为了执行异步操作，最后还是通过dispatch分发同步action

```react
// 异步action creator(返回一个函数)
export const incrementAsync = number => {
  return dispatch => {
    setTimeout(() => {
      dispatch(increment(number))
    }, 1000)
  }
}

//小括号简洁语法，但是因为结构本身就比较复杂，一般还是特地加一个return，用于强调
export const incrementAsync = number => （
  dispatch => {
    setTimeout(() => {
      dispatch(increment(number))
    }, 1000)
  }
）
```

- components/counter.jsx

```react
incrementAsync = () => {
  const number = this.refs.numSelect.value*1
  this.props.incrementAsync(number)
}
```

- containers/app.jsx

```react
import {increment, decrement, incrementAsync} from '../redux/actions'
// 向外暴露连接App组件的包装组件
export default connect(
  state => ({count: state}),
  {increment, decrement, incrementAsync}
)(Counter)
```

## 使用上redux调试工具

```
npm install --save-dev redux-devtools-extension
```

- index.js

```react
import { composeWithDevTools } from 'redux-devtools-extension'

const store = createStore(
  counter,
  composeWithDevTools(applyMiddleware(thunk)) 
)
```

![1547045446583](F:\OneDrive\JS\纲略合集\assets\1547045446583.png)

- 左边可以查看到reducer的调用

### 改造comments

- shift()会影响原数组，所以用`[action.data,...state]`
- splice返回的是被删除的元素，所以用`state.filter((comment,index)=> index!==action.data)`

## 多个reducer怎么处理

- redux/reducers.js

```react
import {combineReducers} from 'redux'

import {...} from './action-types'

const initComments = []

function comments(state = initComments, action) {
  switch ...
}
function counter(state = initComments, action) {
  switch ...
}  

export default combineReducers({
  comments,
  counter
})
  
//redux向外暴露的state结构：  
//{counter:2,comments:[]}
//所以app也要做响应的改变  
```

- redux/store.js

```react
//视作形参
import reducers from './reducers'

// 根据counter函数创建store对象
export default createStore(
  reducers,
  composeWithDevTools(applyMiddleware(thunk)) // 应用上异步中间件
)
```

- app.js

- ```react
  export default connect(
    state=>{comments:state.comments},
    {addComments,deleteComments,getComments}
  )(App)
  ```

## 相关重要知识: 纯函数和高阶函数

### 纯函数

- 一类特别的函数: 只要是同样的输入，必定得到同样的输出

- 必须遵守以下一些约束  

1. 不得改写参数

2. 不能调用系统 I/O 的API

3. 能调用Date.now()或者Math.random()等不纯的方法  

4. reducer函数必须是一个纯函数

### 高阶函数

- 理解: 一类特别的函数

- 情况1: 参数是函数

- 情况2: 返回是函数

### 常见的高阶函数: 

- 定时器设置函数

- 数组的map()/filter()/reduce()/find()/bind()

- react-redux中的connect函数

- 作用: 
  - 能实现更加动态, 更加可扩展的功能

# 9. React 编程思想

# 10. React Hooks

https://juejin.im/post/5be3ea136fb9a049f9121014

https://juejin.im/post/5bfcbc83e51d450fb3263a35

https://juejin.im/post/5be6150551882511a8526955

### 但是什么是钩子（Hook）?

- 钩子是可以让你与**React状态以及函数式组件的生命周期特性**“挂钩”的函数。钩子是为了让你**抛弃**类使用React的，**所以它不能在类中运行**。（我们[不推荐](https://react.docschina.org/docs/hooks-intro.html#gradual-adoption-strategy)你立即重写已经存在的组件，但是如果你喜欢的话可以在新的组件中开始使用钩子。）
  - Hook不能在类中运行，也不能在类的子组件中，但是类，却可以运行再Hook 函数式组件的 子组件中
- React提供了少量内置的钩子，如`useState`。你也可以创建自己的钩子在不同的组件之间复用有状态的行为。我们先来看一下内置的钩子。
- *Hooks*是React v16.7.0-alpha中加入的新特性。它可以让你在class以外使用state和其他React特性。
- 有了Hooks，你可以以一种更加强大的方式将 props, state, context, refs 和生命周期整合起来。
- **Hooks允许您根据相关部分(例如设置订阅或获取数据)将一个组件分割成更小的函数**，而不是强制基于生命周期方法进行分割。您还可以选择使用一个reducer来管理组件的本地状态，以使其更加可预测。

## 状态钩子（State Hook）

- ```react
  import { useState } from 'react';
  
  function Example() {
    // Declare a new state variable, which we'll call "count"
    // a pair 数组的解构赋值，count 的初始值由 useState 初始化
    const [count, setCount] = useState(0);
  
    return (
      <div>
        <p>You clicked {count} times</p>
        <button onClick={() => setCount(count + 1)}>
          Click me
        </button>
      </div>
    );
  }
  ```

- ![1552531385655](F:\OneDrive\JS\纲略合集\assets\1552531385655.png) you clicked 8 times

- 在这里, `useState`是一个*钩子（Hook）* （稍后我们将会谈及它的含义）。

- 我们在一个函数式组件中调用它，为这个组件增加一些内部的状态。React将会在**下一次渲染前保存此状态**。 

  - 函数式组件没有生命周期函数，但是不代表它没有生命周期

- **What does calling useState do?** It declares a “state variable”. Our variable is called `count`but we could call it anything else, like `banana`. This is a way to “**preserve**” some values between the function calls — `useState` is a new way to use the exact same capabilities that `this.state` provides in a class. Normally, variables “disappear” when the function exits but state variables are preserved by React.

- `useState`唯一的**参数就是初始状态（initial state）**。在上面的例子中,因为我们的计数器从零开始所以它是`0`。这里的状态与`this.state`不同，它不必是一个对象— 如果你想这么做，当然也可以。初始状态参数只在第一次渲染中被使用。
- `useState`返回一对值：当前的状态（state value）和一个可以更新状态的函数。你可以在事件处理程序（event handler）中或其他地方调用这个函数。 它与类组件中的`this.setState`类似，但不能将新旧状态进行合并。（我们在[使用状态钩子](https://react.docschina.org/docs/hooks-state.html)中展示了一个将`useState`和`this.state`进行对比的例子。）
- You might be wondering: why is `useState` not named `createState` instead?

  - “Create” wouldn’t be quite accurate because the state is only created the first time our component renders. During the next renders, `useState` gives us the current state. Otherwise it wouldn’t be “state” at all! There’s also a reason why Hook names *always* start with `use`. We’ll learn why later in the [Rules of Hooks](https://react.docschina.org/docs/hooks-rules.html).

### 声明多个状态变量

- 你可以在一个组件中多次使用状态钩子:

  ```REACT
  function ExampleWithManyStates() {
    // 声明多个状态变量！
    const [age, setAge] = useState(42);
    const [fruit, setFruit] = useState('banana');
    const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);
    // ...
  }
  ```

- 通过调用`useState`我们声明了一些状态变量，我们可以使用[数组解构](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring)语法赋予这些状态变量不同的名字。

- When we declare a state variable with `useState`, it returns a pair — an array with two items. The first item is the current value, and the second is a function that lets us update it. Using `[0]`and `[1]` to access them is a bit confusing because they have a specific meaning. This is why we use array destructuring instead.

- 这些名字不是`useState` API的一部分。 相反，当你多次调用`useState`时，**React假定你在每一次渲染中以相同的顺序调用它们**。我们会在之后再来解释为什么这样可以运行以及在什么时候起作用。

- You might be curious how React knows which component `useState` corresponds to since we’re not passing anything like `this` back to React. We’ll answer [this question](https://react.docschina.org/docs/hooks-faq.html#how-does-react-associate-hook-calls-with-components) and many others in the FAQ section.

- You **don’t have to** use many state variables. State variables can hold objects and arrays just fine, so you can still group related data together. However, unlike `this.setState` in a class, updating a state variable always *replaces* it instead of merging it.

### Reading State

- When we want to display the current count in a class, we read `this.state.count`
- In a function, we can use `count` directly，因为 state 就是函数内部的一个变量，作用域内可以随意使用

### Updating State

- In a class, we need to call `this.setState()` to update the `count` state

- In a function, we already have `setCount` and `count` as variables so we don’t need `this`:

  ```react
  <button onClick={() => setCount(count + 1)}>
    Click me
  </button>
  ```

  - 在作用域内调用setXXX()，传入state，即可更新

+ 同时更新多个 state 只能分别调用
+ 类似与setState，直接更改state的值，组件不会重新渲染，也不会触发相应的useEffect
  + 反过来说，再useEffect里面setState有可能会导致无线循环
+ 而且，虽然使用const 解构，但是state和setState都是可以直接更改的
+ 如果state是一个对象，先使用assign方法更新闭包里的state，再setState
  + setXxx 钩子 不会自动合并对象，而是会直接覆盖
  + 即使state不是闭包内的，而是真正的state也ok，直接改变state的值，然后setState一个相同的值，通知渲染，这样是行不通的，state没有发生改变，不会进行渲染

#### 当State是Object时

+ ```react
    const [obj,setObj] = useState({
      name:'mary',
      age:20
    })
     useEffect(() => {
      const newObj = Object.assign(obj,{age:29}) // newObj 和 obj 引用相同
      newObj.age = 30
      console.log(newObj)
      console.log(obj) // 传递一个属性不同，引用相同的obj，不会重新渲染
      setObj(obj)
    },[])  
  
     useEffect(() => {
      
      setObj({name:'mary',age:29}) // 一个属性完全相同的新obj，会重新渲染
      console.log(obj)
    },[]) 
  
    useEffect(() => {
      console.log(obj)
      setObj({...obj,age:29}) // 使用...运算符简化克隆
      console.log(obj)
    },[])
  ```

+ 

## 副作用钩子（Effect Hook）

- 你可能之前已经在React中执行过获取数据，订阅或者手动改变DOM。我们称这些操作为“副作用（side effects）”（或者简称为“作用（effects）”），因为它们可以**影响其他的组件并且不能在渲染中完成**。

- 副作用钩子, `useEffect`, 为函数式组件带来执行副作用的能力。它与类组件中的`componentDidMount` ，`componentDidUpdate`和 `componentWillUnmount`具有相同的用途，但是**被统一为一个API**。（我们在[使用副作用钩子](https://react.docschina.org/docs/hooks-effect.html)中展示了一个将`useEffect`和这些方法进行对比的例子。）

- 举个例子，这个组件在React更新DOM之后设置文档的标题：

  ```REACT
  import { useState, useEffect } from 'react';
  
  function Example() {
    const [count, setCount] = useState(0);
  
    // 类似于 componentDidMount 和 componentDidUpdate:
    useEffect(() => {
      // 使用浏览器API更新文档标题
      document.title = `You clicked ${count} times`;
    });
  
    return (
      <div>
        <p>You clicked {count} times</p>
        <button onClick={() => setCount(count + 1)}>
          Click me
        </button>
      </div>
    );
  }
  ```

- 当你调用`useEffect`,就是告诉React在**刷新DOM之后运行你的副作用函数**。副作用函数在组件中声明，所以可以使用组件的状态（state）和属性（props）。**React默认在每一次渲染后运行副作用函数**——*包括*第一次渲染。(与类组件的生命周期函数的对比请看[使用副作用钩子](https://react.docschina.org/docs/hooks-effect.html)。)

### 不需要清理的effects

+ 有时我们想要 **在 React 更新过 DOM 之后执行一些额外的操作。** 比如网络请求、手动更新 DOM 、以及打印日志都是常见的不需要清理的 effects。

+ 在 **class 组件**中，`render` 方法本身不应该导致 side effects。`render` 方法太早了————我们通常会在 React 更新过 DOM *之后* 再执行 effect。

+ 这也是我们在 class 组件中，把 side effects 放在 `componentDidMount` 和 `componentDidUpdate`中的原因。

+ **useEffect 做了什么？** 通过这个 Hook，React 知道你想要这个组件在每次 render 之后做些事情。React 会记录下你传给 `useEffect` 的这个方法（我们可以把它看做我们的 `effect` ），然后在进行了 DOM 更新之后调用这个方法。在这个 effect 中，我们设置 document title，但我们同样也可以进行数据获取或是调用其它必要的 API。

+ **为什么 useEffect 在组件内部调用？** 将 `useEffect` 放在一个组件内部，可以让我们在 effect 中，即可获得对 `count` state（或其它 props）的访问，而不是使用一个特殊的 API 去获取它。Hooks 使用了 JavaScript 的闭包，从而避免了引入 React 特有的 API 来解决 JavaScript 已经提供解决方案。

+ **useEffect 是不是在每次 render 之后都会调用？** 是的！默认情况下，它会在第一次 render *和*之后的每次 update 后运行。（我们会在之后讨论如何[优化](https://react.docschina.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects)。）比起 “mounting” 和 “updating”，effect 在“每次 render”之后调用，想必会更容易理解。React 保证每次运行 effects 之前 DOM 已经更新了。

  ```react
  function Example() {
    const [count, setCount] = useState(0);
  
    useEffect(() => {
      document.title = `You clicked ${count} times`;
    });
  ```

+ 我们声明了 `count` state，然后我们告诉 React 我们将会用到一个 effect。我们将一个函数传递给 `useEffct` Hook。我们传递的这个方法 *就是* 我们的 effect（副作用）。在这个 effect 里，我们使用 `document.title` API 设置了 document title。同时，由于 effect 在这个函数的作用域内，我们也可以在 effect 中读取到最新的 `count`。当 React 渲染组件时，它会记录下我们使用的 effect，然后再更新完 DOM 后调用它。这发生在每一次 render 之后，包括最开始的一次。

+ 有经验的 JavaScript 开发者也许已经发现，在每次 render 的时候，我们传递给 `useEffect` 的方法都是全新的。这是故意的。事实上，这正是我们可以在 effect 内部读取到 `count` 值，并且不用担心 `count` 值过期的原因。每当我们重新 render 的时候，我们都会使用一个 *不同的* effect，替换掉之前的哪一个。在某种程度上，这使得 effect 表现得更像是 render 结果的一部分————每个 effect “属于”一个特定的 render。我们会在[这一节的后面](https://react.docschina.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update)更清晰地了解到这么做的作用。

+ 不像 `componentDidMount` 或者 `componentDidUpdate`，`useEffect` 中使用的 effect **并不会阻滞浏览器渲染页面**。这让你的 app 看起来更加流畅。尽管大多数 effect 不需要同步调用。但是在一些不常见的情况下你也许需要他们同步调用（比如计算元素尺寸），我们提供了一个单独的 [`useLayoutEffect`](https://react.docschina.org/docs/hooks-reference.html#uselayouteffect) 来达成这样的效果。它的 API 和 `useEffect` 是相同的。

### 需要清理的effects

- 在 React class 中，典型的做法是在 `componentDidMount` 里创建订阅，然后在 `componentWillUnmount` 中清除它。

  ```react
    componentDidMount() {
      ChatAPI.subscribeToFriendStatus(
        this.props.friend.id,
        this.handleStatusChange
      );
    }
  
    componentWillUnmount() {
      ChatAPI.unsubscribeFromFriendStatus(
        this.props.friend.id,
        this.handleStatusChange
      );
    }
  ```

  - 注意 `componentDidMount` 和 `componentWillUnmount` 中我们需要重复同一段代码。生命周期要求我们不得不拆分这段逻辑，就算从概念上讲他们是从属于同一个 effect 的。

- 副作用函数可以**通过返回一个函数来指定如何“回收”它们**，如果你的 effect 返回了一个函数，React 将会在清理时运行它：举个例子，这个组件使用了一个副作用函数来订阅一个朋友的在线状态，通过取消订阅来回收：

  ```react
  import { useState, useEffect } from 'react';
  
  function FriendStatus(props) {
    const [isOnline, setIsOnline] = useState(null);
  
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
  
    useEffect(() => {
      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
  
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
      };
    });
  
    if (isOnline === null) {
      return 'Loading...';
    }
    return isOnline ? 'Online' : 'Offline';
  }
  ```

- 在这个例子中，**当组件被卸载时，React会在由随后的渲染引起的副作用函数运行之前取消对`ChatAPI`的订阅。**（如果有需要的话，可以用这个方法[告诉React跳过重订阅](https://react.docschina.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects)当传给`ChatAPI`的`props.friend.id`没有改变时。）

- **React 究竟在什么时候清理 effect？** React 在每次组件 unmount 的时候执行清理。然而，正如我们之前了解的那样，effect 会在每次 render 时运行，而不是仅仅运行一次。这也就是为什么 React *也* 会在下次运行 effect 之后清理上一次 render 中的 effect。我们会在接下来讨论[为什么这可以帮助避免 bug](https://react.docschina.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update) 以及[如何有选择的运行 effect 以避免出现性能问题](https://react.docschina.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects)

+ 我们没必要在 effect 中返回一个具名函数。我们在这里称它为 `清理` 就可以表明它的目的，但你也可以返回一个箭头函数或者给它起一个名字。

### 使用多个userEffect

- 像使用`useState`一样,你可以在一个组件中使用多个副作用：

  ```react
  function FriendStatusWithCounter(props) {
    const [count, setCount] = useState(0);
    useEffect(() => {
      document.title = `You clicked ${count} times`;
    });
  
    const [isOnline, setIsOnline] = useState(null);
    useEffect(() => {
      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
      };
    });
  
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    // ...
  ```

- 有了钩子，你可以在组件中按照代码块的相关性组织副作用，而不是基于生命周期方法强制进行切分。

### Why Effects Run on Each Update

+ If you’re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let’s look at a practical example to see why this design helps us create components with fewer bugs.

  ```react
    componentDidMount() {
      ChatAPI.subscribeToFriendStatus(
        this.props.friend.id,
        this.handleStatusChange
      );
    }
  
    componentWillUnmount() {
      ChatAPI.unsubscribeFromFriendStatus(
        this.props.friend.id,
        this.handleStatusChange
      );
    }
  ```

+ **But what happens if the friend prop changes** while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.

+ In a class component, we would need to add `componentDidUpdate` to handle this case:

  ```react
    componentDidMount() {
      ChatAPI.subscribeToFriendStatus(
        this.props.friend.id,
        this.handleStatusChange
      );
    }
  
    componentDidUpdate(prevProps) {
      // Unsubscribe from the previous friend.id
      ChatAPI.unsubscribeFromFriendStatus(
        prevProps.friend.id,
        this.handleStatusChange
      );
      // Subscribe to the next friend.id
      ChatAPI.subscribeToFriendStatus(
        this.props.friend.id,
        this.handleStatusChange
      );
    }
  
    componentWillUnmount() {
      ChatAPI.unsubscribeFromFriendStatus(
        this.props.friend.id,
        this.handleStatusChange
      );
    }
  ```

+ Forgetting to handle `componentDidUpdate` properly is a common source of bugs in React applications.

+ Now consider the version of this component that **uses Hooks**:

  ```react
  function FriendStatus(props) {
    // ...
    useEffect(() => {
      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
      };
    });
  ```

+ There is no special code for handling updates because `useEffect` handles them **by default**. 

+ It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:

  ```js
  // Mount with { friend: { id: 100 } } props
  ChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Run first effect
  
  // Update with { friend: { id: 200 } } props
  ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Clean up previous effect
  ChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Run next effect
  
  // Update with { friend: { id: 300 } } props
  ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Clean up previous effect
  ChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Run next effect
  
  // Unmount
  ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Clean up last effect
  ```

### Optimizing Performance by Skipping Effects

+ In some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with `prevProps` or `prevState` inside `componentDidUpdate`:

  ```react
  componentDidUpdate(prevProps, prevState) {
    if (prevState.count !== this.state.count) {
      document.title = `You clicked ${this.state.count} times`;
    }
  }
  ```

+ **This requirement is common enough that it is built into the `useEffect` Hook API.** You can tell React to **skip** applying an effect if certain values haven’t changed between re-renders. To do so, pass an array as an optional second argument to `useEffect`:

  ```react
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  }, [count]); // Only re-run the effect if count changes
  ```

  + In the example above, we pass `[count]` as the second argument. What does this mean? If the `count` is `5`, and then our component re-renders with `count` still equal to `5`, React will compare `[5]` from the previous render and `[5]` from the next render. Because **all items in the array** are the same (`5 === 5`), React would skip the effect. That’s our optimization.
  + When we render with `count` updated to `6`, React will compare the items in the `[5]` array from the previous render to items in the `[6]` array from the next render. This time, React will re-apply the effect because `5 !== 6`. **If there are multiple items in the array, React will re-run the effect even if just one of them is different.**
  + 深度比较还是浅度比较？

+ This also works for effects that have a cleanup phase:

  ```react
  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  }, [props.friend.id]); // Only re-subscribe if props.friend.id changes
  ```

+ In the future, the second argument might get added automatically by a build-time transformation.

+ If you use this optimization, make sure the array includes **any values from the outer scope that change over time and that are used by the effect**. Otherwise, your code will reference stale values from previous renders. We’ll also discuss other optimization options in the [Hooks API reference](https://react.docschina.org/docs/hooks-reference.html).

+ If you want to run an effect and clean it up **only once** (on mount and unmount), you can pass an empty array (`[]`) as a second argument. This tells React that your effect doesn’t depend on *any* values from props or state, so it never needs to re-run. 

  + This isn’t handled as a special case — it follows directly from how the inputs array always works. While passing `[]` is closer to the familiar `componentDidMount` and `componentWillUnmount` mental model, we suggest not making it a habit because it often leads to bugs, [as discussed above](https://react.docschina.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update). Don’t forget that React defers running `useEffect` until after the browser has painted, so doing extra work is less of a problem.

## Hooks 规范

- 钩子就是强制实现了两条额外规则的Javascript函数：
  - 只能在**顶层**调用钩子。不要在循环，控制流和嵌套的函数中调用钩子。
    - Instead, always use Hooks at the top level of your React function. By following this rule, you ensure that Hooks are called in the same order each time a component renders. That’s what allows React to correctly preserve the state of Hooks between multiple `useState` and `useEffect` calls. (If you’re curious, we’ll explain this in depth [below](https://react.docschina.org/docs/hooks-rules.html#explanation).)
  - 只能从React的**函数式组件**中调用钩子。不要在常规的JavaScript函数中调用钩子。（此外，你也可以在你的自定义钩子中调用钩子。我们马上就会讲到它。）
    - By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.

### Explanation

+ As we [learned earlier](https://react.docschina.org/docs/hooks-state.html#tip-using-multiple-state-variables), we can use multiple State or Effect Hooks in a single component:

  ```react
  function Form() {
    // 1. Use the name state variable
    const [name, setName] = useState('Mary');
  
    // 2. Use an effect for persisting the form
    useEffect(function persistForm() {
      localStorage.setItem('formData', name);
    });
  
    // 3. Use the surname state variable
    const [surname, setSurname] = useState('Poppins');
  
    // 4. Use an effect for updating the title
    useEffect(function updateTitle() {
      document.title = name + ' ' + surname;
    });
  
    // ...
  }
  ```

+ So how does React know which state corresponds to which `useState` call? The answer is that **React relies on the order in which Hooks are called**. Our example works because the order of the Hook calls is the same on every render:

+ ```react
  // ------------
  // First render
  // ------------
  useState('Mary')           // 1. Initialize the name state variable with 'Mary'
  useEffect(persistForm)     // 2. Add an effect for persisting the form
  useState('Poppins')        // 3. Initialize the surname state variable with 'Poppins'
  useEffect(updateTitle)     // 4. Add an effect for updating the title
  
  // -------------
  // Second render
  // -------------
  useState('Mary')           // 1. Read the name state variable (argument is ignored)
  useEffect(persistForm)     // 2. Replace the effect for persisting the form
  useState('Poppins')        // 3. Read the surname state variable (argument is ignored)
  useEffect(updateTitle)     // 4. Replace the effect for updating the title
  
  // ...
  ```

+ As long as the order of the Hook calls is the same between renders, React can associate some local state with each of them. But what happens if we put a Hook call (for example, the `persistForm` effect) inside a condition?

  ```react
  // 🔴 We're breaking the first rule by using a Hook in a condition
    if (name !== '') {
      useEffect(function persistForm() {
        localStorage.setItem('formData', name);
      });
    }
  ```

+ The `name !== ''` condition is `true` on the first render, so we run this Hook. However, on the next render the user might clear the form, making the condition `false`. Now that we skip this Hook during rendering, the order of the Hook calls becomes different:

  ```react
  useState('Mary')           // 1. Read the name state variable (argument is ignored)
  // useEffect(persistForm)  // 🔴 This Hook was skipped!
  useState('Poppins')        // 🔴 2 (but was 3). Fail to read the surname state variable
  useEffect(updateTitle)     // 🔴 3 (but was 4). Fail to replace the effect
  ```

+ React wouldn’t know what to return for the second `useState` Hook call. React expected that the second Hook call in this component corresponds to the `persistForm` effect, just like during the previous render, but it doesn’t anymore. From that point, every next Hook call after the one we skipped would also shift by one, leading to bugs.

+ **This is why Hooks must be called on the top level of our components.** If we want to run an effect conditionally, we can put that condition *inside* our Hook:

  ```react
    useEffect(function persistForm() {
      // 👍 We're not breaking the first rule anymore
      if (name !== '') {
        localStorage.setItem('formData', name);
      }
    });
  ```

+ **Note that you don’t need to worry about this problem if you use the provided lint rule.**But now you also know *why* Hooks work this way, and which issues the rule is preventing.

## 自定义Hooks

- 有时你希望在组件之间复用一些状态逻辑。在之前有两种流行的解决方案：[高阶组件](https://react.docschina.org/docs/higher-order-components.html) and [渲染属性](https://react.docschina.org/docs/render-props.html)。现在你可以利用自定义钩子做到这些而不用在你的组件树中添加更多的组件。

- 在此之前，我们展示了一个`FriendStatus` 组件，它可以调用`useState`和`useEffect`钩子来订阅一个朋友的在线状态。假设我们想要在其他的组件中复用这个订阅逻辑。

- 首先，我们要把这个逻辑抽取到名为`useFriendStatus`的自定义钩子中：

  ```react
  import { useState, useEffect } from 'react';
  
  function FriendStatus(props) {
    const [isOnline, setIsOnline] = useState(null);
  
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
  
    useEffect(() => {
      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
      };
    });
  
    if (isOnline === null) {
      return 'Loading...';
    }
    return isOnline ? 'Online' : 'Offline';
  }
  ```

- 这个钩子需要一个`friendID`作为参数，返回你的朋友是否在线。

- Now let’s say that our chat application also has a contact list, and we want to render names of online users with a green color. We could copy and paste similar logic above into our `FriendListItem` component but it wouldn’t be ideal:

  ```react
  import { useState, useEffect } from 'react';
  
  function FriendListItem(props) {
    const [isOnline, setIsOnline] = useState(null);
  
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
  
    useEffect(() => {
      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
      };
    });
  
    return (
      <li style={{ color: isOnline ? 'green' : 'black' }}>
        {props.friend.name}
      </li>
    );
  }
  ```

- Instead, we’d like to share this logic between `FriendStatus` and `FriendListItem`.

- Traditionally in React, we’ve had two popular ways to share stateful logic between components: [render props](https://react.docschina.org/docs/render-props.html) and [higher-order components](https://react.docschina.org/docs/higher-order-components.html). We will now look at how Hooks solve many of the same problems without forcing you to add more components to the tree.

### Extracting a Custom Hook

+ When we want to share logic between two JavaScript functions, we extract it to a third function. Both components and Hooks are functions, so this works for them too!

+ **A custom Hook is a JavaScript function whose name starts with ”use” and that may call other Hooks.** For example, `useFriendStatus` below is our first custom Hook:

  ```react
  import { useState, useEffect } from 'react';
  
  function useFriendStatus(friendID) {
    const [isOnline, setIsOnline] = useState(null);
  
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
  
    useEffect(() => {
      ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
      return () => {
        ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
      };
    });
  
    return isOnline;
  }
  ```

+ There’s nothing new inside of it — the logic is copied from the components above. Just like in a component, make sure to only call other Hooks unconditionally at the top level of your custom Hook.

+ Unlike a React component, a custom Hook doesn’t need to have a specific signature. We can decide what it takes as arguments, and what, if anything, it should return. In other words, it’s just like a normal function. Its name should always start with `use` so that you can tell at a glance that the [rules of Hooks](https://react.docschina.org/docs/hooks-rules.html) apply to it.

- The purpose of our `useFriendStatus` Hook is to subscribe us to a friend’s status. This is why it takes `friendID` as an argument, and returns whether this friend is online

### Using a Custom Hook

- In the beginning, our stated goal was to remove the duplicated logic from the `FriendStatus`and `FriendListItem` components. Both of them want to know whether a friend is online.

- 现在，我们可以同时在两个组件中使用它：

  ```react
  // 函数式组件一
  function FriendStatus(props) {
    const isOnline = useFriendStatus(props.friend.id);
  
    if (isOnline === null) {
      return 'Loading...';
    }
    return isOnline ? 'Online' : 'Offline';
  }
  // 函数式组件二
  function FriendListItem(props) {
    const isOnline = useFriendStatus(props.friend.id);
  
    return (
      <li style={{ color: isOnline ? 'green' : 'black' }}>
        {props.friend.name}
      </li>
    );
  }
  ```

- **Is this code equivalent to the original examples?** Yes, it works in exactly the same way. If you look closely, you’ll notice we didn’t make any changes to the behavior. All we did was to extract some common code between two functions into a separate function.

- 自定义钩子更多的**是一个约定(convention)**而不是特性。如果一个函数的名字以 ”`use`” 开头并且**调用了其他的钩子**，我们就称它为自定义钩子。`useSomething`的命名约定方便语法检查插件找到代码中钩子的错误使用。

- **Do two components using the same Hook share state?**，NO，两个组件中的状态是完全独立的。钩子只复用状态逻辑而不是状态本身。事实上，每一次调用钩子都会得到一个完全孤立的状态——所以你甚至可以在同一个组件中使用两次相同的自定义钩子。

- **How does a custom Hook get isolated state?** Each *call* to a Hook gets isolated state. Because we call `useFriendStatus` directly, from React’s point of view our component just calls `useState` and `useEffect`. And as we [learned](https://react.docschina.org/docs/hooks-state.html#tip-using-multiple-state-variables) [earlier](https://react.docschina.org/docs/hooks-effect.html#tip-use-multiple-effects-to-separate-concerns), we can call `useState` and `useEffect`many times in one component, and they will be completely independent.
- 自定义钩子可以覆盖非常多的用例，像**表单处理，动画，声明式订阅，定时器**，还有很多我们还没有考虑到的。我们非常激动能够看到React社区提出的自定义钩子。

### Pass Information Between Hooks

+ Since Hooks are functions, we can pass information between them.

+ To illustrate this, we’ll use another component from our hypothetical chat example. This is a chat message recipient picker that displays whether the currently selected friend is online:

  ```react
  const friendList = [
    { id: 1, name: 'Phoebe' },
    { id: 2, name: 'Rachel' },
    { id: 3, name: 'Ross' },
  ];
  
  function ChatRecipientPicker() {
    const [recipientID, setRecipientID] = useState(1);
    const isRecipientOnline = useFriendStatus(recipientID);
  
    return (
      <>
        <Circle color={isRecipientOnline ? 'green' : 'red'} />
        <select
          value={recipientID}
          onChange={e => setRecipientID(Number(e.target.value))}
        >
          {friendList.map(friend => (
            <option key={friend.id} value={friend.id}>
              {friend.name}
            </option>
          ))}
        </select>
      </>
    );
  }
  ```

+ We keep the currently chosen friend ID in the `recipientID` state variable, and update it if the user chooses a different friend in the `<select>` picker.

+ Because the `useState` Hook call gives us the latest value of the `recipientID` state variable, we can pass it to our custom `useFriendStatus` Hook as an argument:

  ```react
    const [recipientID, setRecipientID] = useState(1);
    const isRecipientOnline = useFriendStatus(recipientID);
  ```

+ This lets us know whether the *currently selected* friend is online. If we pick a different friend and update the `recipientID` state variable, our `useFriendStatus` Hook will unsubscribe from the previously selected friend, and subscribe to the status of the newly selected one.

### useYourImagination()

+ Custom Hooks offer the flexibility of sharing logic that wasn’t possible in React components before. You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven’t considered. What’s more, you can build Hooks that are just as easy to use as React’s built-in features.

+ Try to resist adding abstraction too early. Now that function components can do more, it’s likely that the average function component in your codebase will become longer. This is normal — don’t feel like you *have to* immediately split it into Hooks. But we also encourage you to start spotting cases where a custom Hook could hide complex logic behind a simple interface, or help untangle a messy component.

+ For example, maybe you have a complex component that contains a lot of local state that is managed in an ad-hoc way. `useState` doesn’t make centralizing the update logic any easier so might you prefer to write it as a [Redux](https://redux.js.org/) reducer:

  ```js
  function todosReducer(state, action) {
    switch (action.type) {
      case 'add':
        return [...state, {
          text: action.text,
          completed: false
        }];
      // ... other actions ...
      default:
        return state;
    }
  }
  ```

+ Reducers are very convenient to test in isolation, and scale to express complex update logic. You can further break them apart into smaller reducers if necessary. However, you might also enjoy the benefits of using React local state, or might not want to install another library.

+ So what if we could write a `useReducer` Hook that lets us **manage the local state** of our component with a reducer? A simplified version of it might look like this:

  ```react
  function useReducer(reducer, initialState) {
    const [state, setState] = useState(initialState);
  
    function dispatch(action) {
      const nextState = reducer(state, action);
      setState(nextState);
    }
  
    return [state, dispatch];
  }
  ```

+ Now we could use it in our component, and let the reducer drive its state management:

  ```react
  function Todos() {
    const [todos, dispatch] = useReducer(todosReducer, []);
  
    function handleAddClick(text) {
      dispatch({ type: 'add', text });
    }
  
    // ...
  }
  ```

+ The need to manage local state with a reducer in a complex component is common enough that we’ve built the `useReducer` Hook right into React. You’ll find it together with other built-in Hooks in the [Hooks API reference](https://react.docschina.org/docs/hooks-reference.html).

## 其他钩子

+ built-in Hooks in React
+ [Basic Hooks](https://react.docschina.org/docs/hooks-reference.html#basic-hooks)
  - [`useState`](https://react.docschina.org/docs/hooks-reference.html#usestate)
  - [`useEffect`](https://react.docschina.org/docs/hooks-reference.html#useeffect)
  - [`useContext`](https://react.docschina.org/docs/hooks-reference.html#usecontext)
+ [Additional Hooks](https://react.docschina.org/docs/hooks-reference.html#additional-hooks)
  - [`useReducer`](https://react.docschina.org/docs/hooks-reference.html#usereducer)
  - [`useCallback`](https://react.docschina.org/docs/hooks-reference.html#usecallback)
  - [`useMemo`](https://react.docschina.org/docs/hooks-reference.html#usememo)
  - [`useRef`](https://react.docschina.org/docs/hooks-reference.html#useref)
  - [`useImperativeMethods`](https://react.docschina.org/docs/hooks-reference.html#useimperativemethods)
  - [`useMutationEffect`](https://react.docschina.org/docs/hooks-reference.html#usemutationeffect)
  - [`useLayoutEffect`](https://react.docschina.org/docs/hooks-reference.html#uselayouteffect)

- 使用[`useContext`](https://react.docschina.org/docs/hooks-reference.html#usecontext)可以订阅React context而不用引入嵌套：

  ```react
  function Example() {
    const locale = useContext(LocaleContext);
    const theme = useContext(ThemeContext);
    // ...
  }
  ```

- [`useReducer`](https://react.docschina.org/docs/hooks-reference.html#usereducer)则允许你使用一个reducer来管理一个复杂组件的局部状态（local state）：

  ```react
  function Todos() {
    const [todos, dispatch] = useReducer(todosReducer);
    // ...
  ```

### useRef

+ `const refContainer = useRef(initialValue);`

+ `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component.

+ A common use case is to access a child imperatively:

  ```react
  function TextInputWithFocusButton() {
    const inputEl = useRef(null);
    const onButtonClick = () => {
      // `current` points to the mounted text input element
      inputEl.current.focus();
    };
    return (
      <>
        <input ref={inputEl} type="text" />
        <button onClick={onButtonClick}>Focus the input</button>
      </>
    );
  }
  ```

+ Note that `useRef()` is useful for more than the `ref` attribute. It’s [handy for keeping any mutable value around](https://react.docschina.org/docs/hooks-faq.html#is-there-something-like-instance-variables) similar to how you’d use instance fields in classes.

+ 参数null，用于初始化对象的值，当获取到DOM节点后，对象的值也会自动更新

## Hooks FAQ

+ https://segmentfault.com/a/1190000017057144#articleHeader9
+ https://juejin.im/post/5be6150551882511a8526955
+ https://juejin.im/post/5c230aa2e51d4529355bc2e0
+ https://medium.com/@unbug/ive-completely-rewritten-two-projects-with-react-hooks-here-is-the-good-and-the-ugly-48c28a103f52

## Hooks 实践

### 接受props

+ ```react
  import React from 'react';
  import {connect} from 'react-redux'
  import PropTypes from 'prop-types';
  
  import './Header.less'
  
  function Header (props){
    return (
      <header className='n-back_header'>
        DUAL N-BACK N={props.playLevel}
      </header>
    );
  }
  
  Header.propTypes = {
    playLevel:PropTypes.number.isRequired
  };
  
  export default connect(
    (state)=>({
      playLevel:state.playInfo.playLevel,
    }),
    {}
  )(Header)
  ```

+ 以参数形式接受即可，class 的 props 自动变成组件的属性， 函数组件的 props 则是以参数形式，自动传入

### ref

+ 函数式组件，无法像 class 那样使用 ref ， 需要使用 useRef()
+ **你不能在函数式组件上使用 ref 属性**，因为它们没有实例，无法把ref对象作为实例的属性保存下来
+ 可能是为了保持一致性，useRef()返回一个对象，对象的.current属性才真是的DOM节点
+ ![1552564808864](F:\OneDrive\JS\纲略合集\assets\1552564808864.png) 

### state

+ 同时更新多个 state 只能分别调用？
+ state都是 constent 不可以使用 state++
+ // 这样是否ok呢？state 是常量，使用了 shift() 方法
+ 同步流中，上一行set ，下一行，是否已经是最新的状态？
+ 传入一个新的state

### useEffect

+ 逻辑要放在一个函数里面执行，虽然setTimeout也是要给函数，但还是要用箭头函数包一层，一方面结构更加清晰，另一方面可以保证正确的运行，因为setTimeout是一个运行函数，而不是定义函数

+ ```react
  useEffect(() => {
    // 准备时间 1000ms
    setTimeout(() => {
      randomActive()
      // 3000ms
      let randomInterval = setInterval(() => {
        
        // 判断是否需要继续游戏
        if(matchTime>4){
          // 游戏结束，清除定时器
          clearInterval(randomInterval)
  
          console.log(visualMatchCorrect,visualMatchMistake);
  
          // 调用游戏结算函数
          const playResult = {visualMatchCorrect,visualMatchMistake}
          const {playResultList} = props
          playSettlement(playResultList,playResult,playLevel)
          
          // 跳转到result界面
          props.history.push('/result')
        }else{
          // 继续游戏
          randomActive()
        }
      },3000)
    },1000)
  },[]) 
  ```


### Interval

+ https://overreacted.io/zh-hans/making-setinterval-declarative-with-react-hooks/
+ https://zhuanlan.zhihu.com/p/57239068
+ https://cloud.tencent.com/developer/article/1398858
+ 通过控制useInterval 的 delay 可以实现各种延时 定时 贝塞尔速度等
+ 如果需要使用多个setState，由于，对于state的引用一直时在闭包里的，如果使用...运算符会覆盖前面的set操作，所以需要在一开始 用...运算符做一个潜复制，然后每次set就改变复制的对象，最后在统一set给全局的state
+ 又或者是直接解构赋值，分别操作每个属性，最后合成新的对象，用于set