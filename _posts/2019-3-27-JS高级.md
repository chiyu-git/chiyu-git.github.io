---
layout: post
#标题配置
title:  Javascript Advanced Note
#时间配置
date:   2019-3-16 21:00:00 +0800
#大类配置
categories: document
#小类配置
tag: note front-end
---

* content
{:toc}





# 1. 基础总结深入

## 数据类型

### 分类

- 基本类型（值类型）

  - String: 任意字符串

  - Number: 任意的数字

  - boolean: true/false

  - undefined: undefined

  - null: null

- 引用类型（对象类型）

  - Object: 任意对象

  - Function: 一种特别的对象(可以执行)

  - Array: 一种特别的对象(数值下标, 内部数据是有序的)

### 判断

- typeof:

  - 可以判断: undefined/ 数值 / 字符串 / 布尔值 / function

  - 不能判断: null与object  object与array

- ```js
  typeof null //object
  typeof array //object
  ```

  - 返回的是数据类型的字符串表达，全都是小写
   - 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 `null` 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，`typeof null`就错误的返回了"`object"`。（[reference](http://www.2ality.com/2013/10/typeof-null.html)）
   - ECMAScript提出了一个修复（通过opt-in），但[被拒绝](http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null)。这将导致typeof null === 'object'。

- instanceof:
  - instanceof运算符用于测试**构造函数**的prototype属性是否出现在对象的原型链中的任何位置
  - 判断对象的是否是某个具体类（构造函数的实例）

- ===
  - 可以判断: undefined, null

  - 因为这两个类型都只有一个值

- `Object.prototype.toString.call(target) `
  - 返回固定字符串： [Object target类型]
  - `Object.prototype.toString.call(target).slice(8,-1)`，就可以返回准确的类型
  - Array.prototype也是数组，类似的Number.prototype是number类型的对象
  - 实例本身是没有`constructor`属性的，`constructor`属性在原型上，为了保持一致性，所以`Array.prototype`也是`Array`
  - ES5开始，可以检查Null 和 undefined

### undefined与null的区别?

- undefined代表**定义未赋值**
  - 注意，用未定义的变量是会报错的，未定义的属性是undefined

- `nulll`定义并赋值了, 只是值为`null`
- 什么时候给变量赋值为null呢?

  - 初始赋值, 表明将要赋值为对象

  - 结束前, 让对象成为垃圾对象(被浏览器的垃圾回收器回收)

### 严格区别变量类型与数据类型?

- **数据**的类型
  - 基本类型（五种基本类型）

  - 对象类型

- **变量**的类型(变量内存值的类型)
  - 基本类型: 保存就是基本类型的数据

  - 引用类型: 保存的是地址值（指向对象类型数据）

- `JS`是弱类型语言，全都是var声明变量，变量是没有类型的，判断的其实是变量保存的值的类型

## 数据、变量、内存

### **什么是数据?**

- 存储在内存中代表特定信息的'东东', 本质上是0101...

- 数据的特点: 可传递, 可运算

- 一切皆数据（基本数据、对象数据）

- 内存中所有**操作的目标**: **数据**
  - 算术运算

  - 逻辑运算

  - 赋值

  - 运行函数

### **什么是内存?**

- **内存条**通电后产生的可储存数据的空间(临时的)

- 内存产生和死亡: 内存条(电路版)==>通电==>产生内存空间==>存储数据==>处理数据==>断电==>内存空间和数据都消失

- 一块小内存的2个数据

  - 内部存储的数据

  - 地址值

- 内存分类

  - 栈: 全局变量/局部变量 （函数名本质上是一个变量名）

  - 堆: 对象（包括对象的属性、方法）

### **什么是变量?**

- 可变化的量, 由变量名和变量值组成

- 每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据

### **内存,数据, 变量三者之间的关系**

- 内存用来存储数据的临时空间

- 变量是内存的标识

- 数据赋值给变量是数据有了实际意义，仅仅是内存中存储着的“18”，可能是年龄，年份，时间等等，只有赋值给了变量才变得有意义



### 关于赋值与内存的问题

- var a = xxx, a内存中到底保存的是什么?
- `xxx`是**基本数据,** 保存的就是这个数据
- `xxx`是**对象**, 保存的是对象的地址值

- `xxx`是一个**变量**, 保存的`xxx`的内存内容(可能是基本数据, 也可能是地址值)

- 对象的赋值只能有一次，就是创建的时候，**其他变量想要获取同一个对象的地址值**，只能赋值变量，即使创建一个内容一模一样的对象，地址值也是不同的

- 关于引用变量赋值的问题

```js
var obj1 = {};
var obj2 = obj1; 
//这一步的操作是：把obj1保存的内容（{}的地址值）赋值给obj2，而不是把obj1的地址值赋值，因为所有的变量都是有自己的地址值的（用于在内存中查找该数据）
```

- 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据

- 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象

### 形参赋值

```js
var a = {age:12}

function fn (obj){
  obj = {age:15}
}
fn(a)
console.log(a.age) //12
//实参赋值给形参，obj保存了a的内存内容，age12的对象的内存地址值，然后obj获得了a的保存内容，然后又重新获取了一个地址值，age15，然后函数运行完毕，fn的执行上下文出栈，age15成为垃圾对象
//函数操作的永远是形参，只是形参保存了传入的实参的值
var b = 2 
function fn2 (animal){
  animal = 3
}
fn(b)
console.log(b) //2
```

### 关于数据传递的问题

- 在`js`调用函数时传递变量参数时, 是值传递还是引用传递

- 理解1: 都是值(基本/地址值)传递

- 理解2: 可能是值传递, 也可能是引用传递(地址值)

### `JS`引擎如何管理内存

- 内存生命周期
  - 分配小内存空间, 得到它的使用权
  - 存储数据, 可以反复进行操作
  - 释放小内存空间

  - 释放内存

- 局部变量: 函数执行完自动释放

- 对象: 成为垃圾对象==>垃圾回收器回收 //即使是函数内部新建的对象

- 所以要尽量少全局变量

### 对象

- 什么是对象?
  - 多个数据的封装体
  - 用来保存多个数据的容器
  - 一个对象代表现实中的一个事物（Object）

- 为什么要用对象?
  - 统一管理多个数据

- 对象的组成
  - 属性: 属性名(字符串，引号省略了)和属性值(任意)组成

  - 方法: 一种特别的属性(属性值是函数)

  - 如何访问对象内部数据?
    - .属性名: 编码简单, 有时不能用
    - ['属性名']: 编码麻烦, 能通用

- 问题: 什么时候必须使用['属性名']的方式?

  - 属性名包含特殊字符: - 空格

  - 属性名不确定 //用一个变量来存储变量名，可以做到任意变量名读取同一个数据

```js
var n = “变量名”
p.[n] //p.变量名 可以随时读取数据

//属性名不确定
var propName = "bge"
var value = 18
p[propName] = value
console.log(p[propName]) //18
console.log(p.age) //从有值→undefined
console.log(p.bge) //从undefined→18
```

### 函数

- 什么是函数?

  - 实现特定功能的n条语句的封装体

  - 只有函数是可以执行的, 其它类型的数据不能执行

- 为什么要用函数?
  - 提高代码复用

  - 便于阅读交流

- 如何定义函数?

  - 函数声明

  - 表达式

```js
var b = function c () {
  console.log(c) //可见
}
b()
console.log(c) //Uncaguht ReferenceError： c is not defined
```

- 表达式形式无法访问c，这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效。

- 如何调用(执行)函数?

  - test(): 直接调用

  - obj.test(): 通过对象调用

  - new test(): new调用

  - test.call/apply(obj): 临时让test成为obj的方法进行调用

- 什么函数才是回调函数?

  - 你定义的

  - 你没有调

  - 但最终它执行了(在某个时刻或某个条件下)

- 常见的回调函数?

  - `dom`事件回调函数 ==>发生事件的`dom`元素（与用户交互）
  - 定时器回调函数 ===>window
  - 延时定时器

  - 循环定时器
  - `ajax`请求回调函数(后面讲)（与后台交互）

  - 生命周期回调函数(后面讲)

### `IIFE`

- 理解

  - 全称: Immediately-Invoked Function Expression

  - 立即调用函数表达式

- 作用

  - 隐藏实现

  - 不会污染外部(全局)命名空间

  - 用它来编码`js`模块

- 只有function(){}会报错，要么使用要么赋值存起来 //`SyntaxError: function statement requires a name`

- (function(){})();  //匿名函数自调用，也就是`IIFE`

### this是什么?

- 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window

```:bullettrain_front:
function fun1(){
	function fun2(){
	console.log(this); //window，没有直接指定就是window
	}
}
```

- 所有函数内部都有一个变量this

- 它的值是**调用函数的当前对象**

- 如何确定this的值?

  - test(): window //相当于window.test()

  - p.test(): p

  - new test(): 新创建的对象

  - p.call(obj): obj

# 2. 函数高级

## 原型与原型链

### **显式原型：prototype**

- 每个**函数**function都有一个prototype，即显式原型（属性），它默认指向一个Object空对象(即称为: 原型对象) 
  - **定义函数**的时候，内部有一条内部语句：`Fn.prototype={}`
  - 默认值是一个空Object对象
  - 内建函数指向的Object有许多定义好的方法


### **隐式原型：`__proto__`**

- 每个**实例对象**都有一个`__proto__`，可称为隐式原型（属性）

  - **对象的隐式原型的值为其对应构造函数的显式原型的值**
  - **创建对象**的时候，内部有一条语句：`this.__proto__=Fn.prototype`
  - 默认值为构造函数的prototype属性值
  - 程序员能直接操作显式原型, 但不能直接操作隐式原型(`ES5`之前)，使用`getPrototypeOf()`
- 函数可以看作是一个特殊的对象，所以所有的函数也同时具有`__proto__`属性

+ ![1546691834085](F:\OneDrive\JS\纲略合集\assets\1546691834085.png) 

**注意：**

+ 其次是 `__proto__` ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.`__proto__` 时，可以理解成返回了 `Object.getPrototypeOf(obj)`。

### constructor

+ 原型对象也有一个属性叫**constructor**，这个属性包含一个指针，指向**原构造函数**。

  - 虽然**原型对象**也是**某个构造函数**的实例，但是因为它是原型对象，所有constructor被设计成指向实例**构造函数**

  - ```javascript
    function Foo(){}
    Foo.prototype instanceof Foo //false
    Foo.prototype.constructor === Foo //true
    //构造函数是Foo，但却不是Foo的实例
    ```

  - 原型对象，constructor和instanceof 不一致

  - 普通对象，constructor和instanceof 一致

+ 本质：**实例对象**，本身是没有constructor属性的，它的constructor需要到它的**原型链**去找。所以Foo.prototype**确实是Object的实例**，如果可以屏蔽本身的constructor属性，就会沿着原型链向上查找，

  - ```javascript
    function Foo(){}
    Foo.prototype.constructor === Object //false
    delete Foo.prototype.constructor
    Foo.prototype.constructor === Object //true
    ```

### 原型链

- 原型链(图解)
  - ![1546692183103](F:\OneDrive\JS\纲略合集\assets\1546692183103.png) 
   - 可以直接访问到的对象只有栈内存的三个
   - 变量找作用域链，对象的属性找原型链
- 访问一个对象的属性时，先在自身属性中查找，找到返回如果没有, 再沿着__proto__这条链向上查找, 找到返回如果最终没找到, 返回undefined
- 别名: **隐式原型链**
  - 作用: 查找对象的属性(方法)
- 构造函数/原型/实体对象的关系2(图解)
  - ![1546692302049](F:\OneDrive\JS\纲略合集\assets\1546692302049.png) 

**总结**

- 所有的对象都源于Object

- 函数的显示原型指向对象，默认是空Object**实例**对象（不包括Object构造函数，Object的prototype不是实例对象）

- 所有的函数源于Function构造函数

  - 推论1：所有函数都是Function的实例（包括Function本身）
  - 推论2：所有函数的隐式原型``__proto__``都是一样的，包括Function自己

  ```js
  Function = new Function()
  Function.__proto__=== Function.prototype // true
  ```

### 探索`instanceof`

- `instanceof`是如何判断的?
- 表达式: `A instanceof B`
- 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false
- Function是通过new自己产生的实例
- ![1546692412784](F:\OneDrive\JS\纲略合集\assets\1546692412784.png) 
- ![1546692426651](F:\OneDrive\JS\纲略合集\assets\1546692426651.png)
- Object.create(prototype, [descriptors])相当于是在`o1, o2` 再接一个`__proto__`指向`o1 ,o2`的对象，他们没有其他constructor和prototype属性，因为它们都是实例

### 面试题

![1546692544602](F:\OneDrive\JS\纲略合集\assets\1546692544602.png)

![1546692548349](F:\OneDrive\JS\纲略合集\assets\1546692548349.png)

- 凡是实例，都会经过`Object.prototype`
- 所有的函数，都是由Function构造的（都是Function 的实例），凡是函数都会经过`Function.porotype` 和` Object.prototype`

## 作用域

- 理解
  - 就是一块"地盘", 指程序源代码中定义变量的区域。
  - 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。
  - JavaScript 采用**词法作用域(lexical scoping)**，也就是静态作用域。它是静态的(相对于上下文对象), 在函数定义时就确定
- 分类
  - 全局作用域
  - 函数作用域
  - 块作用域(ES6新增)
- 作用
  - 隔离变量，不同作用域下同名变量不会有冲突

#### 静态作用域与动态作用域

- 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。

- 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

- 让我们认真看个例子就能明白之间的区别：

  ```js
  var value = 1;
  
  function foo() {
      console.log(value);
  }
  
  function bar() {
      var value = 2;
      foo();
  }
  
  bar();
  
  // 结果是 ???
  ```

- 假设JavaScript采用静态作用域，让我们分析下执行过程：

  - 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。

- 假设JavaScript采用动态作用域，让我们分析下执行过程：

  - 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。

- 前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。

#### 面试题

- ```js
  var scope = "global scope";
  function checkscope(){
      var scope = "local scope";
      function f(){
          return scope; 
      }
      return f();
  }
  checkscope(); // 'local scope'
  ```

- ```js
  var scope = "global scope";
  function checkscope(){
      var scope = "local scope";
      function f(){
          return scope;
      }
      return f;
  }
  checkscope()(); // 'local scope'
  ```

- JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。

## 执行上下文与执行上下文栈

> https://juejin.im/post/5ba32171f265da0ab719a6d7

### 变量提升与函数提升

- 变量声明提升
  - 通过var定义(声明)的变量, 在定义语句之前就可以访问到

  - 值: undefined

- 函数声明提升

  - 通过function声明的函数, 在之前就可以直接调用

  - 值: 函数定义(对象)

- 用函数表达式创建的函数，只遵循变量提升

  - `var fun =function(){}`

- 面试题

  - ```js
    var a =3 
    function fn(){
      console.log(a) 
      var a = 4
    }
    fn() //undefined
    //实际的过程
    var a = 3
    function fn(){
      var a 
      console.log(a)
      a = 4
    }
    ```

  - ```js
    fn() //undefined
    
    var a =3 
    function fn(){
      console.log(a)
    }
    
    //实际的过程
    var a
    var fn 
    fn = function(){
      console.log(a)
    }
    fn() //undefined
    a = 3
    ```

**问题: 变量提升和函数提升是如何产生的?（执行上下文）**

- 在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在**作用域的最开始的部分**。

- 函数提升要比变量提升的优先级要高一些，且**不会被变量声明覆盖**，但是会被**变量赋值之后覆盖**。

- 优先级：

  - ```js
    console.log(a) //f a(){console.log(10)}
    console.log(a()) //undefined，因为函数a没有定义返回值
    var a = 3 
    
    function a(){
      console.log(10)
    }
    console.log(a) //3
    a=6
    console.log(a()) //a is not a function
    
    //实际过程
    var a //函数的声明
    a = function(){
      console.log(10)
    }
    var a  //变量的声明,仅声明，不会覆盖函数定义
    
    console.log(a) //f a(){console.log(10)}
    console.log(a()) //undefined，因为函数a没有定义返回值
    
    a = 3 
    console.log(a) //3
    a=6
    console.log(a()) //a is not a function
    ```

### 执行上下文

- execution context

- 对于每个执行上下文，都有三个重要属性：

  - 变量对象(Variable object，VO)
  - 作用域链(Scope chain)
  - this

- 码分类(位置)，不同的码分类对这三个属性的处理有所不同

  - 全局代码
  - 函数(局部)代码

- **变量对象**

  - 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。
  - 因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。

- 全局执行上下文

  - 在执行全局代码前创建全局执行上下文
  - 将window确定为全局执行上下文的**变量对象VO**
    - 预定义了非常多的可以直接使用的属性和方法
  - 对全局数据进行预处理
    - function声明的全局函数==>赋函数定义(fun), 添加为window的方法
    - var定义的全局变量==>undefined, 添加为window的属性
    - this==>赋值(window，传递引用)
    - 开始执行全局代码

- 函数执行上下文

  - 在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。

    > 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。
    >
    > 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。

  - 在**调用函数**, 准备执行函数体之前, **创建**对应的函数执行上下文 (虚拟的, 存在于栈中，方便调用完函数之后内存的释放)
  - 创建活动对象，通过arguments 属性初始化，arguments==>赋值(实参列表), 添加为活动对象的属性
  - 对局部数据进行预处理
    - function声明的函数 ==>赋值(fun), 添加为活动对象的方法
    - var定义的局部变量==>undefined, 添加为活动对象的属性
    - this==>赋值(调用函数的对象，传递引用)
    - 开始执行函数体代码

**例子**：

- 请看下面的代码

  ```js
  function foo(a) {
    var b = 2;
    function c() {}
    var d = function() {};
  
    b = 3;
  
  }
  
  foo(1);
  ```

- 在进入执行上下文后，代码执行之前，这时候的 AO 是：

  ```js
  AO = {
      arguments: {
          0: 1,
          length: 1
      },
      a: 1,
      b: undefined,
      c: reference to function c(){},
      d: undefined
  }
  ```

- 在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值，当代码执行完后，这时候的 AO 是：

  ```js
  AO = {
      arguments: {
          0: 1,
          length: 1
      },
      a: 1,
      b: 3,
      c: reference to function c(){},
      d: reference to FunctionExpression "d"
  }
  ```

**面试题**

- ```js
  function foo() {
      console.log(a);
      a = 1;
  }
  
  foo(); // ???
  
  function bar() {
      a = 1;
      console.log(a);
  }
  bar(); // ???
  ```

- 第一段会报错：`Uncaught ReferenceError: a is not defined`。

- 第二段会打印：`1`。

- 这是因为函数中的 "a" 并没有通过 var 关键字声明，所有不会被存放在 AO 中。

- 第一段执行 console 的时候， AO 的值是：

  ```js
  AO = {
      arguments: {
          length: 0
      }
  }
  ```

- 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。

- 当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。

### 执行上下文栈

- 栈：后进先出；队列：先进先出

- 浏览器中的JS解释器被实现为单线程，这也就意味着同一时间只能发生一件事情，其他的行为或事件将会被放在叫做执行栈里面排队。下面的图是单线程栈的抽象视图：

![1546693704393](F:\OneDrive\JS\纲略合集\assets\1546693704393.png)

- 执行步骤

  - 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象

  - 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)

  - 在函数执行上下文创建(函数被调用时)后, 将其添加到栈中(压栈)

  - 在当前函数执行完后,将栈顶的对象移除(出栈)

  - 当所有的代码执行完后, 栈中只剩下window

### 面试题

```js
console.log("gb:"+i)
var i = 1
foo(1)
function foo(i){
  if(i==4){
    return
  }
  console.log("fb:"+i)
  foo(i+1) //递归调用
  console.log("fe:"+i)
}
console.log("ge:"+i)

//1.依次输出了什么？
/*
undefined
1
2
3
3
2
1
1
*/
//2.整个过程产生了几个执行上下文栈
//步骤分解
var foo
foo = function (i){}
var i 
console.log("gb:"+i) //undefined
i = 1
foo(i)
	/*
	  var i //定义形参
	  i = 1 //实参赋值给形参
	  console.log("fb:"+i) //1
	  foo(i+1) //foo(2)
	  	//var i
	  	// i = 2
	  	// console.log("fb:"+i) // 2
	  	// foo(i+1) // foo(3)→ console.log("fb:"+i) //3
	  	// foo(4) return 结束整个函数，foo(4)结束了
	  	// foo(3) 继续下一步 console.log("fe:"+i) ， 闭包没有传递下来，所以i还是3
	  	// foo(2) console.log("fe:"+i) // 2
	  	// foo(1) console.log("fe:"+i) // 1
	*/
console.log("ge:"+i) //闭包没有保存下来，所以全局里i的值没有变过 1
```

```js
//1.先函数提升，再变量提升，但是var如果有值了不会再次赋值undefined
  function a(){}
  var a 
  console.log(typeof a) // function
//2.if是语句，不是函数，var正常声明提升
  if(!b in window){
    var b = 1
  }
  console.log(b) //undefined，而不是报错Uncaught ReferenceError: pangjing is not defined
  //压缩过后的代码，很多abcd，得试试其他的
//3.
var c =1 
function c(c){
  console.log(c)
  var c = 3
}
c(2) //函数提升之后变量提升，c先被赋予了数字1，报错 c is not a function
```

## 作用域链

- 理解

  - 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)
  - 查找变量时就是沿着作用域链来查找的
  - 由多个执行上下文的变量对象构成的链表就叫做作用域链。

- 查找一个变量的查找规则

  1. 在**当前作用域**下的**执行上下文**中查找对应的属性, 如果有直接返回, 否则进入2
  2. 在**上一级作用域**的**执行上下文**中查找对应的属性, 如果有直接返回, 否则进入3
  3. 再次执行2的相同操作, 直到**全局作用域**, 如果还找不到就抛出找不到的异常

- 下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。

### 作用域链的创建

- **函数的定义**

- 函数的作用域在函数定义的时候就决定了。这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！

- 请看下面的例子：

  ```js
  function foo() {
      function bar() {
          ...
      }
  }
  ```

- 函数创建时，各自的[[scope]]为：

  ```js
  foo.[[scope]] = [
    globalContext.VO
  ];
  
  bar.[[scope]] = [
      fooContext.AO,
      globalContext.VO
  ];
  ```

### 作用域链的变化

- **函数的执行**

- 当函数激活时，进入函数上下文，创建 VO/AO 后，就会**将活动对象添加到作用链的前端**。

- 这时候执行上下文的作用域链，我们命名为 Scope：

  ```js
  Scope = [AO].concat([[Scope]]);
  ```

- 至此，作用域链创建完毕。

### 完整例子

- 以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：

  ```js
  var scope = "global scope";
  function checkscope(){
      var scope2 = 'local scope';
      return scope2;
  }
  checkscope();
  ```

**执行过程如下：**

1. checkscope 函数被**创建**，保存作用域链到 内部属性[[scope]]

   ```js
   checkscope.[[scope]] = [
       globalContext.VO
   ];
   ```

2. **执行** checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈

   ```js
   ECStack = [
       checkscopeContext,
       globalContext
   ];
   ```

3. checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链

   ```js
   checkscopeContext = {
       Scope: checkscope.[[scope]],
   }
   ```

4. 第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明

   ```js
   checkscopeContext = {
       AO: {
           arguments: {
               length: 0
           },
           scope2: undefined
       }，
       Scope: checkscope.[[scope]],
   }
   ```

5. 第三步：将活动对象压入 checkscope 作用域链顶端

   ```js
   checkscopeContext = {
       AO: {
           arguments: {
               length: 0
           },
           scope2: undefined
       },
       Scope: [AO, [[Scope]]]
   }
   ```

6. 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值

   ```js
   checkscopeContext = {
       AO: {
           arguments: {
               length: 0
           },
           scope2: 'local scope'
       },
       Scope: [AO, [[Scope]]]
   }
   ```

7. 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出

   ```js
   ECStack = [
       globalContext
   ];
   ```

   



### 注意

- 一旦找到第一个匹配，作用域查询就停止了。相同的标识符名称可以在嵌套作用域的多个层中被指定，这称为“遮蔽（shadowing）”（内部的标识符“遮蔽”了外部的标识符）。无论如何遮蔽，作用域查询总是从当前被执行的最内侧的作用域开始，向外/向上不断查找，直到第一个匹配才停止。

  注意： 全局变量也自动地是全局对象（在浏览器中是 `window`，等等）的属性，所以不直接通过全局变量的词法名称，而通过将它作为全局对象的一个属性引用来间接地引用，是可能的。

- 词法作用域查询 *仅仅* 在处理头等标识符时实施，比如 `a`，`b`，和 `c`。如果你在一段代码中拥有一个 `foo.bar.baz` 的引用，词法作用域查询将在查找 `foo` 标识符时实施，但一旦定位这个变量，对象属性访问规则将会分别接管 `bar` 和 `baz` 属性的解析。

- 词法作用域意味着作用域是由编写时函数被声明的位置的决策定义的。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并如此在执行期间预测它们将如何被查询。

- 

### 面试题

```javascript
var x = 10
function fn (){
  console.log(x)
}
function show(f){
  var x = 20 
  f()
}
show(fn)
```

- 因为函数时引用类型，把`fn`赋值给<u>f</u>，<u>f</u>依然是引用相同的`fn`，所以是**调用函数**，而不是新建然后执行，所以被调用的`fn`函数的作用域还是外部的，而不是在show()内部

```js
var fn = function(){
  console.log(fn)
}
fn()
var obj={
  fn2:function(){
    console.log(this.fn2)
    console.log(obj.fn2)
    console.log(fn2)
  }
}
obj.fn2()
//与是不是方法没有关系，本质都是把函数的引用传递给了一个变量，然后某个对象读取了这个变量值（调用了this），这个对象就是this
```

### 左查询与右查询

- 左查询和右查询，都是基于作用域的
- 左查询，Left-hand Side
- 右查询，Right-hand Side 
- Side 什么的...边？ 赋值操作的边
- 换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。
- 实际上，我们可以表述得更准确一点儿。对于我们的目的来说，一个 RHS 是难以察觉的，因为它简单地查询某个变量的值，而 LHS 查询是试着找到变量容器本身，以便它可以赋值。从这种意义上说，RHS 的含义实质上不是 真正的 “一个赋值的右手边”，更准确地说，它只是意味着**“不是左手边”。**
- **注意：** LHS 和 RHS 意味着“赋值的左/右手边”未必像字面上那样意味着“ `=` 赋值操作符的左/右边”。赋值有几种其他的发生形式，所以最好在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）”。
- **注意：** 你可能会试图将函数声明 `function foo(a) {...}` 概念化为一个普通的变量声明和赋值，比如 `var foo` 和 `foo = function(a){...}`。这样做会诱使你认为函数声明涉及了一次 LHS 查询。

**例子**

- 考虑这段程序，它既有 LHS 引用又有 RHS 引用：

  ```js
  function foo(a) {
  	console.log( a ); // 2
  }
  
  foo( 2 );
  ```

- 调用 `foo(..)` 的最后一行是一个函数调用，查询一个指向 `foo` 的 RHS 引用，意味着，“去查询 `foo` 的值，并把它交给我”。另外，`(..)` 意味着 `foo` 的值应当被执行，所以它最好实际上是一个函数！

- 这里有一个微妙但重要的赋值。你发现了吗？

- 你可能错过了这个代码段隐含的 `a = 2`。它发生在当值 `2` 作为参数值传递给 `foo(..)` 函数时，值 `2` 被赋值 给了参数 `a`。为了（隐含地）给参数 `a` 赋值，进行了一个 LHS 查询。

- 这里还有一个 `a` 的值的 RHS 引用，它的结果值被传入 `console.log(..)`。`console.log(..)` 需要一个引用来执行。它为 `console` 对象进行一个 RHS 查询，然后发生一个**属性解析**来看它是否拥有一个称为 `log` 的方法。

- 最后，我们可以将这一过程概念化为，在将值 `2`（通过变量 `a` 的 RHS 查询得到的）传入 `log(..)` 时发生了一次 LHS/RHS 的交换。在 `log(..)` 的原生实现内部，我们可以假定它拥有参数，其中的第一个（也许被称为 `arg1`）在 `2` 被赋值给它之前，进行了一次 LHS 引用查询。

- 然而，一个微妙但重要的不同是，在这种情况下 *编译器* 在代码生成期间同时处理声明和值的定义，如此当 引擎 执行代码时，没有必要将一个函数值“赋予” `foo`。因此，将函数声明考虑为一个我们在这里讨论的 LHS 查询赋值是不太合适的。

**小测验**

- ```js
  function foo(a) {
  	var b = a;
  	return a + b;
  }
  
  var c = foo( 2 );
  ```

1. 找到所有的 LHS 查询（有3处！）。
2. 找到所有的 RHS 查询（有4处！）。

**区别**

- 为什么我们区别 LHS 和 RHS 那么重要？

- 因为在变量还没有被声明（在所有被查询的 *作用域* 中都没找到）的情况下，这两种类型的查询的行为不同。

- ```js
  function foo(a) {
  	console.log( a + b );
  	b = a;
  }
  
  foo( 2 );
  
  // 找出所有的 LHS 查询（有3处！）。
  
  c = .., a = 2（隐含的参数赋值）和 b = ..
  
  // 找出所有的 RHS 查询（有4处！）。
  
  foo(2.., = a;, a + .. 和 .. + b
  ```

- 当 `b` 的 RHS 查询第一次发生时，它是找不到的。它被说成是一个“未声明”的变量，因为它在作用域中找不到。

- 如果 RHS 查询在嵌套的 *作用域* 的任何地方都找不到一个值，这会导致 引擎 抛出一个 `ReferenceError`。必须要注意的是这个错误的类型是 `ReferenceError`。

- 相比之下，如果 *引擎* 在进行一个 LHS 查询，但到达了顶层（全局 作用域）都没有找到它，而且如果程序没有运行在“Strict模式”[[1\]](https://www.kancloud.cn/kancloud/you-dont-know-js-scope-closures/516609#fn1)下，那么这个全局作用域 将会在 全局作用域中 创建一个同名的新变量，并把它交还给 引擎。

- 在 ES5 中被加入的“Strict模式”[[1:1\]](https://www.kancloud.cn/kancloud/you-dont-know-js-scope-closures/516609#fn1)，有许多与一般/宽松/懒惰模式不同的行为。其中之一就是不允许自动/隐含的全局变量创建。在这种情况下，将不会有全局 作用域 的变量交回给 LHS 查询，并且类似于 RHS 的情况, 引擎 将抛出一个 `ReferenceError`。

- 现在，如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 `null` 或者 `undefined` 值的属性，那么 *引擎* 就会抛出一个不同种类的错误，称为 `TypeError`。

- `ReferenceError` 是关于 作用域 解析失败的，而 `TypeError` 暗示着 作用域 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。

- 作用域是一组规则，它决定了一个变量（标识符）在哪里和如何被查找。这种查询也许是为了向这个变量赋值，这时变量是一个 LHS（左手边）引用，或者是为取得它的值，这时变量是一个 RHS（右手边）引用。

## 作用域与执行上下文

- 区别1
  - 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时
  - 全局执行上下文环境是在**全局作用域确定之后**, js代码马上执行之前创建
  - 函数执行上下文是在调用函数时, 函数体代码执行之前创建
- 区别2
  - 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
  - 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放
- 联系
  - 执行上下文(对象)是从属于所在的作用域
  - 全局上下文环境==>全局作用域
  - 函数上下文环境==>对应的函数作用域
  - 问题来了：作用域 词法作用域 词法环境
    - 作用域的一种工作方式：词法作用域
    - 另一种：动态作用域
    - 词法环境：在执行上下文中的一个对象，有着和作用域相同的映射 
  - 执行上下文和作用域之间没有从属关系，仅仅是执行上下文当中的lexical environment对象保存着函数被创建时的作用域（**标识符—变量映射**）的信息，可以说一个副本，在函数要执行的时候把这个对象放了进来
  - 当函数被定义时，他的作用域就确定了，当函数要执行的时候lexical environment对象保存了这个作用域的信息
  - 而且：
  - https://segmentfault.com/a/1190000009522006
  - https://juejin.im/post/5ba32171f265da0ab719a6d7
  - A *closure* is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was created. 

## 函数与块作用域

- ```js
  var a = 2;
  
  (function foo(){ // <-- 插入这个
  
  	var a = 3;
  	console.log( a ); // 3
  
  })(); // <-- 和这个
  
  console.log( a ); // 2
  ```

- 首先注意，与仅仅是 `function...` 相对，这个包装函数语句以 `(function...` 开头。虽然这看起来像是一个微小的细节，但实际上这是一个重大改变。与将这个函数视为一个标准的声明不同的是，这个函数被视为一个函数表达式。

- 注意： 区分声明与表达式的最简单的方法是，这个语句中（不仅仅是一行，而是一个独立的句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。

- 这里我们可以观察到一个函数声明和一个函数表达式之间的关键不同是，它的名称作为一个标识符被绑定在何处。

- 比较这前两个代码段。在第一个代码段中，名称 `foo` 被绑定在外围作用域中，我们用 `foo()` 直接调用它。在第二个代码段中，名称 `foo` 没有被绑定在外围作用域中，而是被绑定在它自己的函数内部。

- 换句话说，`(function foo(){ .. })` 作为一个表达式意味着标识符 `foo` 仅能在 `..` 代表的作用域中被找到，而不是在外部作用域中。将名称 `foo` 隐藏在它自己内部意味着它不会没必要地污染外围作用域。

### 匿名与命名

- 你可能对函数表达式作为回调参数再熟悉不过了，比如：

  ```js
  setTimeout( function(){
  	console.log("I waited 1 second!");
  }, 1000 );
  ```

- 这称为一个“匿名函数表达式”，因为 `function()...` 上没有名称标识符。函数表达式可以是匿名的，但是函数声明不能省略名称 —— 那将是不合法的JS程序。

- 匿名函数表达式可以快速和很容易地键入，而且许多库和工具往往鼓励使用这种代码惯用风格。然而，它们有几个缺点需要考虑：

1. 在栈轨迹上匿名函数没有有用的名称可以表示，这可能会使得调试更加困难。
2. 没有名称的情况下，如果这个函数需要为了递归等目的引用它自己，那么就需要很不幸地使用 被废弃的`arguments.callee` 引用。另一个需要自引用的例子是，当一个事件处理器函数在被触发后想要把自己解除绑定。
3. 匿名函数省略的名称经常对提供更易读/易懂的代码很有帮助。一个描述性的名称可以帮助代码自解释。

- 内联函数表达式 很强大且很有用 —— 匿名和命名的问题并不会贬损这一点。给你的函数表达式提供一个名称就可以十分有效地解决这些缺陷，而且没有实际的坏处。最佳的方法是总是命名你的函数表达式：

  ```js
  setTimeout( function timeoutHandler(){ // <-- 看，我有一个名字！
  	console.log( "I waited 1 second!" );
  }, 1000 );
  ```

- 但是现在有更好的选择：箭头函数？

- 得益于包装在一个 `()` 中，我们有了一个作为表达式的函数，我们可以通过在末尾加入另一个 `()` 来执行这个函数，就像 `(function foo(){ .. })()`。第一个外围的 `( )` 使这个函数变成表达式，而第二个 `()` 执行这个函数。

- 传统的IIFE有一种稍稍变化的形式，一些人偏好这样：`(function(){ .. }())`。仔细观察不同之处。在第一种形式中，函数表达式被包在 `( )` 中，然后用于调用的 `()` 出现在它的外侧。在第二种形式中，用于调用的 `()` 被移动到用于包装的 `( )` 内侧。

- 这两种形式在功能上完全相同。这纯粹是一个你偏好的风格的选择。

### try/catch

- 一个鲜为人知的事实是，JavaScript 在 ES3 中明确指出在 `try/catch` 的 `catch` 子句中声明的变量，是属于 `catch` 块儿的块儿作用域的。

  ```js
  try {
  	undefined(); //用非法的操作强制产生一个异常！
  }
  catch (err) {
  	console.log( err ); // 好用！
  }
  
  console.log( err ); // ReferenceError: `err` not found
  ```

### let

- 至此，我们看到 JavaScript 仅仅有一些奇怪的小众行为暴露了块儿作用域功能。如果这就是我们拥有的一切，而且许多许多年以来这 *确实就是* 我们拥有的一切，那么块作用域对 JavaScript 开发者来说就不是非常有用。

- 幸运的是，ES6 改变了这种状态，并引入了一个新的关键字 `let`，作为另一种声明变量的方式伴随着 `var`。

- `let` 关键字将变量声明附着在它所在的任何块儿（通常是一个 `{ .. }`）的作用域中。换句话说，`let` 为它的变量声明隐含地劫持了任意块儿的作用域。

## 闭包

- 调用的时候i是谁，i为什么还在

- 如何产生闭包?

  - 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包

- 闭包到底是什么?

  - 使用chrome调试查看
  - ~~理解一: 闭包是嵌套的内部函数(绝大部分人)~~
  - 理解二: 包含被引用变量(函数)的对象(极少数人)
  - 理解三：闭包是一个嵌套在内部的函数对象，包含着引用的变量，传递对象的引用的时候这个小背包里的变量也会被一起传递
  - 我的理解：闭包是打包了外部作用域的对象，保存了该作用域的变量的引用，在这个内部函数中，通过闭包对象可以实现对作用域链内的变量的访问
  - 注意: 闭包存在于嵌套的内部函数中

- 产生闭包的条件?

  - 函数嵌套
  - 内部函数引用了外部函数的数据(变量/函数)

  ```js
  function fn1(){
    var a =2 
    function fn2(){
      a++
      console.log(a)
    }
    return fn2
  }
  
  var f = fn1 //接受了函数引用（还有小背包里的变量）
  f() //3 函数fn1的局部变量fn2已经消失，但是把引用赋值给了f，所以产生的闭包对象一直存在
  f() //4 反复调用f，可以继续使用fn1的局部变量
  ```

![1546850652897](F:\OneDrive\JS\纲略合集\assets\1546850652897.png)

- 常见的闭包

  - 将函数作为另一个函数的返回值

  - 将函数作为实参传递给另一个函数调用

- 闭包的作用

  - 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)

  - 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

  - 外部无法直接访问闭包内的变量，只能执行内部函数设定好的操作

- 问题:

  - 函数执行完后, 函数内部声明的局部变量是否还存在?  一般是不存在, 存在于闭包中的变量，且闭包对象被引用，才会继续存在

  - 在函数外部能直接访问函数内部的局部变量吗? 不能, 但我们可以通过闭包让外部操作它

- 闭包的生命周期

  - 产生: 在嵌套内部函数**定义执行**完时就产生了(不是在调用 a：undefined)

  - 死亡: 在嵌套的内部函数成为垃圾对象时
    - f = null;

- 定义JS模块

  - 具有特定功能的js文件

  - 将所有的数据和功能都封装在一个函数内部(私有的)

  - 只向外暴露一个包含n个方法的对象或函数

  - 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能

- 缺点
    - 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
    - 容易造成内存泄露

- 解决
    - 能不用闭包就不用
    - 及时释放

    ```js
    function fn1() {
    	var arr = new Array[100000]
    	function fn2() {
     		console.log(arr.length)
    	}
    	return fn2
    }
    var f = fn1()
    f()
    
    f = null //让内部函数成为垃圾对象-->回收闭包
    ```
- 

  ```js
  var module = myModule()
  module.doSomething()
  module.doOtherhing()
  
  (function(window){
    //私有数据
    var msg = "Hello Closure"
    //操作数据的函数
    function doSomething(){
      console.log("doSomething()"+ msg.toUpperCase())
    }
    function doOtherthing(){
      console.log("doSomething()"+ msg.toLowerCase())
    }
    
    //向外暴露对象（给外部使用的方法）
    window.myModule2 = (){
      doSomething:doSomething,
      doOtherthing:doOtherthing
    }
    
  })(window)
  ```

- 用闭包和用tool.js的区别在哪里呢？

  - tool.js所有的函数和变量都可以直接操作

### 面试题

```js
//代码片段一
var name = "The Window"
var object = {
  name:"My Object",
  getNameFunc:function(){
    return function(){
      return this.name
    }
  }
}
consloe.log(object.getNameFunc()()) //The Window,this变成了window

//代码片段二
  var name2 = "The Window";
  var object2 = {
    name2 : "My Object",
    getNameFunc : function(){
      var that = this;
      return function(){
        return that.name2;
      };
    }
  };
  alert(object2.getNameFunc()()); //?  my object thta还是object，
//执行上下文创建的时候，this每次都会重新绑定引用，没办法作为闭包内的变量，
//而且是在创建函数的那一刻的执行上下文中引用的变量，所以不同的执行上下文，即使引用了外部变量也不会是闭包变量
//外部函数，只能是包着的哪一个
```

```js
function foo(n,o) {
  console.log(o)
  return {
    method:function(m){
      return foo(m,n)
    }
  }
}
var a=foo(0)
a.method(1)
a.method(2)
a.method(3)//undefined,0,0,0

var b = foo(0).method(1).method(2).method(3)//undefined,0,1,2

var c = foo(0).method(1)
c.method(2)
c.method(3)//undefined,0,1,1
```

## 循环 + 闭包

用来展示闭包最常见最权威的例子是老实巴交的 for 循环。

```
for (var i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}
```

注意： 当你将函数放在循环内部时 Linter 经常会抱怨，因为不理解闭包的错误 在开发者中太常见了。我们在这里讲解如何正确地利用闭包的全部力量。但是 Linter 通常不理解这样的微妙之处，所以它们不管怎样都将抱怨，认为你 *实际上* 不知道你在做什么。

这段代码的精神是，我们一般将 *期待* 它的行为是分别打印数字“1”，“2”，……“5”，一次一个，一秒一个。

实际上，如果你运行这段代码，你会得到“6”被打印5次，一秒一个。

啊？

首先，让我们解释一下“6”是从哪儿来的。循环的终结条件是 `i`*不*`<=5`。第一次满足这个条件时 `i` 是6。所以，输出的结果反映的是 `i` 在循环终结后的最终值。

如果多看两眼的话这其实很明显。超时的回调函数都将在循环的完成之后立即运行。实际上，就计时器而言，即便在每次迭代中它是 `setTimeout(.., 0)`，所有这些回调函数也都仍然是严格地在循环之后运行的，因此每次都打印 `6`。

但是这里有个更深刻的问题。要是想让它实际上如我们在语义上暗示的那样动作，我们的代码缺少了什么？

缺少的东西是，我们试图 *暗示* 在迭代期间，循环的每次迭代都“捕捉”一份对 `i` 的拷贝。但是，虽然所有这5个函数在每次循环迭代中分离地定义，由于作用域的工作方式，它们 都闭包在同一个共享的全局作用域上，而它事实上只有一个 `i`。

这么说来，所有函数共享一个指向相同的 `i` 的引用是 *理所当然* 的。循环结构的某些东西往往迷惑我们，使我们认为这里有其他更精巧的东西在工作。但是这里没有。这与根本没有循环，5个超时回调仅仅一个接一个地被声明没有区别。

好了，那么，回到我们火烧眉毛的问题。缺少了什么？我们需要更多 铃声 被闭包的作用域。明确地说，我们需要为循环的每次迭代都准备一个新的被闭包的作用域。

我们在第三章中学到，IIFE 通过声明并立即执行一个函数来创建作用域。

让我们试试：

```
for (var i=1; i<=5; i++) {
	(function(){
		setTimeout( function timer(){
			console.log( i );
		}, i*1000 );
	})();
}
```

这好用吗？试试。我还会等你。

我来为你终结悬念。不好用。 但是为什么？很明显我们现在有了更多的词法作用域。每个超时回调函数确实闭包在每次迭代时分别被每个 IIFE 创建的作用域中。

拥有一个被闭包的 空的作用域 是不够的。仔细观察。我们的 IIFE 只是一个空的什么也不做的作用域。它内部需要 *一些东西* 才能变得对我们有用。

它需要它自己的变量，在每次迭代时持有值 `i` 的一个拷贝。

```
for (var i=1; i<=5; i++) {
	(function(){
		var j = i;
		setTimeout( function timer(){
			console.log( j );
		}, j*1000 );
	})();
}
```

万岁！它好用了！

有些人偏好一种稍稍变形的形式：

```
for (var i=1; i<=5; i++) {
	(function(j){
		setTimeout( function timer(){
			console.log( j );
		}, j*1000 );
	})( i );
}
```

当然，因为这些 IIFE 只是函数，我们可以传入 `i`，如果我们乐意的话可以称它为 `j`，或者我们甚至可以再次称它为 `i`。不管哪种方式，这段代码都能工作。

在每次迭代内部使用的 IIFE 为每次迭代创建了新的作用域，这给了我们的超时回调函数一个机会，在每次迭代时闭包一个新的作用域，这些作用域中的每一个都拥有一个持有正确的迭代值的变量给我们访问。

问题解决了！

### 重温块儿作用域

仔细观察我们前一个解决方案的分析。我们使用了一个 IIFE 来在每一次迭代中创建新的作用域。换句话说，我们实际上每次迭代都 *需要* 一个 块儿作用域。我们在第三章展示了 `let` 声明，它劫持一个块儿并且就在这个块儿中声明一个变量。

这实质上将块儿变成了一个我们可以闭包的作用域。所以接下来的牛逼代码“就是好用”：

```
for (var i=1; i<=5; i++) {
	let j = i; // 呀，给闭包的块儿作用域！
	setTimeout( function timer(){
		console.log( j );
	}, j*1000 );
}
```

*但是，这还不是全部！*（用我最棒的 Bob Barker 嗓音）在用于 for 循环头部的 `let` 声明被定义了一种特殊行为。这种行为说，这个变量将不是只为循环声明一次，而是为每次迭代声明一次。并且，它将在每次后续的迭代中被上一次迭代末尾的值初始化。

```
for (let i=1; i<=5; i++) {
	setTimeout( function timer(){
		console.log( i );
	}, i*1000 );
}
```

这有多酷？块儿作用域和闭包携手工作，解决世界上所有的问题。我不知道你怎么样，但这使我成了一个快乐的 JavaScript 开发者。





本质：传递了引用和词法环境，词法环境有环境记录器和outer，outer绑定了父级作用域（闭住了父级作用域，把他包进来了，作为outer对象），环境记录器引用了outer的变量，这样他自己可以使用，同时为了让他可以使用，父级的作用域一直存在，其他没有被引用的变量也一直存在，只是因为环境记录器没有记录，现在他们访问不到了

https://juejin.im/post/5ba32171f265da0ab719a6d7

https://segmentfault.com/a/1190000009522006

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures

https://www.kancloud.cn/kancloud/you-dont-know-js-scope-closures/516613

https://zhuanlan.zhihu.com/p/25296587



如果环境记录器没有引用outer的变量，那么outer会被垃圾回收机制处理，所以：仅仅是返回一个函数的话，之后就没办法在调用outer的变量了

```js
function fn1(){
  var a = 2
  return function fn2(){
    
  }
}
```





![1546912097947](F:\OneDrive\JS\纲略合集\assets\1546912097947.png)

在函数定义的时候，闭包就产生了

![1546912224962](F:\OneDrive\JS\纲略合集\assets\1546912224962.png)

闭包其实是：外部作用域，所以在fn2还没执行上下文的时候，闭包就一已经有了，因为外部作用域已经有了，而且外部作用域的变化，闭包也会跟着变化，a变成了2

![1546912786105](F:\OneDrive\JS\纲略合集\assets\1546912786105.png)

闭包仅仅是被fn2引用者，所以保留了一下来，依然可以访问，由于fn2的函数声明提升，闭包被创建了，outer和fn2的环境记录器已经起了联系

![1546913014211](F:\OneDrive\JS\纲略合集\assets\1546913014211.png)

a产生的时候，b也产生了，因为函数声明的提升，fn2内部的环境记录器和outer都已经有值了

a 和 b 不在同一个环境里，所以a不在fn2的环境记录器中，而是一直在闭包里面，也就是outer，如果没有产生闭包，fn2的outer也还是一样，只是没有办法引用outer的值了，因为在fn1被回收之前，没有过outer，outer应该也被回收了，即使把整个词法环境一起传递（但是没有引用outer，outer是无用的），所以outer也会被回收

环境记录器和outer并不是在函数执行的时候确定的，而是在函数定义的时候就已经确定了，在函数执行的时候，创建执行上下文，在词法环境内引用环境记录器和outer，给可能的函数定义，在执行阶段，给环境记录器内的变量赋值

```js
  // 1. 将函数作为另一个函数的返回值
  function fn1() {
    var a = 2

    function fn2() {
	  var b = 2
      a++
      console.log(a)
    }

    return fn2
  }
  var f = fn1()
  f() // 3
  f() // 4
```
```js
window.onload = function(){
  //用var声明，也存在闭包，只是外部作用域为全局作用域，其他的闭包也引用着相同的它，所以i被修改了
  //用let声明，每次都为i创建一个单独的作用域，即可正常绑定和引用
  for(let i=0;i<liNodes.length;i++){
    //转绑很重要
    liNodes[i].index = i;
    liNodes[i].onclick=function(){
      //var i ，本质上是在函数内部声明了i，导致不会沿着作用域链去访问外部闭包里的i
      for(var j=0;j<upNodes.length;j++){
        //upNodes[i].style.width="0";
        upNodes[j].style.width="";
      }
      upNodes[i].style.width="100%";
      arrowEl.style.left = liNodes[i].offsetLeft + liNodes[i].offsetWidth/2 - arrowEl.offsetWidth/2+"px";
    }
  }
}
```

## call() apply() bind()

### call()

+ call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。

+ 让某个函数临时成为指定的 this 的方法，并且进行调用

  ```js
  var foo = {
      value: 1
  };
  
  function bar() {
      console.log(this.value);
  }
  
  bar.call(foo); // 1
  ```

  + call 改变了 this 的指向，指向到 foo
  + 同时，bar 函数执行了

#### 模拟实现第一步

1. 将函数设为对象的属性
2. 执行该函数
3. 删除该函数

+ 改造上面的例子

  ```js
  // 第一步
  foo.fn = bar
  // 第二步
  foo.fn()
  // 第三步
  delete foo.fn
  ```

+ 完整版myCall函数

  ```js
  Function.prototype.myCall = function(context){
    context.fn = this
    context.fn()
    delete context.fn
  }
  
  const foo = {
    value:1,
  }
  
  function bar(){
    console.log(this.value)
  }
  
  bar.myCall(foo) // 1
  ```

#### 模拟实现第二步

+ call 函数还能给定参数执行函数，但是，传入的参数并不确定，并且传入的参数要再传入到调用的函数中

+ 两种错误的做法

  ```js
  // 将数组里的元素作为多个参数放进函数的形参里
  context.fn(args.join(','))
  // 相当于是传入了一个 join 好的字符串
  
  // 相当于是传入了一个类数组对象，只有第一个形参被赋予该值
  context.fn(arguments)
  ```

+ 使用ES6的做法，使用扩展运算符即可解决

  ```js
  Function.prototype.myCall = function(context){
    context.fn = this
    context.fn(...arguments)
    delete context.fn
  }
  
  const foo = {
    value:1,
  }
  
  function bar(a,b){
    console.log(this.value)
    console.log(a,b) // this,1
  }
  
  bar.myCall(foo,1,2,3) // 1
  ```

+ 不过 call 是 ES3 的方法，模拟实现就别用ES6了

**eval()**

+ 截取arguments的参数部分

+ ```js
  // 以上个例子为例，此时的arguments为：
  // arguments = {
  //      0: foo,
  //      1: 'kevin',
  //      2: 18,
  //      length: 3
  // }
  // 因为arguments是类数组对象，所以可以用for循环
  var args = [];
  for(var i = 1, len = arguments.length; i < len; i++) {
      args.push('arguments[' + i + ']');
  }
  
  // 执行后 args为 ["arguments[1]", "arguments[2]", "arguments[3]"]
  ```

+ 通过eval还原参数

  ```js
  eval('context.fn(' + args +')')
  ```

  + 这里 args 会自动调用 Array.toString() 这个方法。

+ eval()版完整代码

  ```js
  Function.prototype.myCall = function(context){
    const args = []
    context.fn = this
    for (let i = 1; i < arguments.length; i++) {
      args.push('arguments['+i+']')
    }
    eval('context.fn('+args+')')
    delete context.fn
  }
  
  const foo = {
    value:1,
  }
  
  function bar(a,b){
    console.log(this.value)
    console.log(a,b) // this,1
  }
  
  bar.myCall(foo,1,{b:2}) // 1
  ```

#### 模拟实现第三步

**两个注意点**

+ **this 参数可以传 null，当为 null 的时候，视为指向 window**

+ **函数是可以有返回值的！**

+ 最终版完整代码

  ```js
  // 第三版
  Function.prototype.call2 = function (context) {
      // null
      var context = context || window;
      context.fn = this;
  
      var args = [];
      for(var i = 1, len = arguments.length; i < len; i++) {
          args.push('arguments[' + i + ']');
      }
    
      var result = eval('context.fn(' + args +')');
  
      delete context.fn
      return result;
  }
  
  // 测试一下
  var value = 2;
  
  var obj = {
      value: 1
  }
  
  function bar(name, age) {
      console.log(this.value);
      return {
          value: this.value,
          name: name,
          age: age
      }
  }
  
  bar.call2(null); // 2
  
  console.log(bar.call2(obj, 'kevin', 18));
  // 1
  // Object {
  //    value: 1,
  //    name: 'kevin',
  //    age: 18
  // }
  ```

### apply()

+ ```js
  Function.prototype.apply = function (context, arr) {
      var context = Object(context) || window;
      context.fn = this;
  
      var result;
      if (!arr) {
          result = context.fn();
      }
      else {
          var args = [];
          for (var i = 0, len = arr.length; i < len; i++) {
              args.push('arr[' + i + ']');
          }
          result = eval('context.fn(' + args + ')')
      }
  
      delete context.fn
      return result;
  }
  ```

### bind()

- bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。

#### 返回函数的实现

- 返回一个函数

- 可以指定this，关于this的指定，我们可以使用 call() 或者 apply() 方法实现

  ```js
  Function.prototype.bind2 = function (context) {
      var self = this;
      return function () {
          return self.apply(context); // 调用函数可能会有返回值，所以需要再return一个
      }
  
  }
  ```

#### 分段传参的实现

- ```js
  var foo = {
      value: 1
  };
  
  function bar(name, age) {
      console.log(this.value);
      console.log(name);
      console.log(age);
  
  }
  
  var bindFoo = bar.bind(foo, 'daisy');
  bindFoo('18');
  // 1
  // daisy
  // 18
  ```

- 函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!

- 我们用 arguments 进行处理：

  ```js
  // 第二版
  Function.prototype.bind2 = function (context) {
  
      var self = this;
      // 获取bind2函数从第二个参数到最后一个参数
      var args = Array.prototype.slice.call(arguments, 1);
  
      return function () {
          // 这个时候的arguments是指bind返回的函数传入的参数
          var bindArgs = Array.prototype.slice.call(arguments);
          return self.apply(context, args.concat(bindArgs));
      }
  
  }
  ```

#### 构造函数效果的实现

- 因为 bind 还有一个特点，就是

  > 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。

- 先来看一个例子

  ```js
  var value = 2;
  
  var foo = {
      value: 1
  };
  
  function bar(name, age) {
      this.habit = 'shopping';
      console.log(this.value);
      console.log(name);
      console.log(age);
  }
  
  bar.prototype.friend = 'kevin';
  
  var bindFoo = bar.bind(foo, 'daisy');
  
  var obj = new bindFoo('18');
  // undefined
  // daisy
  // 18
  console.log(obj.habit);
  console.log(obj.friend);
  // shopping
  // kevin
  ```

- **注意：**尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。

- 我们可以通过修改返回的函数的原型来实现，让我们写一下：

  ```js
  // 第三版
  Function.prototype.bind2 = function (context) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
  
      var fBound = function () {
          var bindArgs = Array.prototype.slice.call(arguments);
          // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
          // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
          // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
          return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));
      }
      // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
      fBound.prototype = this.prototype;
      return fBound;
  }
  ```

#### 构造函数效果的优化实现

- 但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：

  ```js
  Function.prototype.bind2 = function (context) {
  
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
  
      var fNOP = function () {};
  
      var fBound = function () {
          var bindArgs = Array.prototype.slice.call(arguments);
          return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
      }
  
      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();
      return fBound;
  }
  ```

#### 三个小问题

- 在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是：

  ```js
  self.apply(this instanceof self ? this : context || this, args.concat(bindArgs))
  ```

  - 多了一个关于 context 是否存在的判断，然而这个是错误的！
  - 举个例子：

  ```js
  var value = 2;
  var foo = {
      value: 1,
      bar: bar.bind(null)
  };
  
  function bar() {
      console.log(this.value);
  }
  
  foo.bar() // 2
  ```

  - 以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！
  - 所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！

- **调用 bind 的不是函数咋办？**

  ```js
  if (typeof this !== "function") {
    throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
  }
  ```

#### 最终代码

- ```js
  Function.prototype.bind2 = function (context) {
  
      if (typeof this !== "function") {
        throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
      }
  
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
  
      var fNOP = function () {};
  
      var fBound = function () {
          var bindArgs = Array.prototype.slice.call(arguments);
          return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
      }
  
      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();
      return fBound;
  }
  ```

## new()

- new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一

- 先来看一个例子

  ```js
  // Otaku 御宅族，简称宅
  function Otaku (name, age) {
      this.name = name;
      this.age = age;
  
      this.habit = 'Games';
  }
  
  // 因为缺乏锻炼的缘故，身体强度让人担忧
  Otaku.prototype.strength = 60;
  
  Otaku.prototype.sayYourName = function () {
      console.log('I am ' + this.name);
  }
  
  var person = new Otaku('Kevin', '18');
  
  console.log(person.name) // Kevin
  console.log(person.habit) // Games
  console.log(person.strength) // 60
  
  person.sayYourName(); // I am Kevin
  ```

- 从这个例子中，我们可以看到，实例 person 可以：

  - 访问到 Otaku 构造函数里的属性
  - 访问到 Otaku.prototype 中的属性

- 因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的：

  ```js
  function Otaku () {
      ……
  }
  
  // 使用 new
  var person = new Otaku(……);
  // 使用 objectFactory
  var person = objectFactory(Otaku, ……)
  ```

### 初步实现

- 因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku **构造函数里的属性**，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。

- 在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 __proto__ 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。

  ```js
  // 第一版代码
  function objectFactory() {
  
      var obj = new Object(),
  
      Constructor = [].shift.call(arguments);
  
      obj.__proto__ = Constructor.prototype;
  
      Constructor.apply(obj, arguments);
  
      return obj;
  
  };
  ```

  1. 用new Object() 的方式新建了一个对象 obj
  2. 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数
  3. 将 obj 的原型指向构造函数的原型，这样 obj 就可以访问到构造函数原型中的属性
  4. 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性，**其实是最传统的工厂模式**
  5. 返回 obj

### 返回值效果实现

- 接下来我们再来看一种情况，假如构造函数有返回值，举个例子：

  ```js
  function Otaku (name, age) {
      this.strength = 60;
      this.age = age;
  
      return {
          name: name,
          habit: 'Games'
      }
  }
  
  var person = new Otaku('Kevin', '18');
  
  console.log(person.name) // Kevin
  console.log(person.habit) // Games
  console.log(person.strength) // undefined
  console.log(person.age) // undefined
  ```

- 在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？

- 再举个例子：

  ```js
  function Otaku (name, age) {
      this.strength = 60;
      this.age = age;
  
      return 'handsome boy';
  }
  
  var person = new Otaku('Kevin', '18');
  
  console.log(person.name) // undefined
  console.log(person.habit) // undefined
  console.log(person.strength) // 60
  console.log(person.age) // 18
  ```

- 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。

- 所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。

- 再来看第二版的代码，也是最后一版的代码：

  ```js
  // 第二版的代码
  function objectFactory() {
  
      var obj = new Object(),
  
      Constructor = [].shift.call(arguments);
  
      obj.__proto__ = Constructor.prototype;
  
      var ret = Constructor.apply(obj, arguments);
  		// obj 已经经过工厂模式的修改
      return typeof ret === 'object' ? ret : obj;
  
  };
  ```

  

# 3. 面向对象高级

## 对象创建模式

### 方式一: Object构造函数模式

- 套路: 先创建空Object对象, 再动态添加属性/方法

- 适用场景: 起始时不确定对象内部数据

- 问题: 语句太多

### 方式二: 对象字面量模式

- 套路: 使用{}创建对象, 同时指定属性/方法

- 适用场景: 起始时对象内部数据是确定的，创建对象数量少

- 问题: 如果创建多个对象, 有重复代码

### 方式三: 工厂模式

- 套路: 通过工厂函数动态创建对象**并返回**

- 适用场景: 需要创建多个对象

-  问题: 对象没有一个具体的类型, 都是Object类型

### 方式四: 自定义构造函数模式

- 套路: 自定义构造函数, 通过new创建对象

- 适用场景: 需要创建多个类型确定的对象

- 问题: 每个对象都有相同的数据, 浪费内存

### 方式五：原型模式

### 方式六: 构造函数+原型的组合模式

- 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上

- 适用场景: 需要创建多个类型确定的对象

## 继承模式

### 原型链继承

- 步骤

1. 定义父类型构造函数

2. 给父类型的原型添加方法

3. 定义子类型的构造函数

4. 创建父类型的实例对象赋值给子类型的原型

5. 将子类型原型的构造属性设置为子类型的构造函数

6. 给子类型原型添加方法

7. 创建子类型的对象: 可以调用父类型的方法

- 关键

  - 子类型的原型为父类型的一个实例对象

  - 如果不去更改子类型的原型的constructor属性，则只能在父类型的原型中找到，所以最好更改constructor属性，指向子类型

![1547106232276](F:\OneDrive\JS\纲略合集\assets\1547106232276.png)

### 借用构造函数继承(假的)

- 步骤

1. 定义父类型构造函数

2. 定义子类型构造函数

3. 在子类型构造函数中调用父类型构造

- 关键:
  - 在子类型构造函数中通用call()调用父类型构造函数
  - 并没有真正的继承操作，实质是代码的简化

### 组合继承

- 原型链+借用构造函数的组合继承

- 利用原型链实现对父类型对象的方法继承

- 利用super()借用父类型构建函数初始化相同属性

![1547106660261](F:\OneDrive\JS\纲略合集\assets\1547106660261.png)

# 4. 线程机制与事件机制

## 进程与线程

### 理解

- 进程(process)：程序的一次执行, 它占有一片独有的内存空间
  - **进程是cpu资源分配的最小单位。系统会给它分配内存，是能拥有资源和独立运行的最小单位**
- 线程(thread)：是进程内独立执行的单元，线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程
  - 线程是cpu调度的最小单位

![1547106772414](F:\OneDrive\JS\纲略合集\assets\1547106772414.png)

- 进程与线程
  - 应用程序必须运行在某个进程的某个线程上

  - 一个进程中一般至少有一个运行的线程: **主线程**

  - 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的

  - **一个进程内的数据可以供其中的多个线程直接共享**

  - 进程之间是相互独立的，多个进程之间的数据是不能直接共享的

  - 线程池(thread pool)：保存多个线程对象的容器，实现线程对象的反复调用

- 多进程：一个应用程序可以同时启动多个进程运行

- 多线程：单个进程内，同时运行多个线程

- 看一个形象化的例子

  ```js
  工厂的资源 -> 系统分配的内存（独立的一块内存）
  
  工厂之间的相互独立 -> 进程之间相互独立
  
  多个工人协作完成任务 -> 多个线程在进程中协作完成任务
  
  工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成
  
  工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
  ```

+ > 不同进程之间也可以通信，不过代价较大
  >
  > 现在，一般通用的叫法：**单线程与多线程**，都是指**在一个进程内**的单和多。（所以核心还是得属于一个进程才行）

### 优缺点

- 多线程优点：：有效提高CPU的利用率

- 缺点：

  - 创建多线程开销

  - 线程间切换开销（单个CPU单位时间只运行一个线程）

  - 死锁与状态同步问题

- 单线程优点：顺序编程简单易懂

- 缺点：效率低

## JS是单线程执行的

- 如何证明js执行是单线程的?
  - setTimeout()的回调函数是在主线程执行的
  - 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行
  - alert()之后，暂停了主线程，也暂停了计时，不点确定，定时器的回调函数一直不会执行
- 为什么js要用单线程模式, 而不用多线程模式?
  - JavaScript的单线程，与它的用途有关。
  - 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。
  - 这决定了它只能是单线程，否则会带来很复杂的同步问题
  - 即是是支持多线程的JAVA，在开发安卓应用也只使用一个主线程操作UI，称作UI线程

- <https://www.cnblogs.com/Jacky-MYD/p/7743532.html>

## 浏览器是多进程的

### 浏览器是单进程还是多进程?

- 有的是单进程

  - firefox，最新版已经是多进程的了
  - 老版IE

- 有的是多进程

  - chrome
  - 新版IE

- 如何查看浏览器是否是多进程运行的呢?

  - 任务管理器==>进程

  - 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。

  - ![1553674399626](F:\OneDrive\JS\纲略合集\assets\1553674399626.png) 

  - > **注意：**在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的）

- 浏览器运行是**单线程**还是**多线程**?

  - 都是多线程运行的

### 浏览器都包含哪些进程？

#### Browser进程

+ 浏览器的主进程（负责协调、主控），只有一个
+ 主要的作用是：
  + 负责浏览器界面显示，与用户交互。如前进，后退等
  + 负责各个页面的管理，创建和销毁其他进程
  + 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
  + 网络资源的管理，下载等

#### 第三方插件进程

+ 每种类型的插件对应一个进程，仅当使用该插件时才创建

#### GPU进程

+ 最多一个，用于3D绘制等

#### 浏览器渲染进程

+ （浏览器内核、Renderer进程，内部是**多线程**的）：默认每个Tab页面一个进程，互不影响。
+ 主要作用为：
  + 页面渲染
  + 脚本执行
  + 事件处理等

### 浏览器多进程的优势

+ 相比于单进程浏览器，多进程有如下优点：
  + 避免单个page crash影响整个浏览器
  + 避免第三方插件crash影响整个浏览器
  + 多进程充分利用多核优势
  + 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性
+ 当然，内存等资源消耗也会更大

## 浏览器内核（渲染进程）

### 什么是浏览器内核?

- 支持浏览器运行的最核心的进程，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。

- 不同的浏览器可能不太一样

  - Chrome, Safari: webkit
  - firefox: Gecko
  - IE: Trident
  - 360,搜狗等国内浏览器: Trident + webkit


### 渲染进程由哪些线程?

#### GUI渲染线程

+ 负责**渲染**浏览器界面，**解析**HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
+ 当界面需要**重绘**（Repaint）或由于某种操作引发**回流**(reflow)时，该线程就会执行
+ 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。
+ GUI线程渲染结果多数情况下是一个位图 (Bitmap)，然后交给Browser进程显示..

#### JS引擎线程

+ 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
+ JS引擎线程负责解析Javascript脚本，运行代码。
+ JS引擎一直等待着**任务队列**中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
+ 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

#### 事件触发线程

+ 归属于浏览器而不是JS引擎，用来控制事件循环
  + 可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助
+ 当JS引擎执行代码块如setTimeout时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到**事件线程**中
+ 当对应的事件符合触发条件被触发时，该线程会把事件添加到任务队列的队尾，等待JS引擎的处理
+ 注意，由于JS的单线程关系，所以这些任务队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

#### 定时触发器线程

+ 传说中的`setInterval`与`setTimeout`所在线程

+ 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）

+ 因此通过单独线程来计时并触发定时（任务发起后，添加到事件队列中，等待JS引擎空闲后执行）

  > 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

#### 异步http请求线程

+ 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
+ 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入任务队列中。再由JavaScript引擎执行。

+ https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-6

### Browser进程 和 Renderer 进程的通信过程

+ 如果自己打开任务管理器，然后打开一个浏览器，就可以看到：**任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）**， 然后在这前提下，看下整个的过程：(简化了很多)
  + Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程
  + Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染
    - 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染
    - 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）
    - 最后Render进程将结果传递给Browser进程
  + Browser进程接收到结果并将结果绘制出来
+ 浏览器内核源码解析 https://www.cnblogs.com/lhb25/p/how-browsers-work.html

### 浏览器内核中线程之间的关系

#### GUI渲染线程与JS引擎线程互斥

+ 由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。
+ 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

#### JS阻塞页面加载

+ 从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。
+ 譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。
+ 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。


## 浏览器的事件循环（轮询）模型

### 理解

- 所有代码分类
  - 初始化执行代码(同步代码): 包含**绑定**dom事件监听, **设置**定时器, **发送**ajax请求的代码
  - 同步任务都在主线程上执行，形成一个 执行栈
  - 回调执行代码(异步代码): 处理回调逻辑（调用回调函数）
- js引擎执行代码的基本流程:
  - 初始化代码===>回调代码
- 模型的2个重要组成部分:
  - 事件(定时器/DOM事件/Ajax)管理模块（**事件触发线程**）
  - **事件触发线程**管理着一个`任务队列`，只要异步任务有了运行结果，就在`任务队列`之中放置一个事件。
  - 任务队列、消息队列、事件队列、回调队列，都OK
- 模型的运转流程

1. 执行初始化代码, 将事件回调函数交给事件触发线程管理，产生执行栈	

2. **当事件发生时, 事件触发线程将回调函数及其上数据添加到回调列队中**

3. 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取任务队列中的回调函数执行

- 模型概念图

![1547107412345](F:\OneDrive\JS\纲略合集\assets\1547107412345.png)

![1547107426240](F:\OneDrive\JS\纲略合集\assets\1547107426240.png)

### 一个完整异步过程：

1. **JS引擎线程**发一起一个异步请求
2. **相关线程**接收请求并告知主线程已收到通知
3. 主线程可以继续执行后面的代码，同时工作线程执行异步任务，并管理着回调函数
4. 事件发生，工作线程完成工作后，通知主线程
5. 主线程收到通知后，如果已经执行完了初始化的代码，会遍历读取回调队列（消息队列）中的回调函数执行

### 异步函数

- 通常具有以下的形式：A(args..., callbackFn);
- 它可以叫做异步过程的发起函数，或者叫做异步任务**注册函数**。
  - args是这个函数需要的参数
  - callbackFn（回调函数）也是这个函数的参数

- 所以，从主线程的角度看，一个异步过程包括下面两个要素：

1. 发起函数（或叫注册函数）A;

1. 回调函数callbackFn；

- 它们都是**主线程**上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。

```js
setTimeout（()=>{})，1000）；
//其中setTimeout就是异步过程的发起函数，function是回调函数。
```

```js
//注：前面说得形式A(args..., callbackFn)只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如：
　　var xhr = new XMLHttpRequest();
　　xhr.onreadystatechange = xxx;     // 添加回调函数
　　xhr.open('GET'， url);
　　xhr.send();   // 发起函数　　
//发起函数和回调函数是分离的。
```

### 消息队列和事件循环

- 工作线程将消息放到**消息队列，**主线程通过**事件循环**过程去取消息。

- 消息队列：消息队列是一个先进先出的**队列**，它里面存放这各种消息。

- 事件循环：事件循环是指主线程重复从消息队列中取消息，执行的**过程**。
  - 实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息、再取消息、再执行消息。
  - 当消息队列为空时，就会等待直到消息队列变成非空。
  - 而且主线程只有在将前面的消息执行完成后，才会去去下一个消息。
  - 这种机制就叫做**事件循环机制**，取一个消息并执行的过程叫做一次循环。

  ```js
  //事件循环代码表示大概是这样的：
  　　while（true）{
  　　　　var message = queue.get（）；
  　　　　execute（message）；
  　　}
  ```

- 消息队列中放的消息具体是什么？

  - 消息的具体结构当然跟具体实现有关，但是为了简单起见，我们可以认为：消息就是注册异步任务时添加的回调函数。

  ```js
  //再次以异步AJAX为例，假设存在如下的代码：
  　　$.ajax（'http://baidu.com'，function（res）{
  　　　　console.log（'我是响应'，res）；
  　　}）
  　　// 其他代码
  　　...
  　　...
  ```

- 主线程在发起AJAX请求后，会继续执行其他代码，AJAX线程负责请求http://baidu.com，拿到响应后，它会把响应封装成一个JavaScript对象，然后构造一条消息：

  ```js
  var message = function（）{
    callbackFn（response）；
  }
  //其中callbackFn就是就是前面代码中得到成功响应时的回调函数。
  ```

- 主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是message函数)，并执行它。
- 到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。
- 如果一开始主线程就没有提供回调函数，AJAX线程在收到HTTP响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。
- 用图表示这个过程就是：

　　![img](F:\OneDrive\JS\纲略合集\assets\1220270-20171027174149305-672812579-1547109462353.png)

- 从上文中我们也可以得到这样一个明显的结论，就是：**异步过程的回调函数，一定不在当前这一轮事件循环中执行。**

### 异步与事件

- 消息队列中的每条消息实际上都对应着一个事件。

- 上文中一直没有提到一类很重要的异步过程：DOM事件。

  ```js
  var button = document.getElement('#btn');
  	button.addEventListener('click', function(e) {
  	console.log();
  });
  ```

- 从事件的角度来看，上述代码表示：
  - 在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，**事件监听器函数**被调用。

- 从异步过程的角度看：
  - addEventListener函数就是异步过程的**发起函数**，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。

- **事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。**
- 我觉得它的存在是为了编程接口对开发者更友好。
- 另一方面，所有的异步过程也都可以用事件来描述。
- 例如：setTimeout可以看成对应一个时间到了！的事件。
- 前文的setTimeout(fn, 1000);可以看成：`timer.addEventListener('timeout', 1000, fn);`

## 定时触发器线程

+ 上述事件循环机制的核心是：JS引擎线程和事件触发线程

+ 为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。

+ 什么时候会用到定时器线程？**当使用setTimeout或setInterval时**，它需要定时器线程计时，计时完成后就会将特定的事件推入**事件队列**中。

  ```js
  setTimeout(function(){
      console.log('hello!');
  }, 1000);
  ```

+ 这段代码的作用是当`1000`毫秒计时完毕后（由定时器线程计时），将**回调函数推入事件队列**中，等待主线程执行

  ```js
  setTimeout(function(){
      console.log('hello!');
  }, 0);
  
  console.log('begin');
  ```

+ 这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行

  > 注意：
  >
  > 执行结果是：先`begin`后`hello!`
  >
  > 虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 (不过也有一说是不同浏览器有不同的最小时间设定)
  >
  > 就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行`begin`（因为只有可执行栈内空了后才会主动读取事件队列）

#### setTimeout而不是setInterval

+ 用setTimeout模拟定期计时和直接用setInterval是有区别的。
+ 因为每次setTimeout计时到后就会去执行回调，然后**执行一段时间后**才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关）
+ 而setInterval则是每次都精确的隔一段时间推入一个事件 
  + 因为有一个单独的线程在计时，但是，事件的实际执行时间不一定就准确，还有可能是这次的回调还没执行完毕，下一次的回调就来了
+ 而且setInterval有一些比较致命的问题就是：
  + 累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行， 就会导致定时器代码连续运行好几次，而之间没有间隔。 就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）
  + 而且把浏览器最小化显示等操作时，setInterval并不是不执行程序， 它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时
+ 所以，鉴于这么多但问题，目前一般认为的最佳方案是：**用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame**

## macrotask与microtask

+ 在ES6中，Promise里有了一个一个新的概念：`microtask`
+ 进一步，JS中分为两种任务类型：**macrotask和microtask**，在ECMAScript中，microtask称为`jobs`，macrotask可称为`task`

### macrotask

+ 又称之为宏任务，可以理解是每次**执行栈执行的代码**就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
+ 每一个task会从头到尾将这个任务执行完毕，不会执行其它
+ 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （`task->渲染->task->...`）

### microtask

+ 又称为微任务，可以理解是在当前 task 执行结束后立即执行的任务
  + 也就是说，在当前task任务后，下一个task之前，在渲染之前
  + 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
  + 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）

### 

+ macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）

+ microtask：Promise，process.nextTick等

  > **补充：在node环境下，process.nextTick的优先级高于Promise**，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。

+ 再根据线程来理解下：

  + macrotask中的事件都是放在**一个事件队列**中的，而这个队列由**事件触发线程**维护
  + microtask中的所有微任务都是添加到**微任务队列**（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由**JS引擎线程维护** （这点由自己理解+推测得出，因为它是在主线程下无缝执行的）

+ 所以，总结下运行机制：

  + 执行一个宏任务（栈中没有就从事件队列中获取）
  + 执行过程中如果遇到微任务，就将它添加到微任务的 Job Queues 中
  + 宏任务执行完毕后，执行这个task宏任务期间发生的所有job微任务
  + 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
  + 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

+ promise.all 和 单独的promise一样，只不过多个primise的逻辑在all方法内实现，最终都是**一个**micro-task挂载到队列上。

+ > 小知识：[babel中对于微任务的polyfill](https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzloirock%2Fcore-js%2Fblob%2Fmaster%2Fpackages%2Fcore-js%2Finternals%2Ftask.js)，如果是拥有`setImmediate`函数平台，则使用之，若没有则自定义则利用各种比如nodejs中的`process.nextTick`，浏览器中支持`postMessage`的，或者是通过create一个script来实现微任务(microtask)。最终的最终，是使用setTimeout，不过这个就和微任务无关了，promise变成了宏任务的一员。

### 使用MutationObserver实现microtask

+ MutationObserver可以用来实现microtask （它属于microtask，优先级小于Promise， 一般是Promise不支持时才会这样做）

+ 它是HTML5中的新特性，作用是：监听一个DOM变动， 当DOM对象树发生任何变动时，Mutation Observer会得到通知

+ 像以前的Vue源码中就是利用它来模拟nextTick的， 具体原理是，创建一个TextNode并监听内容变化， 然后要nextTick的时候去改一下这个节点的文本内容， 如下：（Vue的源码，未修改）

  ```js
  var counter = 1
  var observer = new MutationObserver(nextTickHandler)
  var textNode = document.createTextNode(String(counter))
  
  observer.observe(textNode, {
      characterData: true
  })
  timerFunc = () => {
      counter = (counter + 1) % 2
      textNode.data = String(counter)
  }
  ```

+ 不过，现在的Vue（2.5+）的nextTick实现移除了MutationObserver的方式（据说是兼容性原因）， 取而代之的是使用MessageChannel （当然，默认情况仍然是Promise，不支持才兼容的）。

+ MessageChannel属于宏任务，优先级是：`MessageChannel->setTimeout`， 所以Vue（2.5+）内部的nextTick与2.4及之前的实现是不一样的，需要注意下。

+ https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-17

## H5 Web Workers（多线程）

- H5规范提供了js分线程的实现, 取名为: Web Workers

  - 我们可以将一些计算量大的代码，交由web workers运行而不冻结用户界面
- 创建Worker时，JS引擎向浏览器申请开一个子线程，但是子线程完全受主线程控制，且不得操纵DOM。所以这个新标准，并没有改变JS的本质
- 一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件   这个文件包含将在工作线程中运行的代码; 
- workers 运行在另一个全局上下文中,不同于当前的 window 因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误
- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

### 相关API

- Worker: 构造函数, 加载分线程执行的js文件
  - `var workers = new Worker(‘worker.js’)`

- Worker.prototype.onmessage: 用于接收另一个线程的回调函数

- Worker.prototype.postMessage: 向另一个线程发送消息

### 不足

- worker内代码不能操作DOM(更新UI)
  - 因为全局对象不再是window，没有方法了

- 不能跨域加载JS

- 不是每个浏览器都支持这个新特性

![1547107490966](F:\OneDrive\JS\纲略合集\assets\1547107490966.png)

### WebWorker与SharedWorker

- WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享
  - 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。
- SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用
  - 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。

+ 看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程